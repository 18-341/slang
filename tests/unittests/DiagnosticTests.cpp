#include "Test.h"

TEST_CASE("Diagnostic Line Number") {
    auto& text = "`include \"foofile\"\nident";

    // Include a file that doesn't exist, we should still parse the identifier
    // on the next line, but have a diagnostic error on line 1
    Token token = lexToken(text);

    CHECK(token.kind == TokenKind::Identifier);
    CHECK(token.valueText() == "ident");
    CHECK(diagnostics.size() == 1);
    std::string message = to_string(diagnostics[0]);
    int bufNum, line, col;
    sscanf(message.c_str(), "<unnamed_buffer%d>:%d:%d", &bufNum, &line, &col);
    CHECK(line == 1);
    CHECK(col == 10);
}

TEST_CASE("Diagnostic reporting with `line") {
    auto& text = "`line 100 \"foo.svh\" 0\n"
                 "`include \"foofile\"\n"
                 "ident";

    lexToken(text);
    CHECK(diagnostics.size() == 1);
    std::string message = to_string(diagnostics[0]);
    int line, col;
    int matches = sscanf(message.c_str(), "foo.svh:%d:%d", &line, &col);
    REQUIRE(matches == 2);
    CHECK(line == 100);
    CHECK(col == 10);
}

TEST_CASE("undef errors") {
    // There are errors for attempting to undef a built-in
    // and also for missing the token of what to undef altogether
    // make sure we only give an error about one at a time
    auto& text = "`undef\n";
    Token token = lexToken(text);

    CHECK(token.kind == TokenKind::EndOfFile);

    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == DiagCode::ExpectedIdentifier);

    auto& text2 = "`undef __LINE__\n";
    token = lexToken(text2);

    CHECK(token.kind == TokenKind::EndOfFile);

    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == DiagCode::UndefineBuiltinDirective);
}

TEST_CASE("keywords_errors") {
    // verify all the correct errors are generated by the keywords macros
    auto& text = "`begin_keywords \"foo\"\n";

    Token token = lexToken(text);
    CHECK(token.kind == TokenKind::EndOfFile);
    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == DiagCode::UnrecognizedKeywordVersion);

    auto& text2 = "`begin_keywords\n";

    token = lexToken(text2);
    CHECK(token.kind == TokenKind::EndOfFile);
    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == DiagCode::ExpectedStringLiteral);

    auto& text3 = "`end_keywords\n";

    token = lexToken(text3);
    CHECK(token.kind == TokenKind::EndOfFile);
    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == DiagCode::MismatchedEndKeywordsDirective);
}
