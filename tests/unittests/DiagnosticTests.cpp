#include "Test.h"

TEST_CASE("Diagnostic Line Number") {
    auto& text = "`include \"foofile\"\nident";

    // Include a file that doesn't exist, we should still parse the identifier
    // on the next line, but have a diagnostic error on line 1
    Token token = lexToken(text);

    CHECK(token.kind == TokenKind::Identifier);
    CHECK(token.valueText() == "ident");
    CHECK(diagnostics.size() == 1);
    std::string message = to_string(diagnostics[0]);
    int bufNum, line, col;
    sscanf(message.c_str(), "<unnamed_buffer%d>:%d:%d", &bufNum, &line, &col);
    CHECK(line == 1);
    CHECK(col == 10);
}

TEST_CASE("Diagnostic reporting with `line") {
    auto& text = "`line 100 \"foo.svh\" 0\n"
                 "`include \"foofile\"\n"
                 "ident";

    lexToken(text);
    CHECK(diagnostics.size() == 1);
    std::string message = to_string(diagnostics[0]);
    int line, col;
    int matches = sscanf(message.c_str(), "foo.svh:%d:%d", &line, &col);
    REQUIRE(matches == 2);
    CHECK(line == 100);
    CHECK(col == 10);
}

TEST_CASE("undef errors") {
    // There are errors for attempting to undef a built-in
    // and also for missing the token of what to undef altogether
    // make sure we only give an error about one at a time
    auto& text = "`undef\n";
    Token token = lexToken(text);

    CHECK(token.kind == TokenKind::EndOfFile);

    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == diag::ExpectedIdentifier);

    auto& text2 = "`undef __LINE__\n";
    token = lexToken(text2);

    CHECK(token.kind == TokenKind::EndOfFile);

    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == diag::UndefineBuiltinDirective);
}

TEST_CASE("keywords_errors") {
    // verify all the correct errors are generated by the keywords macros
    auto& text = "`begin_keywords \"foo\"\n";

    Token token = lexToken(text);
    CHECK(token.kind == TokenKind::EndOfFile);
    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == diag::UnrecognizedKeywordVersion);

    auto& text2 = "`begin_keywords\n";

    token = lexToken(text2);
    CHECK(token.kind == TokenKind::EndOfFile);
    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == diag::ExpectedStringLiteral);

    auto& text3 = "`end_keywords\n";

    token = lexToken(text3);
    CHECK(token.kind == TokenKind::EndOfFile);
    REQUIRE(diagnostics.size() == 1);
    CHECK(diagnostics[0].code == diag::MismatchedEndKeywordsDirective);
}

TEST_CASE("Diag within macro arg") {
    auto tree = SyntaxTree::fromText(R"(
`define FOO(blah) blah
`define BAR(blah) `FOO(blah)

module m;
    struct { } asdf;
    int i = `BAR(asdf.bar);
endmodule

)",
                                     "source");

    Compilation compilation;
    compilation.addSyntaxTree(tree);

    auto& diagnostics = compilation.getAllDiagnostics();
    std::string result = "\n" + report(diagnostics);
    CHECK(result == R"(
source:7:23: error: no member named 'bar' in '<unnamed unpacked struct>'
    int i = `BAR(asdf.bar);
                 ~~~~~^~~
source:3:24: note: expanded from macro 'BAR'
`define BAR(blah) `FOO(blah)
                       ^~~~
source:2:19: note: expanded from macro 'FOO'
`define FOO(blah) blah
                  ^~~~
)");
}

TEST_CASE("Diag within macro body") {
    auto tree = SyntaxTree::fromText(R"(
`define FOO(blah) blah.bar
`define BAR(blah) `FOO(blah)

module m;
    struct { } asdf;
    int i = `BAR(asdf);
endmodule

)",
                                     "source");

    Compilation compilation;
    compilation.addSyntaxTree(tree);

    auto& diagnostics = compilation.getAllDiagnostics();
    std::string result = "\n" + report(diagnostics);
    CHECK(result == R"(
source:7:13: error: no member named 'bar' in '<unnamed unpacked struct>'
    int i = `BAR(asdf);
            ^~~~~~~~~~
source:3:19: note: expanded from macro 'BAR'
`define BAR(blah) `FOO(blah)
                  ^~~~~~~~~~
source:2:24: note: expanded from macro 'FOO'
`define FOO(blah) blah.bar
                  ~~~~~^~~
)");
}

TEST_CASE("Diag range within arg and caret within body") {
    auto tree = SyntaxTree::fromText(R"(
`define FOO(blah) blah++
`define BAR(blah) `FOO(blah)

module m;
    struct { } asdf;
    int i = `BAR(asdf);
endmodule

)",
                                     "source");

    Compilation compilation;
    compilation.addSyntaxTree(tree);

    auto& diagnostics = compilation.getAllDiagnostics();
    std::string result = "\n" + report(diagnostics);
    CHECK(result == R"(
source:7:13: error: invalid operand type '<unnamed unpacked struct>' to unary expression
    int i = `BAR(asdf);
            ^    ~~~~
source:3:19: note: expanded from macro 'BAR'
`define BAR(blah) `FOO(blah)
                  ^    ~~~~
source:2:23: note: expanded from macro 'FOO'
`define FOO(blah) blah++
                  ~~~~^
)");
}

TEST_CASE("Diag caret within macro arg only") {
    auto tree = SyntaxTree::fromText(R"(
`define FOO(blah) blah
`define BAR(blah) `FOO(blah)

module m;
    int i = `BAR(++);
endmodule

)",
                                     "source");

    Compilation compilation;
    compilation.addSyntaxTree(tree);

    auto& diagnostics = compilation.getAllDiagnostics();
    std::string result = "\n" + report(diagnostics);
    CHECK(result == R"(
source:6:21: error: expected expression
    int i = `BAR(++);
                    ^
)");
}

TEST_CASE("Diag range split across args") {
    auto tree = SyntaxTree::fromText(R"(
`define BAZ(xy) xy
`define FOO(blah, flurb) blah+`BAZ(flurb)
`define BAR(blah, flurb) `FOO(blah, flurb)

module m;
    struct { } asdf;
    struct { } bar;
    int i = `BAR(asdf, bar);
endmodule

)",
                                     "source");

    Compilation compilation;
    compilation.addSyntaxTree(tree);

    auto& diagnostics = compilation.getAllDiagnostics();
    std::string result = "\n" + report(diagnostics);
    CHECK(result == R"(
source:9:13: error: invalid operands to binary expression ('<unnamed unpacked struct>' and '<unnamed unpacked struct>')
    int i = `BAR(asdf, bar);
            ^    ~~~~  ~~~
source:4:26: note: expanded from macro 'BAR'
`define BAR(blah, flurb) `FOO(blah, flurb)
                         ^    ~~~~  ~~~~~
source:3:30: note: expanded from macro 'FOO'
`define FOO(blah, flurb) blah+`BAZ(flurb)
                         ~~~~^     ~~~~~
)");
}

TEST_CASE("Diag macro args with split locations") {
    auto tree = SyntaxTree::fromText(R"(
`define FOO(abc) abc
`define BAR(blah, flurb) `FOO(blah + flurb)

module m;
    struct { } asdf;
    struct { } bar;
    int i = `BAR(asdf, bar);
endmodule

)",
                                     "source");

    Compilation compilation;
    compilation.addSyntaxTree(tree);

    auto& diagnostics = compilation.getAllDiagnostics();
    std::string result = "\n" + report(diagnostics);
    CHECK(result == R"(
source:8:13: error: invalid operands to binary expression ('<unnamed unpacked struct>' and '<unnamed unpacked struct>')
    int i = `BAR(asdf, bar);
            ^    ~~~~  ~~~
source:3:36: note: expanded from macro 'BAR'
`define BAR(blah, flurb) `FOO(blah + flurb)
                              ~~~~ ^ ~~~~~
source:2:18: note: expanded from macro 'FOO'
`define FOO(abc) abc
                 ^~~
)");
}