#pragma once

#include "SyntaxNode.h"
#include "Token.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the tools/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DataTypeSyntax : public SyntaxNode {

    DataTypeSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    ExpressionSyntax* expr;

    OrderedArgumentSyntax(ExpressionSyntax* expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token* dot;
    Token* name;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;

    NamedArgumentSyntax(Token* dot, Token* name, Token* openParen, ExpressionSyntax* expr, Token* closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct ArgumentListSyntax : public SyntaxNode {
    Token* openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token* closeParen;

    ArgumentListSyntax(Token* openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token* closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &parameters;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token* hash;
    ArgumentListSyntax* parameters;

    ParameterValueAssignmentSyntax(Token* hash, ArgumentListSyntax* parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return hash;
            case 1: return parameters;
            default: return nullptr;
        }
    }
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct VariablePatternSyntax : public PatternSyntax {
    Token* dot;
    Token* variableName;

    VariablePatternSyntax(Token* dot, Token* variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return variableName;
            default: return nullptr;
        }
    }
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token* dotStar;

    WildcardPatternSyntax(Token* dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dotStar;
            default: return nullptr;
        }
    }
};

struct ExpressionPatternSyntax : public PatternSyntax {
    ExpressionSyntax* expr;

    ExpressionPatternSyntax(ExpressionSyntax* expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token* tagged;
    Token* memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token* tagged, Token* memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return tagged;
            case 1: return memberName;
            case 2: return pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    PatternSyntax* pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax* pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(pattern)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return pattern;
            default: return nullptr;
        }
    }
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token* name;
    Token* colon;
    PatternSyntax* pattern;

    NamedStructurePatternMemberSyntax(Token* name, Token* colon, PatternSyntax* pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return colon;
            case 2: return pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternSyntax : public PatternSyntax {
    Token* openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token* closeBrace;

    StructurePatternSyntax(Token* openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token* closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return &members;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token* matchesKeyword;
    PatternSyntax* pattern;

    MatchesClauseSyntax(Token* matchesKeyword, PatternSyntax* pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(pattern)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return matchesKeyword;
            case 1: return pattern;
            default: return nullptr;
        }
    }
};

struct ConditionalPatternSyntax : public SyntaxNode {
    ExpressionSyntax* expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax* expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(expr), matchesClause(matchesClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            case 1: return matchesClause;
            default: return nullptr;
        }
    }
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &conditions;
            default: return nullptr;
        }
    }
};

// ----- EXPRESSIONS -----

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token* operatorToken;
    ExpressionSyntax* operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token* operatorToken, ExpressionSyntax* operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), operand(operand)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return operatorToken;
            case 1: return operand;
            default: return nullptr;
        }
    }
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* operand;
    Token* operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax* operand, Token* operatorToken) :
        ExpressionSyntax(kind), operand(operand), operatorToken(operatorToken)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return operand;
            case 1: return operatorToken;
            default: return nullptr;
        }
    }
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token* operatorToken;
    ExpressionSyntax* right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax* left, Token* operatorToken, ExpressionSyntax* right) :
        ExpressionSyntax(kind), left(left), operatorToken(operatorToken), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* min;
    Token* colon1;
    ExpressionSyntax* typ;
    Token* colon2;
    ExpressionSyntax* max;

    MinTypMaxExpressionSyntax(ExpressionSyntax* min, Token* colon1, ExpressionSyntax* typ, Token* colon2, ExpressionSyntax* max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(min), colon1(colon1), typ(typ), colon2(colon2), max(max)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return min;
            case 1: return colon1;
            case 2: return typ;
            case 3: return colon2;
            case 4: return max;
            default: return nullptr;
        }
    }
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token* tagged;
    Token* member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token* tagged, Token* member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return tagged;
            case 1: return member;
            case 2: return expr;
            default: return nullptr;
        }
    }
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* expr;
    Token* inside;
    Token* openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token* closeBrace;

    InsideExpressionSyntax(ExpressionSyntax* expr, Token* inside, Token* openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token* closeBrace) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(expr), inside(inside), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            case 1: return inside;
            case 2: return openBrace;
            case 3: return &valueRanges;
            case 4: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    ConditionalPredicateSyntax* predicate;
    Token* question;
    ExpressionSyntax* left;
    Token* colon;
    ExpressionSyntax* right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax* predicate, Token* question, ExpressionSyntax* left, Token* colon, ExpressionSyntax* right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(predicate), question(question), left(left), colon(colon), right(right)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return predicate;
            case 1: return question;
            case 2: return left;
            case 3: return colon;
            case 4: return right;
            default: return nullptr;
        }
    }
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BitSelectSyntax : public SelectorSyntax {
    ExpressionSyntax* expr;

    BitSelectSyntax(ExpressionSyntax* expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct RangeSelectSyntax : public SelectorSyntax {
    ExpressionSyntax* left;
    Token* range;
    ExpressionSyntax* right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax* left, Token* range, ExpressionSyntax* right) :
        SelectorSyntax(kind), left(left), range(range), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return range;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token* openBracket;
    SelectorSyntax* selector;
    Token* closeBracket;

    ElementSelectSyntax(Token* openBracket, SelectorSyntax* selector, Token* closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBracket;
            case 1: return selector;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct IdentifierNameSyntax : public NameSyntax {
    Token* identifier;

    IdentifierNameSyntax(Token* identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return identifier;
            default: return nullptr;
        }
    }
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token* identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token* identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return identifier;
            case 1: return &selectors;
            default: return nullptr;
        }
    }
};

struct KeywordNameSyntax : public NameSyntax {
    Token* keyword;

    KeywordNameSyntax(SyntaxKind kind, Token* keyword) :
        NameSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct ClassNameSyntax : public NameSyntax {
    Token* identifier;
    ParameterValueAssignmentSyntax* parameters;

    ClassNameSyntax(Token* identifier, ParameterValueAssignmentSyntax* parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return identifier;
            case 1: return parameters;
            default: return nullptr;
        }
    }
};

struct ScopedNameSyntax : public NameSyntax {
    NameSyntax* left;
    Token* separator;
    NameSyntax* right;

    ScopedNameSyntax(NameSyntax* left, Token* separator, NameSyntax* right) :
        NameSyntax(SyntaxKind::ScopedName), left(left), separator(separator), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return separator;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ClassScopeSyntax : public SyntaxNode {
    NameSyntax* left;
    Token* separator;

    ClassScopeSyntax(NameSyntax* left, Token* separator) :
        SyntaxNode(SyntaxKind::ClassScope), left(left), separator(separator)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return separator;
            default: return nullptr;
        }
    }
};

// ----- PRIMARY EXPRESSIONS -----

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token* literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token* literal) :
        PrimaryExpressionSyntax(kind), literal(literal)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return literal;
            default: return nullptr;
        }
    }
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    Token* closeBrace;

    EmptyQueueExpressionSyntax(Token* openBrace, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token* closeBrace;

    ConcatenationExpressionSyntax(Token* openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return &expressions;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    ExpressionSyntax* expression;
    ConcatenationExpressionSyntax* concatenation;
    Token* closeBrace;

    MultipleConcatenationExpressionSyntax(Token* openBrace, ExpressionSyntax* expression, ConcatenationExpressionSyntax* concatenation, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(expression), concatenation(concatenation), closeBrace(closeBrace)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return expression;
            case 2: return concatenation;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token* withKeyword;
    ElementSelectSyntax* range;

    StreamExpressionWithRange(Token* withKeyword, ElementSelectSyntax* range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(range)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return withKeyword;
            case 1: return range;
            default: return nullptr;
        }
    }
};

struct StreamExpressionSyntax : public SyntaxNode {
    ExpressionSyntax* expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax* expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(expression), withRange(withRange)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expression;
            case 1: return withRange;
            default: return nullptr;
        }
    }
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    Token* operatorToken;
    ExpressionSyntax* sliceSize;
    Token* innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token* innerCloseBrace;
    Token* closeBrace;

    StreamingConcatenationExpressionSyntax(Token* openBrace, Token* operatorToken, ExpressionSyntax* sliceSize, Token* innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token* innerCloseBrace, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return operatorToken;
            case 2: return sliceSize;
            case 3: return innerOpenBrace;
            case 4: return &expressions;
            case 5: return innerCloseBrace;
            case 6: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openParen;
    ExpressionSyntax* expression;
    Token* closeParen;

    ParenthesizedExpressionSyntax(Token* openParen, ExpressionSyntax* expression, Token* closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(expression), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return expression;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax* classScope;
    Token* newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax* classScope, Token* newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return classScope;
            case 1: return newKeyword;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token* newKeyword;
    Token* openBracket;
    ExpressionSyntax* sizeExpr;
    Token* closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token* newKeyword, Token* openBracket, ExpressionSyntax* sizeExpr, Token* closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(sizeExpr), closeBracket(closeBracket), initializer(initializer)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return newKeyword;
            case 1: return openBracket;
            case 2: return sizeExpr;
            case 3: return closeBracket;
            case 4: return initializer;
            default: return nullptr;
        }
    }
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    ElementSelectSyntax* select;

    ElementSelectExpressionSyntax(ExpressionSyntax* left, ElementSelectSyntax* select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(left), select(select)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return select;
            default: return nullptr;
        }
    }
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token* dot;
    Token* name;

    MemberAccessExpressionSyntax(ExpressionSyntax* left, Token* dot, Token* name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(left), dot(dot), name(name)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return dot;
            case 2: return name;
            default: return nullptr;
        }
    }
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax* left, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(left), arguments(arguments)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return arguments;
            default: return nullptr;
        }
    }
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DelayControlSyntax : public TimingControlSyntax {
    Token* hash;
    ExpressionSyntax* delayValue;

    DelayControlSyntax(Token* hash, ExpressionSyntax* delayValue) :
        TimingControlSyntax(SyntaxKind::DelayControl), hash(hash), delayValue(delayValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return hash;
            case 1: return delayValue;
            default: return nullptr;
        }
    }
};

struct CycleDelaySyntax : public TimingControlSyntax {
    Token* doubleHash;
    ExpressionSyntax* delayValue;

    CycleDelaySyntax(Token* doubleHash, ExpressionSyntax* delayValue) :
        TimingControlSyntax(SyntaxKind::CycleDelay), doubleHash(doubleHash), delayValue(delayValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return doubleHash;
            case 1: return delayValue;
            default: return nullptr;
        }
    }
};

struct EventControlSyntax : public TimingControlSyntax {
    Token* at;
    NameSyntax* eventName;

    EventControlSyntax(Token* at, NameSyntax* eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(eventName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return at;
            case 1: return eventName;
            default: return nullptr;
        }
    }
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct IffClauseSyntax : public SyntaxNode {
    Token* iff;
    ExpressionSyntax* expr;

    IffClauseSyntax(Token* iff, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return iff;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token* edge;
    ExpressionSyntax* expr;
    IffClauseSyntax* iffClause;

    SignalEventExpressionSyntax(Token* edge, ExpressionSyntax* expr, IffClauseSyntax* iffClause) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(expr), iffClause(iffClause)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return edge;
            case 1: return expr;
            case 2: return iffClause;
            default: return nullptr;
        }
    }
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    EventExpressionSyntax* left;
    Token* operatorToken;
    EventExpressionSyntax* right;

    BinaryEventExpressionSyntax(EventExpressionSyntax* left, Token* operatorToken, EventExpressionSyntax* right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(left), operatorToken(operatorToken), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token* openParen;
    EventExpressionSyntax* expr;
    Token* closeParen;

    ParenthesizedEventExpressionSyntax(Token* openParen, EventExpressionSyntax* expr, Token* closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return expr;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token* atStar;

    ImplicitEventControlSyntax(Token* atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return atStar;
            default: return nullptr;
        }
    }
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token* at;
    Token* openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token* at, Token* openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return at;
            case 1: return openParenStarCloseParen;
            default: return nullptr;
        }
    }
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token* at;
    EventExpressionSyntax* expr;

    EventControlWithExpressionSyntax(Token* at, EventExpressionSyntax* expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return at;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token* repeat;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token* repeat, Token* openParen, ExpressionSyntax* expr, Token* closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(expr), closeParen(closeParen), eventControl(eventControl)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return repeat;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            case 4: return eventControl;
            default: return nullptr;
        }
    }
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    ExpressionSyntax* left;
    Token* colon;
    ExpressionSyntax* right;

    RangeDimensionSpecifierSyntax(ExpressionSyntax* left, Token* colon, ExpressionSyntax* right) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), left(left), colon(colon), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return colon;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ExpressionDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    ExpressionSyntax* expr;

    ExpressionDimensionSpecifierSyntax(ExpressionSyntax* expr) :
        DimensionSpecifierSyntax(SyntaxKind::ExpressionDimensionSpecifier), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct DataTypeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    DataTypeSyntax* type;

    DataTypeDimensionSpecifierSyntax(DataTypeSyntax* type) :
        DimensionSpecifierSyntax(SyntaxKind::DataTypeDimensionSpecifier), type(type)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return type;
            default: return nullptr;
        }
    }
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token* star;

    WildcardDimensionSpecifierSyntax(Token* star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return star;
            default: return nullptr;
        }
    }
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token* colon;
    ExpressionSyntax* expr;

    ColonExpressionClauseSyntax(Token* colon, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return colon;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token* dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token* dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dollar;
            case 1: return maxSizeClause;
            default: return nullptr;
        }
    }
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token* openBracket;
    DimensionSpecifierSyntax* specifier;
    Token* closeBracket;

    VariableDimensionSyntax(Token* openBracket, DimensionSpecifierSyntax* specifier, Token* closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token* equals;
    ExpressionSyntax* expr;

    EqualsValueClauseSyntax(Token* equals, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return equals;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token* name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token* name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return initializer;
            default: return nullptr;
        }
    }
};

struct DataDeclarationSyntax : public SyntaxNode {
    Token* constKeyword;
    Token* varKeyword;
    Token* lifetime;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token* semi;

    DataDeclarationSyntax(Token* constKeyword, Token* varKeyword, Token* lifetime, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token* semi) :
        SyntaxNode(SyntaxKind::DataDeclaration), constKeyword(constKeyword), varKeyword(varKeyword), lifetime(lifetime), type(type), declarators(declarators), semi(semi)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return constKeyword;
            case 1: return varKeyword;
            case 2: return lifetime;
            case 3: return type;
            case 4: return &declarators;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token* keyword;
    Token* signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token* keyword, Token* signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return signing;
            case 2: return &dimensions;
            default: return nullptr;
        }
    }
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token* keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token* keyword) :
        DataTypeSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct NamedTypeSyntax : public DataTypeSyntax {
    NameSyntax* name;

    NamedTypeSyntax(NameSyntax* name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(name)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            default: return nullptr;
        }
    }
};

struct StructUnionMemberSyntax : public SyntaxNode {
    Token* randomQualifier;
    DataTypeSyntax* type;
    SyntaxList<VariableDeclaratorSyntax> declarators;
    Token* semi;

    StructUnionMemberSyntax(Token* randomQualifier, DataTypeSyntax* type, SyntaxList<VariableDeclaratorSyntax> declarators, Token* semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), randomQualifier(randomQualifier), type(type), declarators(declarators), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return randomQualifier;
            case 1: return type;
            case 2: return &declarators;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token* keyword;
    Token* tagged;
    Token* packed;
    Token* signing;
    Token* openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token* closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token* keyword, Token* tagged, Token* packed, Token* signing, Token* openBrace, SyntaxList<StructUnionMemberSyntax> members, Token* closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return tagged;
            case 2: return packed;
            case 3: return signing;
            case 4: return openBrace;
            case 5: return &members;
            case 6: return closeBrace;
            case 7: return &dimensions;
            default: return nullptr;
        }
    }
};

struct EnumNameDeclarationSyntax : public SyntaxNode {
    Token* name;
    VariableDimensionSyntax* dimension;
    EqualsValueClauseSyntax* initializer;

    EnumNameDeclarationSyntax(Token* name, VariableDimensionSyntax* dimension, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::EnumNameDeclaration), name(name), dimension(dimension), initializer(initializer)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return dimension;
            case 2: return initializer;
            default: return nullptr;
        }
    }
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token* keyword;
    DataTypeSyntax* baseType;
    Token* openBrace;
    SyntaxList<EnumNameDeclarationSyntax> members;
    Token* closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token* keyword, DataTypeSyntax* baseType, Token* openBrace, SyntaxList<EnumNameDeclarationSyntax> members, Token* closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return baseType;
            case 2: return openBrace;
            case 3: return &members;
            case 4: return closeBrace;
            case 5: return &dimensions;
            default: return nullptr;
        }
    }
};

struct ExpressionTypeReferenceSyntax : public DataTypeSyntax {
    Token* typeKeyword;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;

    ExpressionTypeReferenceSyntax(Token* typeKeyword, Token* openParen, ExpressionSyntax* expr, Token* closeParen) :
        DataTypeSyntax(SyntaxKind::ExpressionTypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct DataTypeReferenceSyntax : public DataTypeSyntax {
    Token* typeKeyword;
    Token* openParen;
    DataTypeSyntax* type;
    Token* closeParen;

    DataTypeReferenceSyntax(Token* typeKeyword, Token* openParen, DataTypeSyntax* type, Token* closeParen) :
        DataTypeSyntax(SyntaxKind::DataTypeReference), typeKeyword(typeKeyword), openParen(openParen), type(type), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return type;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token* dot;
    Token* member;

    DotMemberClauseSyntax(Token* dot, Token* member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return member;
            default: return nullptr;
        }
    }
};

struct VirtualInterfaceTypeSyntax : public SyntaxNode {
    Token* virtualKeyword;
    Token* interfaceKeyword;
    Token* name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token* virtualKeyword, Token* interfaceKeyword, Token* name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        SyntaxNode(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return virtualKeyword;
            case 1: return interfaceKeyword;
            case 2: return name;
            case 3: return parameters;
            case 4: return modport;
            default: return nullptr;
        }
    }
};

struct ImplicitTypeSyntax : public SyntaxNode {
    Token* signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token* signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        SyntaxNode(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return signing;
            case 1: return &dimensions;
            default: return nullptr;
        }
    }
};

// ----- STATEMENTS -----

struct StatementSyntax : public SyntaxNode {

    StatementSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct EmptyStatementSyntax : public StatementSyntax {
    Token* semicolon;

    EmptyStatementSyntax(Token* semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement), semicolon(semicolon)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return semicolon;
            default: return nullptr;
        }
    }
};

struct ElseClauseSyntax : public SyntaxNode {
    Token* elseKeyword;
    StatementSyntax* statement;

    ElseClauseSyntax(Token* elseKeyword, StatementSyntax* statement) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return elseKeyword;
            case 1: return statement;
            default: return nullptr;
        }
    }
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token* uniqueOrPriority;
    Token* ifKeyword;
    Token* openParen;
    ConditionalPredicateSyntax* predicate;
    Token* closeParen;
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(Token* uniqueOrPriority, Token* ifKeyword, Token* openParen, ConditionalPredicateSyntax* predicate, Token* closeParen, StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(predicate), closeParen(closeParen), statement(statement), elseClause(elseClause)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return uniqueOrPriority;
            case 1: return ifKeyword;
            case 2: return openParen;
            case 3: return predicate;
            case 4: return closeParen;
            case 5: return statement;
            case 6: return elseClause;
            default: return nullptr;
        }
    }
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token* defaultKeyword;
    Token* colon;
    StatementSyntax* statement;

    DefaultCaseItemSyntax(Token* defaultKeyword, Token* colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return defaultKeyword;
            case 1: return colon;
            case 2: return statement;
            default: return nullptr;
        }
    }
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    PatternSyntax* pattern;
    Token* tripleAnd;
    ExpressionSyntax* expr;
    Token* colon;
    StatementSyntax* statement;

    PatternCaseItemSyntax(PatternSyntax* pattern, Token* tripleAnd, ExpressionSyntax* expr, Token* colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return pattern;
            case 1: return tripleAnd;
            case 2: return expr;
            case 3: return colon;
            case 4: return statement;
            default: return nullptr;
        }
    }
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token* colon;
    StatementSyntax* statement;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token* colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &expressions;
            case 1: return colon;
            case 2: return statement;
            default: return nullptr;
        }
    }
};

struct CaseStatementSyntax : public StatementSyntax {
    Token* uniqueOrPriority;
    Token* caseKeyword;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    Token* matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token* endcase;

    CaseStatementSyntax(Token* uniqueOrPriority, Token* caseKeyword, Token* openParen, ExpressionSyntax* expr, Token* closeParen, Token* matchesOrInside, SyntaxList<CaseItemSyntax> items, Token* endcase) :
        StatementSyntax(SyntaxKind::CaseStatement), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return uniqueOrPriority;
            case 1: return caseKeyword;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            case 5: return matchesOrInside;
            case 6: return &items;
            case 7: return endcase;
            default: return nullptr;
        }
    }
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token* foreverKeyword;
    StatementSyntax* statement;

    ForeverStatementSyntax(Token* foreverKeyword, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::ForeverStatement), foreverKeyword(foreverKeyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return foreverKeyword;
            case 1: return statement;
            default: return nullptr;
        }
    }
};

struct LoopStatementSyntax : public StatementSyntax {
    Token* repeatOrWhile;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    StatementSyntax* statement;

    LoopStatementSyntax(Token* repeatOrWhile, Token* openParen, ExpressionSyntax* expr, Token* closeParen, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::LoopStatement), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return repeatOrWhile;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            case 4: return statement;
            default: return nullptr;
        }
    }
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token* doKeyword;
    StatementSyntax* statement;
    Token* whileKeyword;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    Token* semi;

    DoWhileStatementSyntax(Token* doKeyword, StatementSyntax* statement, Token* whileKeyword, Token* openParen, ExpressionSyntax* expr, Token* closeParen, Token* semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement), doKeyword(doKeyword), statement(statement), whileKeyword(whileKeyword), openParen(openParen), expr(expr), closeParen(closeParen), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return doKeyword;
            case 1: return statement;
            case 2: return whileKeyword;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token* returnKeyword;
    ExpressionSyntax* returnValue;
    Token* semi;

    ReturnStatementSyntax(Token* returnKeyword, ExpressionSyntax* returnValue, Token* semi) :
        StatementSyntax(SyntaxKind::ReturnStatement), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return returnKeyword;
            case 1: return returnValue;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct JumpStatementSyntax : public StatementSyntax {
    Token* breakOrContinue;
    Token* semi;

    JumpStatementSyntax(Token* breakOrContinue, Token* semi) :
        StatementSyntax(SyntaxKind::JumpStatement), breakOrContinue(breakOrContinue), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return breakOrContinue;
            case 1: return semi;
            default: return nullptr;
        }
    }
};

struct TimingControlStatementSyntax : public StatementSyntax {
    TimingControlSyntax* timingControl;
    StatementSyntax* statement;

    TimingControlStatementSyntax(TimingControlSyntax* timingControl, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement), timingControl(timingControl), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return timingControl;
            case 1: return statement;
            default: return nullptr;
        }
    }
};

struct AssignmentStatementSyntax : public StatementSyntax {
    ExpressionSyntax* left;
    Token* operatorToken;
    TimingControlSyntax* timingControl;
    ExpressionSyntax* expr;
    Token* semi;

    AssignmentStatementSyntax(SyntaxKind kind, ExpressionSyntax* left, Token* operatorToken, TimingControlSyntax* timingControl, ExpressionSyntax* expr, Token* semi) :
        StatementSyntax(kind), left(left), operatorToken(operatorToken), timingControl(timingControl), expr(expr), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return timingControl;
            case 3: return expr;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token* keyword;
    ExpressionSyntax* lvalue;
    Token* equals;
    ExpressionSyntax* value;
    Token* semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, Token* keyword, ExpressionSyntax* lvalue, Token* equals, ExpressionSyntax* value, Token* semi) :
        StatementSyntax(kind), keyword(keyword), lvalue(lvalue), equals(equals), value(value), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return lvalue;
            case 2: return equals;
            case 3: return value;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token* keyword;
    ExpressionSyntax* variable;
    Token* semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, Token* keyword, ExpressionSyntax* variable, Token* semi) :
        StatementSyntax(kind), keyword(keyword), variable(variable), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return variable;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct DisableStatementSyntax : public StatementSyntax {
    Token* disable;
    NameSyntax* name;
    Token* semi;

    DisableStatementSyntax(Token* disable, NameSyntax* name, Token* semi) :
        StatementSyntax(SyntaxKind::DisableStatement), disable(disable), name(name), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return disable;
            case 1: return name;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token* disable;
    Token* fork;
    Token* semi;

    DisableForkStatementSyntax(Token* disable, Token* fork, Token* semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement), disable(disable), fork(fork), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return disable;
            case 1: return fork;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token* colon;
    Token* name;

    NamedBlockClauseSyntax(Token* colon, Token* name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return colon;
            case 1: return name;
            default: return nullptr;
        }
    }
};

struct SequentialBlockStatementSyntax : public StatementSyntax {
    Token* begin;
    NamedBlockClauseSyntax* blockName;
    Token* end;
    NamedBlockClauseSyntax* endBlockName;

    SequentialBlockStatementSyntax(Token* begin, NamedBlockClauseSyntax* blockName, Token* end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(SyntaxKind::SequentialBlockStatement), begin(begin), blockName(blockName), end(end), endBlockName(endBlockName)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return begin;
            case 1: return blockName;
            case 2: return end;
            case 3: return endBlockName;
            default: return nullptr;
        }
    }
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token* directive;
    Token* endOfDirective;

    DirectiveSyntax(SyntaxKind kind, Token* directive, Token* endOfDirective) :
        SyntaxNode(kind), directive(directive), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch(index) {
            case 0: return directive;
            case 1: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token* fileName;

    IncludeDirectiveSyntax(Token* directive, Token* endOfDirective, Token* fileName) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive, endOfDirective), fileName(fileName)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return fileName;
            default: return nullptr;
        }
    }
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token* equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token* equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return equals;
            case 1: return &tokens;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token* name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token* name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return defaultValue;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token* openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token* closeParen;

    MacroFormalArgumentListSyntax(Token* openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token* closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token* name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;

    DefineDirectiveSyntax(Token* directive, Token* endOfDirective, Token* name, MacroFormalArgumentListSyntax* formalArguments, TokenList body) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive, endOfDirective), name(name), formalArguments(formalArguments), body(body)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return name;
            case 3: return formalArguments;
            case 4: return &body;
            default: return nullptr;
        }
    }
};

}