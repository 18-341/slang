#pragma once

#include "SyntaxNode.h"
#include "Token.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the tools/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

// ----- ATTRIBUTES -----

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token* equals;
    ExpressionSyntax* expr;

    EqualsValueClauseSyntax(Token* equals, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return equals;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct AttributeSpecSyntax : public SyntaxNode {
    Token* name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token* name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return value;
            default: return nullptr;
        }
    }
};

struct AttributeInstanceSyntax : public SyntaxNode {
    Token* openParen;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token* closeParen;

    AttributeInstanceSyntax(Token* openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token* closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &specs;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct StatementLabelSyntax : public SyntaxNode {
    Token* name;
    Token* colon;

    StatementLabelSyntax(Token* name, Token* colon) :
        SyntaxNode(SyntaxKind::StatementLabel), name(name), colon(colon)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return colon;
            default: return nullptr;
        }
    }
};

struct StatementSyntax : public SyntaxNode {
    StatementLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), label(label), attributes(attributes)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            default: return nullptr;
        }
    }
};

struct MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch(index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    ExpressionSyntax* expr;

    OrderedArgumentSyntax(ExpressionSyntax* expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token* dot;
    Token* name;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;

    NamedArgumentSyntax(Token* dot, Token* name, Token* openParen, ExpressionSyntax* expr, Token* closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct ArgumentListSyntax : public SyntaxNode {
    Token* openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token* closeParen;

    ArgumentListSyntax(Token* openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token* closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &parameters;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token* hash;
    ArgumentListSyntax* parameters;

    ParameterValueAssignmentSyntax(Token* hash, ArgumentListSyntax* parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return hash;
            case 1: return parameters;
            default: return nullptr;
        }
    }
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct VariablePatternSyntax : public PatternSyntax {
    Token* dot;
    Token* variableName;

    VariablePatternSyntax(Token* dot, Token* variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return variableName;
            default: return nullptr;
        }
    }
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token* dotStar;

    WildcardPatternSyntax(Token* dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dotStar;
            default: return nullptr;
        }
    }
};

struct ExpressionPatternSyntax : public PatternSyntax {
    ExpressionSyntax* expr;

    ExpressionPatternSyntax(ExpressionSyntax* expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token* tagged;
    Token* memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token* tagged, Token* memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return tagged;
            case 1: return memberName;
            case 2: return pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    PatternSyntax* pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax* pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(pattern)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return pattern;
            default: return nullptr;
        }
    }
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token* name;
    Token* colon;
    PatternSyntax* pattern;

    NamedStructurePatternMemberSyntax(Token* name, Token* colon, PatternSyntax* pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(pattern)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return colon;
            case 2: return pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternSyntax : public PatternSyntax {
    Token* openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token* closeBrace;

    StructurePatternSyntax(Token* openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token* closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return &members;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token* matchesKeyword;
    PatternSyntax* pattern;

    MatchesClauseSyntax(Token* matchesKeyword, PatternSyntax* pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(pattern)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return matchesKeyword;
            case 1: return pattern;
            default: return nullptr;
        }
    }
};

struct ConditionalPatternSyntax : public SyntaxNode {
    ExpressionSyntax* expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax* expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(expr), matchesClause(matchesClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            case 1: return matchesClause;
            default: return nullptr;
        }
    }
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &conditions;
            default: return nullptr;
        }
    }
};

// ----- EXPRESSIONS -----

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token* operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax* operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token* operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(operand)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return operatorToken;
            case 1: return &attributes;
            case 2: return operand;
            default: return nullptr;
        }
    }
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token* operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax* operand, SyntaxList<AttributeInstanceSyntax> attributes, Token* operatorToken) :
        ExpressionSyntax(kind), operand(operand), attributes(attributes), operatorToken(operatorToken)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return operand;
            case 1: return &attributes;
            case 2: return operatorToken;
            default: return nullptr;
        }
    }
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token* operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax* right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax* left, Token* operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* right) :
        ExpressionSyntax(kind), left(left), operatorToken(operatorToken), attributes(attributes), right(right)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return &attributes;
            case 3: return right;
            default: return nullptr;
        }
    }
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* min;
    Token* colon1;
    ExpressionSyntax* typ;
    Token* colon2;
    ExpressionSyntax* max;

    MinTypMaxExpressionSyntax(ExpressionSyntax* min, Token* colon1, ExpressionSyntax* typ, Token* colon2, ExpressionSyntax* max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(min), colon1(colon1), typ(typ), colon2(colon2), max(max)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return min;
            case 1: return colon1;
            case 2: return typ;
            case 3: return colon2;
            case 4: return max;
            default: return nullptr;
        }
    }
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token* tagged;
    Token* member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token* tagged, Token* member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return tagged;
            case 1: return member;
            case 2: return expr;
            default: return nullptr;
        }
    }
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* expr;
    Token* inside;
    Token* openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token* closeBrace;

    InsideExpressionSyntax(ExpressionSyntax* expr, Token* inside, Token* openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token* closeBrace) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(expr), inside(inside), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            case 1: return inside;
            case 2: return openBrace;
            case 3: return &valueRanges;
            case 4: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    ConditionalPredicateSyntax* predicate;
    Token* question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax* left;
    Token* colon;
    ExpressionSyntax* right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax* predicate, Token* question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* left, Token* colon, ExpressionSyntax* right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(predicate), question(question), attributes(attributes), left(left), colon(colon), right(right)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return predicate;
            case 1: return question;
            case 2: return &attributes;
            case 3: return left;
            case 4: return colon;
            case 5: return right;
            default: return nullptr;
        }
    }
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct BitSelectSyntax : public SelectorSyntax {
    ExpressionSyntax* expr;

    BitSelectSyntax(ExpressionSyntax* expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct RangeSelectSyntax : public SelectorSyntax {
    ExpressionSyntax* left;
    Token* range;
    ExpressionSyntax* right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax* left, Token* range, ExpressionSyntax* right) :
        SelectorSyntax(kind), left(left), range(range), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return range;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token* openBracket;
    SelectorSyntax* selector;
    Token* closeBracket;

    ElementSelectSyntax(Token* openBracket, SelectorSyntax* selector, Token* closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBracket;
            case 1: return selector;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct IdentifierNameSyntax : public NameSyntax {
    Token* identifier;

    IdentifierNameSyntax(Token* identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return identifier;
            default: return nullptr;
        }
    }
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token* identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token* identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return identifier;
            case 1: return &selectors;
            default: return nullptr;
        }
    }
};

struct KeywordNameSyntax : public NameSyntax {
    Token* keyword;

    KeywordNameSyntax(SyntaxKind kind, Token* keyword) :
        NameSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct ClassNameSyntax : public NameSyntax {
    Token* identifier;
    ParameterValueAssignmentSyntax* parameters;

    ClassNameSyntax(Token* identifier, ParameterValueAssignmentSyntax* parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(parameters)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return identifier;
            case 1: return parameters;
            default: return nullptr;
        }
    }
};

struct ScopedNameSyntax : public NameSyntax {
    NameSyntax* left;
    Token* separator;
    NameSyntax* right;

    ScopedNameSyntax(NameSyntax* left, Token* separator, NameSyntax* right) :
        NameSyntax(SyntaxKind::ScopedName), left(left), separator(separator), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return separator;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ClassScopeSyntax : public SyntaxNode {
    NameSyntax* left;
    Token* separator;

    ClassScopeSyntax(NameSyntax* left, Token* separator) :
        SyntaxNode(SyntaxKind::ClassScope), left(left), separator(separator)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return separator;
            default: return nullptr;
        }
    }
};

// ----- PRIMARY EXPRESSIONS -----

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {
    }
};

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token* literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token* literal) :
        PrimaryExpressionSyntax(kind), literal(literal)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return literal;
            default: return nullptr;
        }
    }
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    Token* closeBrace;

    EmptyQueueExpressionSyntax(Token* openBrace, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token* closeBrace;

    ConcatenationExpressionSyntax(Token* openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return &expressions;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    ExpressionSyntax* expression;
    ConcatenationExpressionSyntax* concatenation;
    Token* closeBrace;

    MultipleConcatenationExpressionSyntax(Token* openBrace, ExpressionSyntax* expression, ConcatenationExpressionSyntax* concatenation, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(expression), concatenation(concatenation), closeBrace(closeBrace)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return expression;
            case 2: return concatenation;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token* withKeyword;
    ElementSelectSyntax* range;

    StreamExpressionWithRange(Token* withKeyword, ElementSelectSyntax* range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(range)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return withKeyword;
            case 1: return range;
            default: return nullptr;
        }
    }
};

struct StreamExpressionSyntax : public SyntaxNode {
    ExpressionSyntax* expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax* expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(expression), withRange(withRange)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expression;
            case 1: return withRange;
            default: return nullptr;
        }
    }
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openBrace;
    Token* operatorToken;
    ExpressionSyntax* sliceSize;
    Token* innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token* innerCloseBrace;
    Token* closeBrace;

    StreamingConcatenationExpressionSyntax(Token* openBrace, Token* operatorToken, ExpressionSyntax* sliceSize, Token* innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token* innerCloseBrace, Token* closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBrace;
            case 1: return operatorToken;
            case 2: return sliceSize;
            case 3: return innerOpenBrace;
            case 4: return &expressions;
            case 5: return innerCloseBrace;
            case 6: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token* openParen;
    ExpressionSyntax* expression;
    Token* closeParen;

    ParenthesizedExpressionSyntax(Token* openParen, ExpressionSyntax* expression, Token* closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(expression), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return expression;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax* classScope;
    Token* newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax* classScope, Token* newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return classScope;
            case 1: return newKeyword;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token* newKeyword;
    Token* openBracket;
    ExpressionSyntax* sizeExpr;
    Token* closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token* newKeyword, Token* openBracket, ExpressionSyntax* sizeExpr, Token* closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(sizeExpr), closeBracket(closeBracket), initializer(initializer)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return newKeyword;
            case 1: return openBracket;
            case 2: return sizeExpr;
            case 3: return closeBracket;
            case 4: return initializer;
            default: return nullptr;
        }
    }
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    ElementSelectSyntax* select;

    ElementSelectExpressionSyntax(ExpressionSyntax* left, ElementSelectSyntax* select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(left), select(select)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return select;
            default: return nullptr;
        }
    }
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    Token* dot;
    Token* name;

    MemberAccessExpressionSyntax(ExpressionSyntax* left, Token* dot, Token* name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(left), dot(dot), name(name)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return dot;
            case 2: return name;
            default: return nullptr;
        }
    }
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax* left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax* left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(left), attributes(attributes), arguments(arguments)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return &attributes;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DelayControlSyntax : public TimingControlSyntax {
    Token* hash;
    ExpressionSyntax* delayValue;

    DelayControlSyntax(Token* hash, ExpressionSyntax* delayValue) :
        TimingControlSyntax(SyntaxKind::DelayControl), hash(hash), delayValue(delayValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return hash;
            case 1: return delayValue;
            default: return nullptr;
        }
    }
};

struct CycleDelaySyntax : public TimingControlSyntax {
    Token* doubleHash;
    ExpressionSyntax* delayValue;

    CycleDelaySyntax(Token* doubleHash, ExpressionSyntax* delayValue) :
        TimingControlSyntax(SyntaxKind::CycleDelay), doubleHash(doubleHash), delayValue(delayValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return doubleHash;
            case 1: return delayValue;
            default: return nullptr;
        }
    }
};

struct EventControlSyntax : public TimingControlSyntax {
    Token* at;
    NameSyntax* eventName;

    EventControlSyntax(Token* at, NameSyntax* eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(eventName)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return at;
            case 1: return eventName;
            default: return nullptr;
        }
    }
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct IffClauseSyntax : public SyntaxNode {
    Token* iff;
    ExpressionSyntax* expr;

    IffClauseSyntax(Token* iff, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return iff;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token* edge;
    ExpressionSyntax* expr;
    IffClauseSyntax* iffClause;

    SignalEventExpressionSyntax(Token* edge, ExpressionSyntax* expr, IffClauseSyntax* iffClause) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(expr), iffClause(iffClause)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return edge;
            case 1: return expr;
            case 2: return iffClause;
            default: return nullptr;
        }
    }
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    EventExpressionSyntax* left;
    Token* operatorToken;
    EventExpressionSyntax* right;

    BinaryEventExpressionSyntax(EventExpressionSyntax* left, Token* operatorToken, EventExpressionSyntax* right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(left), operatorToken(operatorToken), right(right)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return left;
            case 1: return operatorToken;
            case 2: return right;
            default: return nullptr;
        }
    }
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token* openParen;
    EventExpressionSyntax* expr;
    Token* closeParen;

    ParenthesizedEventExpressionSyntax(Token* openParen, EventExpressionSyntax* expr, Token* closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return expr;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token* atStar;

    ImplicitEventControlSyntax(Token* atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return atStar;
            default: return nullptr;
        }
    }
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token* at;
    Token* openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token* at, Token* openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return at;
            case 1: return openParenStarCloseParen;
            default: return nullptr;
        }
    }
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token* at;
    EventExpressionSyntax* expr;

    EventControlWithExpressionSyntax(Token* at, EventExpressionSyntax* expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return at;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token* repeat;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token* repeat, Token* openParen, ExpressionSyntax* expr, Token* closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(expr), closeParen(closeParen), eventControl(eventControl)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return repeat;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            case 4: return eventControl;
            default: return nullptr;
        }
    }
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    SelectorSyntax* selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax* selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(selector)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return selector;
            default: return nullptr;
        }
    }
};

struct DataTypeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    DataTypeSyntax* type;

    DataTypeDimensionSpecifierSyntax(DataTypeSyntax* type) :
        DimensionSpecifierSyntax(SyntaxKind::DataTypeDimensionSpecifier), type(type)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return type;
            default: return nullptr;
        }
    }
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token* star;

    WildcardDimensionSpecifierSyntax(Token* star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return star;
            default: return nullptr;
        }
    }
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token* colon;
    ExpressionSyntax* expr;

    ColonExpressionClauseSyntax(Token* colon, ExpressionSyntax* expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(expr)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return colon;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token* dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token* dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dollar;
            case 1: return maxSizeClause;
            default: return nullptr;
        }
    }
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token* openBracket;
    DimensionSpecifierSyntax* specifier;
    Token* closeBracket;

    VariableDimensionSyntax(Token* openBracket, DimensionSpecifierSyntax* specifier, Token* closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token* name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token* name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return initializer;
            default: return nullptr;
        }
    }
};

struct DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token* semi;

    DataDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token* semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(type), declarators(declarators), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return &modifiers;
            case 2: return type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct PackageImportItemSyntax : public SyntaxNode {
    Token* package;
    Token* doubleColon;
    Token* item;

    PackageImportItemSyntax(Token* package, Token* doubleColon, Token* item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return package;
            case 1: return doubleColon;
            case 2: return item;
            default: return nullptr;
        }
    }
};

struct PackageImportDeclarationSyntax : public SyntaxNode {
    Token* keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token* semi;

    PackageImportDeclarationSyntax(Token* keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token* semi) :
        SyntaxNode(SyntaxKind::PackageImportDeclaration), keyword(keyword), items(items), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return &items;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct ParameterPortDeclarationSyntax : public SyntaxNode {

    ParameterPortDeclarationSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ParameterDeclarationSyntax : public ParameterPortDeclarationSyntax {
    Token* keyword;
    DataTypeSyntax* type;
    VariableDeclaratorSyntax* declarator;

    ParameterDeclarationSyntax(Token* keyword, DataTypeSyntax* type, VariableDeclaratorSyntax* declarator) :
        ParameterPortDeclarationSyntax(SyntaxKind::ParameterDeclaration), keyword(keyword), type(type), declarator(declarator)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return type;
            case 2: return declarator;
            default: return nullptr;
        }
    }
};

struct TypeParameterDeclarationSyntax : public ParameterPortDeclarationSyntax {
    Token* keyword;
    Token* type;
    VariableDeclaratorSyntax* declarator;

    TypeParameterDeclarationSyntax(Token* keyword, Token* type, VariableDeclaratorSyntax* declarator) :
        ParameterPortDeclarationSyntax(SyntaxKind::TypeParameterDeclaration), keyword(keyword), type(type), declarator(declarator)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return type;
            case 2: return declarator;
            default: return nullptr;
        }
    }
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token* keyword;
    Token* signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token* keyword, Token* signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return signing;
            case 2: return &dimensions;
            default: return nullptr;
        }
    }
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token* keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token* keyword) :
        DataTypeSyntax(kind), keyword(keyword)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct NamedTypeSyntax : public DataTypeSyntax {
    NameSyntax* name;

    NamedTypeSyntax(NameSyntax* name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(name)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            default: return nullptr;
        }
    }
};

struct StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token* randomQualifier;
    DataTypeSyntax* type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token* semi;

    StructUnionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* randomQualifier, DataTypeSyntax* type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token* semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(type), declarators(declarators), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return randomQualifier;
            case 2: return type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token* keyword;
    Token* tagged;
    Token* packed;
    Token* signing;
    Token* openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token* closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token* keyword, Token* tagged, Token* packed, Token* signing, Token* openBrace, SyntaxList<StructUnionMemberSyntax> members, Token* closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return tagged;
            case 2: return packed;
            case 3: return signing;
            case 4: return openBrace;
            case 5: return &members;
            case 6: return closeBrace;
            case 7: return &dimensions;
            default: return nullptr;
        }
    }
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token* keyword;
    DataTypeSyntax* baseType;
    Token* openBrace;
    SeparatedSyntaxList<VariableDeclaratorSyntax> members;
    Token* closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token* keyword, DataTypeSyntax* baseType, Token* openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token* closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return keyword;
            case 1: return baseType;
            case 2: return openBrace;
            case 3: return &members;
            case 4: return closeBrace;
            case 5: return &dimensions;
            default: return nullptr;
        }
    }
};

struct TypeReferenceSyntax : public DataTypeSyntax {
    Token* typeKeyword;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;

    TypeReferenceSyntax(Token* typeKeyword, Token* openParen, ExpressionSyntax* expr, Token* closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token* dot;
    Token* member;

    DotMemberClauseSyntax(Token* dot, Token* member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return member;
            default: return nullptr;
        }
    }
};

struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token* virtualKeyword;
    Token* interfaceKeyword;
    Token* name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token* virtualKeyword, Token* interfaceKeyword, Token* name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return virtualKeyword;
            case 1: return interfaceKeyword;
            case 2: return name;
            case 3: return parameters;
            case 4: return modport;
            default: return nullptr;
        }
    }
};

struct ImplicitTypeSyntax : public DataTypeSyntax {
    Token* signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token* signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return signing;
            case 1: return &dimensions;
            default: return nullptr;
        }
    }
};

// ----- STATEMENTS -----

struct EmptyStatementSyntax : public StatementSyntax {
    Token* semicolon;

    EmptyStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return semicolon;
            default: return nullptr;
        }
    }
};

struct ElseClauseSyntax : public SyntaxNode {
    Token* elseKeyword;
    StatementSyntax* statement;

    ElseClauseSyntax(Token* elseKeyword, StatementSyntax* statement) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return elseKeyword;
            case 1: return statement;
            default: return nullptr;
        }
    }
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token* uniqueOrPriority;
    Token* ifKeyword;
    Token* openParen;
    ConditionalPredicateSyntax* predicate;
    Token* closeParen;
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* uniqueOrPriority, Token* ifKeyword, Token* openParen, ConditionalPredicateSyntax* predicate, Token* closeParen, StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(predicate), closeParen(closeParen), statement(statement), elseClause(elseClause)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return ifKeyword;
            case 4: return openParen;
            case 5: return predicate;
            case 6: return closeParen;
            case 7: return statement;
            case 8: return elseClause;
            default: return nullptr;
        }
    }
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token* defaultKeyword;
    Token* colon;
    StatementSyntax* statement;

    DefaultCaseItemSyntax(Token* defaultKeyword, Token* colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return defaultKeyword;
            case 1: return colon;
            case 2: return statement;
            default: return nullptr;
        }
    }
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    PatternSyntax* pattern;
    Token* tripleAnd;
    ExpressionSyntax* expr;
    Token* colon;
    StatementSyntax* statement;

    PatternCaseItemSyntax(PatternSyntax* pattern, Token* tripleAnd, ExpressionSyntax* expr, Token* colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return pattern;
            case 1: return tripleAnd;
            case 2: return expr;
            case 3: return colon;
            case 4: return statement;
            default: return nullptr;
        }
    }
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token* colon;
    StatementSyntax* statement;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token* colon, StatementSyntax* statement) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), statement(statement)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &expressions;
            case 1: return colon;
            case 2: return statement;
            default: return nullptr;
        }
    }
};

struct CaseStatementSyntax : public StatementSyntax {
    Token* uniqueOrPriority;
    Token* caseKeyword;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    Token* matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token* endcase;

    CaseStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* uniqueOrPriority, Token* caseKeyword, Token* openParen, ExpressionSyntax* expr, Token* closeParen, Token* matchesOrInside, SyntaxList<CaseItemSyntax> items, Token* endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase)
    {
        childCount += 8;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return caseKeyword;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            case 7: return matchesOrInside;
            case 8: return &items;
            case 9: return endcase;
            default: return nullptr;
        }
    }
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token* foreverKeyword;
    StatementSyntax* statement;

    ForeverStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* foreverKeyword, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return foreverKeyword;
            case 3: return statement;
            default: return nullptr;
        }
    }
};

struct LoopStatementSyntax : public StatementSyntax {
    Token* repeatOrWhile;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    StatementSyntax* statement;

    LoopStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* repeatOrWhile, Token* openParen, ExpressionSyntax* expr, Token* closeParen, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return repeatOrWhile;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            case 6: return statement;
            default: return nullptr;
        }
    }
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token* doKeyword;
    StatementSyntax* statement;
    Token* whileKeyword;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;
    Token* semi;

    DoWhileStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* doKeyword, StatementSyntax* statement, Token* whileKeyword, Token* openParen, ExpressionSyntax* expr, Token* closeParen, Token* semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(statement), whileKeyword(whileKeyword), openParen(openParen), expr(expr), closeParen(closeParen), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return doKeyword;
            case 3: return statement;
            case 4: return whileKeyword;
            case 5: return openParen;
            case 6: return expr;
            case 7: return closeParen;
            case 8: return semi;
            default: return nullptr;
        }
    }
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token* returnKeyword;
    ExpressionSyntax* returnValue;
    Token* semi;

    ReturnStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* returnKeyword, ExpressionSyntax* returnValue, Token* semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return returnKeyword;
            case 3: return returnValue;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct JumpStatementSyntax : public StatementSyntax {
    Token* breakOrContinue;
    Token* semi;

    JumpStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* breakOrContinue, Token* semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return breakOrContinue;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct TimingControlStatementSyntax : public StatementSyntax {
    TimingControlSyntax* timingControl;
    StatementSyntax* statement;

    TimingControlStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax* timingControl, StatementSyntax* statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(timingControl), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return timingControl;
            case 3: return statement;
            default: return nullptr;
        }
    }
};

struct AssignmentStatementSyntax : public StatementSyntax {
    ExpressionSyntax* left;
    Token* operatorToken;
    TimingControlSyntax* timingControl;
    ExpressionSyntax* expr;
    Token* semi;

    AssignmentStatementSyntax(SyntaxKind kind, StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* left, Token* operatorToken, TimingControlSyntax* timingControl, ExpressionSyntax* expr, Token* semi) :
        StatementSyntax(kind, label, attributes), left(left), operatorToken(operatorToken), timingControl(timingControl), expr(expr), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return left;
            case 3: return operatorToken;
            case 4: return timingControl;
            case 5: return expr;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token* keyword;
    ExpressionSyntax* lvalue;
    Token* equals;
    ExpressionSyntax* value;
    Token* semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* keyword, ExpressionSyntax* lvalue, Token* equals, ExpressionSyntax* value, Token* semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(lvalue), equals(equals), value(value), semi(semi)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return lvalue;
            case 4: return equals;
            case 5: return value;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token* keyword;
    ExpressionSyntax* variable;
    Token* semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* keyword, ExpressionSyntax* variable, Token* semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(variable), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return variable;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct DisableStatementSyntax : public StatementSyntax {
    Token* disable;
    NameSyntax* name;
    Token* semi;

    DisableStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* disable, NameSyntax* name, Token* semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(name), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token* disable;
    Token* fork;
    Token* semi;

    DisableForkStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* disable, Token* fork, Token* semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token* colon;
    Token* name;

    NamedBlockClauseSyntax(Token* colon, Token* name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return colon;
            case 1: return name;
            default: return nullptr;
        }
    }
};

struct SequentialBlockStatementSyntax : public StatementSyntax {
    Token* begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token* end;
    NamedBlockClauseSyntax* endBlockName;

    SequentialBlockStatementSyntax(StatementLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token* begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token* end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(SyntaxKind::SequentialBlockStatement, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return begin;
            case 3: return blockName;
            case 4: return &items;
            case 5: return end;
            case 6: return endBlockName;
            default: return nullptr;
        }
    }
};

// ----- MEMBERS -----

struct ProceduralBlockSyntax : public MemberSyntax {
    Token* keyword;
    StatementSyntax* statement;

    ProceduralBlockSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token* keyword, StatementSyntax* statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(statement)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return statement;
            default: return nullptr;
        }
    }
};

struct GenerateBlockSyntax : public MemberSyntax {
    Token* keyword;
    SyntaxList<MemberSyntax> members;
    Token* endgenerate;

    GenerateBlockSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* keyword, SyntaxList<MemberSyntax> members, Token* endgenerate) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), keyword(keyword), members(members), endgenerate(endgenerate)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &members;
            case 3: return endgenerate;
            default: return nullptr;
        }
    }
};

struct DividerClauseSyntax : public SyntaxNode {
    Token* divide;
    Token* value;

    DividerClauseSyntax(Token* divide, Token* value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return divide;
            case 1: return value;
            default: return nullptr;
        }
    }
};

struct TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token* keyword;
    Token* time;
    DividerClauseSyntax* divider;
    Token* semi;

    TimeUnitsDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* keyword, Token* time, DividerClauseSyntax* divider, Token* semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return time;
            case 3: return divider;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch(index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
    ExpressionSyntax* expr;

    OrderedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax* expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return expr;
            default: return nullptr;
        }
    }
};

struct NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token* dot;
    Token* name;
    ParenthesizedExpressionSyntax* connection;

    NamedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* dot, Token* name, ParenthesizedExpressionSyntax* connection) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), connection(connection)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return dot;
            case 2: return name;
            case 3: return connection;
            default: return nullptr;
        }
    }
};

struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token* dotStar;

    WildcardPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* dotStar) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return dotStar;
            default: return nullptr;
        }
    }
};

struct HierarchicalInstanceSyntax : public SyntaxNode {
    Token* name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token* openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token* closeParen;

    HierarchicalInstanceSyntax(Token* name, SyntaxList<VariableDimensionSyntax> dimensions, Token* openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token* closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return openParen;
            case 3: return &connections;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct HierarchyInstantiationSyntax : public MemberSyntax {
    Token* type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token* semi;

    HierarchyInstantiationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token* semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return parameters;
            case 3: return &instances;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

// ----- MODULES -----

struct PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    ExpressionSyntax* expr;

    ImplicitNonAnsiPortSyntax(ExpressionSyntax* expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return expr;
            default: return nullptr;
        }
    }
};

struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token* dot;
    Token* name;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;

    ExplicitNonAnsiPortSyntax(Token* dot, Token* name, Token* openParen, ExpressionSyntax* expr, Token* closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 5;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct NonAnsiPortListSyntax : public PortListSyntax {
    Token* openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token* closeParen;

    NonAnsiPortListSyntax(Token* openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token* closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct AnsiPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    AnsiPortSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch(index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

struct PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {
    }
};

struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token* nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token* nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return nameOrKeyword;
            case 1: return modport;
            default: return nullptr;
        }
    }
};

struct VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token* direction;
    Token* varKeyword;
    DataTypeSyntax* type;

    VariablePortHeaderSyntax(Token* direction, Token* varKeyword, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), type(type)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return direction;
            case 1: return varKeyword;
            case 2: return type;
            default: return nullptr;
        }
    }
};

struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
    Token* direction;
    Token* interconnect;
    DataTypeSyntax* type;

    InterconnectPortHeaderSyntax(Token* direction, Token* interconnect, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(type)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return direction;
            case 1: return interconnect;
            case 2: return type;
            default: return nullptr;
        }
    }
};

struct NetPortHeaderSyntax : public PortHeaderSyntax {
    Token* direction;
    Token* netType;
    DataTypeSyntax* dataType;

    NetPortHeaderSyntax(Token* direction, Token* netType, DataTypeSyntax* dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(dataType)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return direction;
            case 1: return netType;
            case 2: return dataType;
            default: return nullptr;
        }
    }
};

struct ImplicitAnsiPortSyntax : public AnsiPortSyntax {
    PortHeaderSyntax* header;
    Token* name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* defaultValue;

    ImplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax* header, Token* name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* defaultValue) :
        AnsiPortSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(header), name(name), dimensions(dimensions), defaultValue(defaultValue)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return header;
            case 2: return name;
            case 3: return &dimensions;
            case 4: return defaultValue;
            default: return nullptr;
        }
    }
};

struct ExplicitAnsiPortSyntax : public AnsiPortSyntax {
    Token* direction;
    Token* dot;
    Token* name;
    Token* openParen;
    ExpressionSyntax* expr;
    Token* closeParen;

    ExplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token* direction, Token* dot, Token* name, Token* openParen, ExpressionSyntax* expr, Token* closeParen) :
        AnsiPortSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {
        childCount += 6;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return direction;
            case 2: return dot;
            case 3: return name;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            default: return nullptr;
        }
    }
};

struct AnsiPortListSyntax : public PortListSyntax {
    Token* openParen;
    SeparatedSyntaxList<AnsiPortSyntax> ports;
    Token* closeParen;

    AnsiPortListSyntax(Token* openParen, SeparatedSyntaxList<AnsiPortSyntax> ports, Token* closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct WildcardPortListSyntax : public PortListSyntax {
    Token* openParen;
    Token* dotStar;
    Token* closeParen;

    WildcardPortListSyntax(Token* openParen, Token* dotStar, Token* closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return dotStar;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterPortListSyntax : public SyntaxNode {
    Token* hash;
    Token* openParen;
    SeparatedSyntaxList<ParameterPortDeclarationSyntax> declarations;
    Token* closeParen;

    ParameterPortListSyntax(Token* hash, Token* openParen, SeparatedSyntaxList<ParameterPortDeclarationSyntax> declarations, Token* closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return hash;
            case 1: return openParen;
            case 2: return &declarations;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct ModuleHeaderSyntax : public SyntaxNode {
    Token* moduleKeyword;
    Token* lifetime;
    Token* name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token* semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token* moduleKeyword, Token* lifetime, Token* name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token* semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi)
    {
        childCount += 7;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return moduleKeyword;
            case 1: return lifetime;
            case 2: return name;
            case 3: return &imports;
            case 4: return parameters;
            case 5: return ports;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ModuleDeclarationSyntax : public MemberSyntax {
    ModuleHeaderSyntax* header;
    SyntaxList<MemberSyntax> members;
    Token* endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax* header, SyntaxList<MemberSyntax> members, Token* endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(header), members(members), endmodule(endmodule), blockName(blockName)
    {
        childCount += 4;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return &attributes;
            case 1: return header;
            case 2: return &members;
            case 3: return endmodule;
            case 4: return blockName;
            default: return nullptr;
        }
    }
};

struct ExternModuleSyntax : public SyntaxNode {
    Token* externKeyword;
    ModuleHeaderSyntax* header;

    ExternModuleSyntax(Token* externKeyword, ModuleHeaderSyntax* header) :
        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(header)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return externKeyword;
            case 1: return header;
            default: return nullptr;
        }
    }
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token* directive;
    Token* endOfDirective;

    DirectiveSyntax(SyntaxKind kind, Token* directive, Token* endOfDirective) :
        SyntaxNode(kind), directive(directive), endOfDirective(endOfDirective)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override {
        switch(index) {
            case 0: return directive;
            case 1: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token* fileName;

    IncludeDirectiveSyntax(Token* directive, Token* endOfDirective, Token* fileName) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive, endOfDirective), fileName(fileName)
    {
        childCount += 1;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return fileName;
            default: return nullptr;
        }
    }
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token* equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token* equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return equals;
            case 1: return &tokens;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token* name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token* name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue)
    {
        childCount += 2;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return name;
            case 1: return defaultValue;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token* openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token* closeParen;

    MacroFormalArgumentListSyntax(Token* openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token* closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token* name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;

    DefineDirectiveSyntax(Token* directive, Token* endOfDirective, Token* name, MacroFormalArgumentListSyntax* formalArguments, TokenList body) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive, endOfDirective), name(name), formalArguments(formalArguments), body(body)
    {
        childCount += 3;
    }

protected:
    TokenOrSyntax getChild(uint32_t index) override final {
        switch(index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return name;
            case 3: return formalArguments;
            case 4: return &body;
            default: return nullptr;
        }
    }
};

}