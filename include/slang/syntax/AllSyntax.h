//------------------------------------------------------------------------------
// AllSyntax.h
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include "slang/parsing/Token.h"
#include "slang/syntax/SyntaxNode.h"
#include "slang/util/BumpAllocator.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the scripts/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

// ----- ATTRIBUTES -----

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token equals;
    not_null<ExpressionSyntax*> expr;

    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EqualsValueClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct AttributeSpecSyntax : public SyntaxNode {
    Token name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value) {
        if (this->value) this->value->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AttributeSpecSyntax* clone(BumpAllocator& alloc) const;
};

struct AttributeInstanceSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token closeParen;

    AttributeInstanceSyntax(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen) {
        this->specs.parent = this;
        for (auto child : this->specs)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AttributeInstanceSyntax* clone(BumpAllocator& alloc) const;
};

struct NamedLabelSyntax : public SyntaxNode {
    Token name;
    Token colon;

    NamedLabelSyntax(Token name, Token colon) :
        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NamedLabelSyntax* clone(BumpAllocator& alloc) const;
};

struct StatementSyntax : public SyntaxNode {
    NamedLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), label(label), attributes(attributes) {
        if (this->label) this->label->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StatementSyntax* clone(BumpAllocator& alloc) const;
};

struct MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MemberSyntax* clone(BumpAllocator& alloc) const;
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct EmptyArgumentSyntax : public ArgumentSyntax {

    EmptyArgumentSyntax() :
        ArgumentSyntax(SyntaxKind::EmptyArgument) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EmptyArgumentSyntax* clone(BumpAllocator& alloc) const;
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    not_null<ExpressionSyntax*> expr;

    OrderedArgumentSyntax(ExpressionSyntax& expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    OrderedArgumentSyntax* clone(BumpAllocator& alloc) const;
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NamedArgumentSyntax* clone(BumpAllocator& alloc) const;
};

struct ArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token closeParen;

    ArgumentListSyntax(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen) {
        this->parameters.parent = this;
        for (auto child : this->parameters)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ArgumentListSyntax* clone(BumpAllocator& alloc) const;
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token hash;
    not_null<ArgumentListSyntax*> parameters;

    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax& parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(&parameters) {
        this->parameters->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParameterValueAssignmentSyntax* clone(BumpAllocator& alloc) const;
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct VariablePatternSyntax : public PatternSyntax {
    Token dot;
    Token variableName;

    VariablePatternSyntax(Token dot, Token variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    VariablePatternSyntax* clone(BumpAllocator& alloc) const;
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token dotStar;

    WildcardPatternSyntax(Token dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WildcardPatternSyntax* clone(BumpAllocator& alloc) const;
};

struct ExpressionPatternSyntax : public PatternSyntax {
    not_null<ExpressionSyntax*> expr;

    ExpressionPatternSyntax(ExpressionSyntax& expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExpressionPatternSyntax* clone(BumpAllocator& alloc) const;
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token tagged;
    Token memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern) {
        if (this->pattern) this->pattern->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TaggedPatternSyntax* clone(BumpAllocator& alloc) const;
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    not_null<PatternSyntax*> pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(&pattern) {
        this->pattern->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    OrderedStructurePatternMemberSyntax* clone(BumpAllocator& alloc) const;
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token name;
    Token colon;
    not_null<PatternSyntax*> pattern;

    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(&pattern) {
        this->pattern->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NamedStructurePatternMemberSyntax* clone(BumpAllocator& alloc) const;
};

struct StructurePatternSyntax : public PatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token closeBrace;

    StructurePatternSyntax(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StructurePatternSyntax* clone(BumpAllocator& alloc) const;
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token matchesKeyword;
    not_null<PatternSyntax*> pattern;

    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(&pattern) {
        this->pattern->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MatchesClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct ConditionalPatternSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(&expr), matchesClause(matchesClause) {
        this->expr->parent = this;
        if (this->matchesClause) this->matchesClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConditionalPatternSyntax* clone(BumpAllocator& alloc) const;
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions) {
        this->conditions.parent = this;
        for (auto child : this->conditions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConditionalPredicateSyntax* clone(BumpAllocator& alloc) const;
};

struct AssignmentPatternSyntax : public SyntaxNode {

    AssignmentPatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token closeBrace;

    SimpleAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    SimpleAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
};

struct AssignmentPatternItemSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> key;
    Token colon;
    not_null<ExpressionSyntax*> expr;

    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(&key), colon(colon), expr(&expr) {
        this->key->parent = this;
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AssignmentPatternItemSyntax* clone(BumpAllocator& alloc) const;
};

struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
    Token closeBrace;

    StructuredAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StructuredAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
};

struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    not_null<ExpressionSyntax*> countExpr;
    Token innerOpenBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token innerCloseBrace;
    Token closeBrace;

    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(&countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
        this->countExpr->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ReplicatedAssignmentPatternSyntax* clone(BumpAllocator& alloc) const;
};

// ----- EXPRESSIONS -----

struct BadExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> expr;

    BadExpressionSyntax(ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::BadExpression), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BadExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    not_null<ExpressionSyntax*> operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(&operand) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->operand->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PrefixUnaryExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken) :
        ExpressionSyntax(kind), operand(&operand), attributes(attributes), operatorToken(operatorToken) {
        this->operand->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PostfixUnaryExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    not_null<ExpressionSyntax*> right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right) :
        ExpressionSyntax(kind), left(&left), operatorToken(operatorToken), attributes(attributes), right(&right) {
        this->left->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BinaryExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> min;
    Token colon1;
    not_null<ExpressionSyntax*> typ;
    Token colon2;
    not_null<ExpressionSyntax*> max;

    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(&min), colon1(colon1), typ(&typ), colon2(colon2), max(&max) {
        this->min->parent = this;
        this->typ->parent = this;
        this->max->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MinTypMaxExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token tagged;
    Token member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TaggedUnionExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct OpenRangeListSyntax : public SyntaxNode {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token closeBrace;

    OpenRangeListSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace) :
        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace) {
        this->valueRanges.parent = this;
        for (auto child : this->valueRanges)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    OpenRangeListSyntax* clone(BumpAllocator& alloc) const;
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> expr;
    Token inside;
    not_null<OpenRangeListSyntax*> ranges;

    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(&expr), inside(inside), ranges(&ranges) {
        this->expr->parent = this;
        this->ranges->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    InsideExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    not_null<ConditionalPredicateSyntax*> predicate;
    Token question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    not_null<ExpressionSyntax*> left;
    Token colon;
    not_null<ExpressionSyntax*> right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(&predicate), question(question), attributes(attributes), left(&left), colon(colon), right(&right) {
        this->predicate->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->left->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConditionalExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
    DataTypeSyntax* type;
    not_null<AssignmentPatternSyntax*> pattern;

    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(&pattern) {
        if (this->type) this->type->parent = this;
        this->pattern->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AssignmentPatternExpressionSyntax* clone(BumpAllocator& alloc) const;
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct BitSelectSyntax : public SelectorSyntax {
    not_null<ExpressionSyntax*> expr;

    BitSelectSyntax(ExpressionSyntax& expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BitSelectSyntax* clone(BumpAllocator& alloc) const;
};

struct RangeSelectSyntax : public SelectorSyntax {
    not_null<ExpressionSyntax*> left;
    Token range;
    not_null<ExpressionSyntax*> right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
        SelectorSyntax(kind), left(&left), range(range), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RangeSelectSyntax* clone(BumpAllocator& alloc) const;
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;

    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket) {
        if (this->selector) this->selector->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ElementSelectSyntax* clone(BumpAllocator& alloc) const;
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct IdentifierNameSyntax : public NameSyntax {
    Token identifier;

    IdentifierNameSyntax(Token identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IdentifierNameSyntax* clone(BumpAllocator& alloc) const;
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors) {
        this->selectors.parent = this;
        for (auto child : this->selectors)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IdentifierSelectNameSyntax* clone(BumpAllocator& alloc) const;
};

struct EmptyIdentifierNameSyntax : public NameSyntax {

    EmptyIdentifierNameSyntax() :
        NameSyntax(SyntaxKind::EmptyIdentifierName) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EmptyIdentifierNameSyntax* clone(BumpAllocator& alloc) const;
};

struct KeywordNameSyntax : public NameSyntax {
    Token keyword;

    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
        NameSyntax(kind), keyword(keyword) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    KeywordNameSyntax* clone(BumpAllocator& alloc) const;
};

struct ClassNameSyntax : public NameSyntax {
    Token identifier;
    not_null<ParameterValueAssignmentSyntax*> parameters;

    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(&parameters) {
        this->parameters->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClassNameSyntax* clone(BumpAllocator& alloc) const;
};

struct ScopedNameSyntax : public NameSyntax {
    not_null<NameSyntax*> left;
    Token separator;
    not_null<NameSyntax*> right;

    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
        NameSyntax(SyntaxKind::ScopedName), left(&left), separator(separator), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ScopedNameSyntax* clone(BumpAllocator& alloc) const;
};

struct ClassScopeSyntax : public NameSyntax {
    not_null<NameSyntax*> left;
    Token separator;

    ClassScopeSyntax(NameSyntax& left, Token separator) :
        NameSyntax(SyntaxKind::ClassScope), left(&left), separator(separator) {
        this->left->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClassScopeSyntax* clone(BumpAllocator& alloc) const;
};

// ----- PRIMARY EXPRESSIONS -----

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
        PrimaryExpressionSyntax(kind), literal(literal) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    LiteralExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
    Token size;
    Token base;
    Token value;

    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IntegerVectorExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token closeBrace;

    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EmptyQueueExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeBrace;

    ConcatenationExpressionSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    not_null<ExpressionSyntax*> expression;
    not_null<ConcatenationExpressionSyntax*> concatenation;
    Token closeBrace;

    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(&expression), concatenation(&concatenation), closeBrace(closeBrace) {
        this->expression->parent = this;
        this->concatenation->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MultipleConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token withKeyword;
    not_null<ElementSelectSyntax*> range;

    StreamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(&range) {
        this->range->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StreamExpressionWithRange* clone(BumpAllocator& alloc) const;
};

struct StreamExpressionSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(&expression), withRange(withRange) {
        this->expression->parent = this;
        if (this->withRange) this->withRange->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StreamExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token operatorToken;
    ExpressionSyntax* sliceSize;
    Token innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token innerCloseBrace;
    Token closeBrace;

    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace) {
        if (this->sliceSize) this->sliceSize->parent = this;
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StreamingConcatenationExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token openParen;
    not_null<ExpressionSyntax*> expression;
    Token closeParen;

    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(&expression), closeParen(closeParen) {
        this->expression->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParenthesizedExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax* classScope;
    Token newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments) {
        if (this->classScope) this->classScope->parent = this;
        if (this->arguments) this->arguments->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NewClassExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    Token openBracket;
    not_null<ExpressionSyntax*> sizeExpr;
    Token closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(&sizeExpr), closeBracket(closeBracket), initializer(initializer) {
        this->sizeExpr->parent = this;
        if (this->initializer) this->initializer->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NewArrayExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct NewExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    not_null<ExpressionSyntax*> expr;

    NewExpressionSyntax(Token newKeyword, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::NewExpression), newKeyword(newKeyword), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NewExpressionSyntax* clone(BumpAllocator& alloc) const;
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    not_null<ElementSelectSyntax*> select;

    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(&left), select(&select) {
        this->left->parent = this;
        this->select->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ElementSelectExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    Token dot;
    Token name;

    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(&left), dot(dot), name(name) {
        this->left->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MemberAccessExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(&left), attributes(attributes), arguments(arguments) {
        this->left->parent = this;
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        if (this->arguments) this->arguments->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    InvocationExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct CastExpressionSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    Token apostrophe;
    not_null<ParenthesizedExpressionSyntax*> right;

    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::CastExpression), left(&left), apostrophe(apostrophe), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CastExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct SignedCastExpressionSyntax : public ExpressionSyntax {
    Token signing;
    Token apostrophe;
    not_null<ParenthesizedExpressionSyntax*> inner;

    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(&inner) {
        this->inner->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    SignedCastExpressionSyntax* clone(BumpAllocator& alloc) const;
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct DelaySyntax : public TimingControlSyntax {
    Token hash;
    not_null<ExpressionSyntax*> delayValue;

    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
        TimingControlSyntax(kind), hash(hash), delayValue(&delayValue) {
        this->delayValue->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DelaySyntax* clone(BumpAllocator& alloc) const;
};

struct EventControlSyntax : public TimingControlSyntax {
    Token at;
    not_null<NameSyntax*> eventName;

    EventControlSyntax(Token at, NameSyntax& eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(&eventName) {
        this->eventName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EventControlSyntax* clone(BumpAllocator& alloc) const;
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token edge;
    not_null<ExpressionSyntax*> expr;

    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    SignalEventExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    not_null<EventExpressionSyntax*> left;
    Token operatorToken;
    not_null<EventExpressionSyntax*> right;

    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(&left), operatorToken(operatorToken), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BinaryEventExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token openParen;
    not_null<EventExpressionSyntax*> expr;
    Token closeParen;

    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParenthesizedEventExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token atStar;

    ImplicitEventControlSyntax(Token atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImplicitEventControlSyntax* clone(BumpAllocator& alloc) const;
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token at;
    Token openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token at, Token openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParenImplicitEventControlSyntax* clone(BumpAllocator& alloc) const;
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token at;
    not_null<EventExpressionSyntax*> expr;

    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EventControlWithExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token repeat;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(&expr), closeParen(closeParen), eventControl(eventControl) {
        this->expr->parent = this;
        if (this->eventControl) this->eventControl->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RepeatedEventControlSyntax* clone(BumpAllocator& alloc) const;
};

struct TimingControlExpressionSyntax : public ExpressionSyntax {
    not_null<TimingControlSyntax*> timing;
    not_null<ExpressionSyntax*> expr;

    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(&timing), expr(&expr) {
        this->timing->parent = this;
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TimingControlExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct TimingControlExpressionConcatenationSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> left;
    not_null<TimingControlSyntax*> timing;
    not_null<ExpressionSyntax*> right;

    TimingControlExpressionConcatenationSyntax(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::TimingControlExpressionConcatenation), left(&left), timing(&timing), right(&right) {
        this->left->parent = this;
        this->timing->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TimingControlExpressionConcatenationSyntax* clone(BumpAllocator& alloc) const;
};

struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
    Token doubleHash;
    Token openBracket;
    Token op;
    Token closeBracket;

    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ShortcutCycleDelayRangeSyntax* clone(BumpAllocator& alloc) const;
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    not_null<SelectorSyntax*> selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(&selector) {
        this->selector->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RangeDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token star;

    WildcardDimensionSpecifierSyntax(Token star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WildcardDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token colon;
    not_null<ExpressionSyntax*> expr;

    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ColonExpressionClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause) {
        if (this->maxSizeClause) this->maxSizeClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    QueueDimensionSpecifierSyntax* clone(BumpAllocator& alloc) const;
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token openBracket;
    DimensionSpecifierSyntax* specifier;
    Token closeBracket;

    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket) {
        if (this->specifier) this->specifier->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    VariableDimensionSyntax* clone(BumpAllocator& alloc) const;
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
        if (this->initializer) this->initializer->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    VariableDeclaratorSyntax* clone(BumpAllocator& alloc) const;
};

struct DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    DataDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(&type), declarators(declarators), semi(semi) {
        this->modifiers.parent = this;
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DataDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct TypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    not_null<DataTypeSyntax*> type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token semi;

    TypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi) :
        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(&type), name(name), dimensions(dimensions), semi(semi) {
        this->type->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ForwardTypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token keyword;
    Token name;
    Token semi;

    ForwardTypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ForwardTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForwardTypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ForwardInterfaceClassTypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token interfaceKeyword;
    Token classKeyword;
    Token name;
    Token semi;

    ForwardInterfaceClassTypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ForwardInterfaceClassTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForwardInterfaceClassTypedefDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct NetStrengthSyntax : public SyntaxNode {

    NetStrengthSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct ChargeStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ChargeStrengthSyntax* clone(BumpAllocator& alloc) const;
};

struct DriveStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength0;
    Token comma;
    Token strength1;
    Token closeParen;

    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DriveStrengthSyntax* clone(BumpAllocator& alloc) const;
};

struct NetDeclarationSyntax : public MemberSyntax {
    Token netType;
    NetStrengthSyntax* strength;
    Token expansionHint;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    NetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(&type), declarators(declarators), semi(semi) {
        if (this->strength) this->strength->parent = this;
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NetDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct PackageImportItemSyntax : public SyntaxNode {
    Token package;
    Token doubleColon;
    Token item;

    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PackageImportItemSyntax* clone(BumpAllocator& alloc) const;
};

struct PackageImportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageImportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PackageImportDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ParameterDeclarationSyntax : public SyntaxNode {
    Token keyword;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;

    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators) :
        SyntaxNode(SyntaxKind::ParameterDeclaration), keyword(keyword), type(&type), declarators(declarators) {
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParameterDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ParameterDeclarationStatementSyntax : public MemberSyntax {
    not_null<ParameterDeclarationSyntax*> parameter;
    Token semi;

    ParameterDeclarationStatementSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi) :
        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(&parameter), semi(semi) {
        this->parameter->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParameterDeclarationStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct PortDeclarationSyntax : public MemberSyntax {
    not_null<PortHeaderSyntax*> header;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    PortDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(&header), declarators(declarators), semi(semi) {
        this->header->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PortDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct GenvarDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token semi;

    GenvarDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi) :
        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi) {
        this->identifiers.parent = this;
        for (auto child : this->identifiers)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    GenvarDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IntegerTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
        DataTypeSyntax(kind), keyword(keyword) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    KeywordTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct NamedTypeSyntax : public DataTypeSyntax {
    not_null<NameSyntax*> name;

    NamedTypeSyntax(NameSyntax& name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(&name) {
        this->name->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NamedTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token randomQualifier;
    not_null<DataTypeSyntax*> type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    StructUnionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(&type), declarators(declarators), semi(semi) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->type->parent = this;
        this->declarators.parent = this;
        for (auto child : this->declarators)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StructUnionMemberSyntax* clone(BumpAllocator& alloc) const;
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token tagged;
    Token packed;
    Token signing;
    Token openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StructUnionTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token keyword;
    DataTypeSyntax* baseType;
    Token openBrace;
    SeparatedSyntaxList<VariableDeclaratorSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions) {
        if (this->baseType) this->baseType->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EnumTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct TypeReferenceSyntax : public DataTypeSyntax {
    Token typeKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TypeReferenceSyntax* clone(BumpAllocator& alloc) const;
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token dot;
    Token member;

    DotMemberClauseSyntax(Token dot, Token member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DotMemberClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token virtualKeyword;
    Token interfaceKeyword;
    Token name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport) {
        if (this->parameters) this->parameters->parent = this;
        if (this->modport) this->modport->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    VirtualInterfaceTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct ImplicitTypeSyntax : public DataTypeSyntax {
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImplicitTypeSyntax* clone(BumpAllocator& alloc) const;
};

struct VarDataTypeSyntax : public DataTypeSyntax {
    Token var;
    not_null<DataTypeSyntax*> type;

    VarDataTypeSyntax(Token var, DataTypeSyntax& type) :
        DataTypeSyntax(SyntaxKind::VarDataType), var(var), type(&type) {
        this->type->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    VarDataTypeSyntax* clone(BumpAllocator& alloc) const;
};

// ----- ASSERTIONS -----

struct DeferredAssertionSyntax : public SyntaxNode {
    Token hash;
    Token zero;
    Token finalKeyword;

    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DeferredAssertionSyntax* clone(BumpAllocator& alloc) const;
};

struct ElseClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    not_null<SyntaxNode*> clause;

    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(&clause) {
        this->clause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ElseClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct ActionBlockSyntax : public SyntaxNode {
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause) {
        if (this->statement) this->statement->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ActionBlockSyntax* clone(BumpAllocator& alloc) const;
};

struct ImmediateAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    DeferredAssertionSyntax* delay;
    not_null<ParenthesizedExpressionSyntax*> expr;
    not_null<ActionBlockSyntax*> action;

    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(&expr), action(&action) {
        if (this->delay) this->delay->parent = this;
        this->expr->parent = this;
        this->action->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImmediateAssertionStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct DisableIffSyntax : public SyntaxNode {
    Token disable;
    Token iff;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DisableIffSyntax* clone(BumpAllocator& alloc) const;
};

struct PropertySpecSyntax : public SyntaxNode {
    TimingControlSyntax* clocking;
    DisableIffSyntax* disable;
    not_null<ExpressionSyntax*> expr;

    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(&expr) {
        if (this->clocking) this->clocking->parent = this;
        if (this->disable) this->disable->parent = this;
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PropertySpecSyntax* clone(BumpAllocator& alloc) const;
};

struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    Token propertyOrSequence;
    Token openParen;
    not_null<PropertySpecSyntax*> propertySpec;
    Token closeParen;
    not_null<ActionBlockSyntax*> action;

    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(&propertySpec), closeParen(closeParen), action(&action) {
        this->propertySpec->parent = this;
        this->action->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConcurrentAssertionStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
    not_null<ConcurrentAssertionStatementSyntax*> statement;

    ConcurrentAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(&statement) {
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConcurrentAssertionMemberSyntax* clone(BumpAllocator& alloc) const;
};

struct ImmediateAssertionMemberSyntax : public MemberSyntax {
    not_null<ImmediateAssertionStatementSyntax*> statement;

    ImmediateAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(&statement) {
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImmediateAssertionMemberSyntax* clone(BumpAllocator& alloc) const;
};

// ----- STATEMENTS -----

struct EmptyStatementSyntax : public StatementSyntax {
    Token semicolon;

    EmptyStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EmptyStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token ifKeyword;
    Token openParen;
    not_null<ConditionalPredicateSyntax*> predicate;
    Token closeParen;
    not_null<StatementSyntax*> statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(&predicate), closeParen(closeParen), statement(&statement), elseClause(elseClause) {
        this->predicate->parent = this;
        this->statement->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConditionalStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    not_null<SyntaxNode*> clause;

    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(&clause) {
        this->clause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DefaultCaseItemSyntax* clone(BumpAllocator& alloc) const;
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    not_null<PatternSyntax*> pattern;
    Token tripleAnd;
    ExpressionSyntax* expr;
    Token colon;
    not_null<StatementSyntax*> statement;

    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(&pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(&statement) {
        this->pattern->parent = this;
        if (this->expr) this->expr->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PatternCaseItemSyntax* clone(BumpAllocator& alloc) const;
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    not_null<SyntaxNode*> clause;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(&clause) {
        this->expressions.parent = this;
        for (auto child : this->expressions)
            child->parent = this;
        this->clause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    StandardCaseItemSyntax* clone(BumpAllocator& alloc) const;
};

struct CaseStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token caseKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    Token matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token endcase;

    CaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase) {
        this->expr->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CaseStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token foreverKeyword;
    not_null<StatementSyntax*> statement;

    ForeverStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(&statement) {
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForeverStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct LoopStatementSyntax : public StatementSyntax {
    Token repeatOrWhile;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    not_null<StatementSyntax*> statement;

    LoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
        this->expr->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    LoopStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token doKeyword;
    not_null<StatementSyntax*> statement;
    Token whileKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    Token semi;

    DoWhileStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(&statement), whileKeyword(whileKeyword), openParen(openParen), expr(&expr), closeParen(closeParen), semi(semi) {
        this->statement->parent = this;
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DoWhileStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ForVariableDeclarationSyntax : public SyntaxNode {
    Token varKeyword;
    not_null<DataTypeSyntax*> type;
    not_null<VariableDeclaratorSyntax*> declarator;

    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(&type), declarator(&declarator) {
        this->type->parent = this;
        this->declarator->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForVariableDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ForLoopStatementSyntax : public StatementSyntax {
    Token forKeyword;
    Token openParen;
    SeparatedSyntaxList<SyntaxNode> initializers;
    Token semi1;
    not_null<ExpressionSyntax*> stopExpr;
    Token semi2;
    SeparatedSyntaxList<ExpressionSyntax> steps;
    Token closeParen;
    not_null<StatementSyntax*> statement;

    ForLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(&statement) {
        this->initializers.parent = this;
        for (auto child : this->initializers)
            child->parent = this;
        this->stopExpr->parent = this;
        this->steps.parent = this;
        for (auto child : this->steps)
            child->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForLoopStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ForeachLoopListSyntax : public SyntaxNode {
    Token openParen;
    not_null<NameSyntax*> arrayName;
    Token openBracket;
    SeparatedSyntaxList<NameSyntax> loopVariables;
    Token closeBracket;
    Token closeParen;

    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen) :
        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(&arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen) {
        this->arrayName->parent = this;
        this->loopVariables.parent = this;
        for (auto child : this->loopVariables)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForeachLoopListSyntax* clone(BumpAllocator& alloc) const;
};

struct ForeachLoopStatementSyntax : public StatementSyntax {
    Token keyword;
    not_null<ForeachLoopListSyntax*> loopList;
    not_null<StatementSyntax*> statement;

    ForeachLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(&loopList), statement(&statement) {
        this->loopList->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ForeachLoopStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token returnKeyword;
    ExpressionSyntax* returnValue;
    Token semi;

    ReturnStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi) {
        if (this->returnValue) this->returnValue->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ReturnStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct JumpStatementSyntax : public StatementSyntax {
    Token breakOrContinue;
    Token semi;

    JumpStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    JumpStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct TimingControlStatementSyntax : public StatementSyntax {
    not_null<TimingControlSyntax*> timingControl;
    not_null<StatementSyntax*> statement;

    TimingControlStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(&timingControl), statement(&statement) {
        this->timingControl->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TimingControlStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ExpressionStatementSyntax : public StatementSyntax {
    not_null<ExpressionSyntax*> expr;
    Token semi;

    ExpressionStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi) :
        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExpressionStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token keyword;
    not_null<ExpressionSyntax*> lvalue;
    Token equals;
    not_null<ExpressionSyntax*> value;
    Token semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(&lvalue), equals(equals), value(&value), semi(semi) {
        this->lvalue->parent = this;
        this->value->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ProceduralAssignStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token keyword;
    not_null<ExpressionSyntax*> variable;
    Token semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(&variable), semi(semi) {
        this->variable->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ProceduralDeassignStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct DisableStatementSyntax : public StatementSyntax {
    Token disable;
    not_null<NameSyntax*> name;
    Token semi;

    DisableStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(&name), semi(semi) {
        this->name->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DisableStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token disable;
    Token fork;
    Token semi;

    DisableForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DisableForkStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token colon;
    Token name;

    NamedBlockClauseSyntax(Token colon, Token name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NamedBlockClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct BlockStatementSyntax : public StatementSyntax {
    Token begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName) {
        if (this->blockName) this->blockName->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BlockStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct WaitStatementSyntax : public StatementSyntax {
    Token wait;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;
    not_null<StatementSyntax*> statement;

    WaitStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(&expr), closeParen(closeParen), statement(&statement) {
        this->expr->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WaitStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct WaitForkStatementSyntax : public StatementSyntax {
    Token wait;
    Token fork;
    Token semi;

    WaitForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WaitForkStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct WaitOrderStatementSyntax : public StatementSyntax {
    Token wait_order;
    Token openParen;
    SeparatedSyntaxList<NameSyntax> names;
    Token closeParen;
    not_null<ActionBlockSyntax*> action;

    WaitOrderStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(&action) {
        this->names.parent = this;
        for (auto child : this->names)
            child->parent = this;
        this->action->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WaitOrderStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct RandCaseItemSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> expr;
    Token colon;
    not_null<StatementSyntax*> statement;

    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
        SyntaxNode(SyntaxKind::RandCaseItem), expr(&expr), colon(colon), statement(&statement) {
        this->expr->parent = this;
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RandCaseItemSyntax* clone(BumpAllocator& alloc) const;
};

struct RandCaseStatementSyntax : public StatementSyntax {
    Token randCase;
    SyntaxList<RandCaseItemSyntax> items;
    Token endCase;

    RandCaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase) :
        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RandCaseStatementSyntax* clone(BumpAllocator& alloc) const;
};

struct EventTriggerStatementSyntax : public StatementSyntax {
    Token trigger;
    TimingControlSyntax* timing;
    not_null<NameSyntax*> name;

    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) :
        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(&name) {
        if (this->timing) this->timing->parent = this;
        this->name->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EventTriggerStatementSyntax* clone(BumpAllocator& alloc) const;
};

// ----- MODULES -----

struct PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct PortExpressionSyntax : public SyntaxNode {

    PortExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct PortReferenceSyntax : public PortExpressionSyntax {
    Token name;
    ElementSelectSyntax* select;

    PortReferenceSyntax(Token name, ElementSelectSyntax* select) :
        PortExpressionSyntax(SyntaxKind::PortReference), name(name), select(select) {
        if (this->select) this->select->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PortReferenceSyntax* clone(BumpAllocator& alloc) const;
};

struct PortConcatenationSyntax : public PortExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<PortReferenceSyntax> references;
    Token closeBrace;

    PortConcatenationSyntax(Token openBrace, SeparatedSyntaxList<PortReferenceSyntax> references, Token closeBrace) :
        PortExpressionSyntax(SyntaxKind::PortConcatenation), openBrace(openBrace), references(references), closeBrace(closeBrace) {
        this->references.parent = this;
        for (auto child : this->references)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PortConcatenationSyntax* clone(BumpAllocator& alloc) const;
};

struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    PortExpressionSyntax* expr;

    ImplicitNonAnsiPortSyntax(PortExpressionSyntax* expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImplicitNonAnsiPortSyntax* clone(BumpAllocator& alloc) const;
};

struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    PortExpressionSyntax* expr;
    Token closeParen;

    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExplicitNonAnsiPortSyntax* clone(BumpAllocator& alloc) const;
};

struct NonAnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token closeParen;

    NonAnsiPortListSyntax(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NonAnsiPortListSyntax* clone(BumpAllocator& alloc) const;
};

struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport) {
        if (this->modport) this->modport->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    InterfacePortHeaderSyntax* clone(BumpAllocator& alloc) const;
};

struct VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token varKeyword;
    not_null<DataTypeSyntax*> dataType;

    VariablePortHeaderSyntax(Token direction, Token varKeyword, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), dataType(&dataType) {
        this->dataType->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    VariablePortHeaderSyntax* clone(BumpAllocator& alloc) const;
};

struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token interconnect;
    DataTypeSyntax* type;

    InterconnectPortHeaderSyntax(Token direction, Token interconnect, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(type) {
        if (this->type) this->type->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    InterconnectPortHeaderSyntax* clone(BumpAllocator& alloc) const;
};

struct NetPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token netType;
    not_null<DataTypeSyntax*> dataType;

    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(&dataType) {
        this->dataType->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NetPortHeaderSyntax* clone(BumpAllocator& alloc) const;
};

struct ImplicitAnsiPortSyntax : public MemberSyntax {
    not_null<PortHeaderSyntax*> header;
    not_null<VariableDeclaratorSyntax*> declarator;

    ImplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator) :
        MemberSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(&header), declarator(&declarator) {
        this->header->parent = this;
        this->declarator->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImplicitAnsiPortSyntax* clone(BumpAllocator& alloc) const;
};

struct ExplicitAnsiPortSyntax : public MemberSyntax {
    Token direction;
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        MemberSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExplicitAnsiPortSyntax* clone(BumpAllocator& alloc) const;
};

struct AnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<MemberSyntax> ports;
    Token closeParen;

    AnsiPortListSyntax(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AnsiPortListSyntax* clone(BumpAllocator& alloc) const;
};

struct WildcardPortListSyntax : public PortListSyntax {
    Token openParen;
    Token dotStar;
    Token closeParen;

    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WildcardPortListSyntax* clone(BumpAllocator& alloc) const;
};

struct ParameterPortListSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParameterDeclarationSyntax> declarations;
    Token closeParen;

    ParameterPortListSyntax(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen) {
        this->declarations.parent = this;
        for (auto child : this->declarations)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ParameterPortListSyntax* clone(BumpAllocator& alloc) const;
};

struct ModuleHeaderSyntax : public SyntaxNode {
    Token moduleKeyword;
    Token lifetime;
    Token name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi) {
        this->imports.parent = this;
        for (auto child : this->imports)
            child->parent = this;
        if (this->parameters) this->parameters->parent = this;
        if (this->ports) this->ports->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModuleHeaderSyntax* clone(BumpAllocator& alloc) const;
};

struct ModuleDeclarationSyntax : public MemberSyntax {
    not_null<ModuleHeaderSyntax*> header;
    SyntaxList<MemberSyntax> members;
    Token endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(&header), members(members), endmodule(endmodule), blockName(blockName) {
        this->header->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->blockName) this->blockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModuleDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ExternModuleSyntax : public SyntaxNode {
    Token externKeyword;
    not_null<ModuleHeaderSyntax*> header;

    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax& header) :
        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(&header) {
        this->header->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExternModuleSyntax* clone(BumpAllocator& alloc) const;
};

// ----- MEMBERS -----

struct EmptyMemberSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token semi;

    EmptyMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi) :
        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi) {
        this->qualifiers.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    EmptyMemberSyntax* clone(BumpAllocator& alloc) const;
};

struct ProceduralBlockSyntax : public MemberSyntax {
    Token keyword;
    not_null<StatementSyntax*> statement;

    ProceduralBlockSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(&statement) {
        this->statement->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ProceduralBlockSyntax* clone(BumpAllocator& alloc) const;
};

struct GenerateRegionSyntax : public MemberSyntax {
    Token keyword;
    SyntaxList<MemberSyntax> members;
    Token endgenerate;

    GenerateRegionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate) :
        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    GenerateRegionSyntax* clone(BumpAllocator& alloc) const;
};

struct LoopGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    Token genvar;
    Token identifier;
    Token equals;
    not_null<ExpressionSyntax*> initialExpr;
    Token semi1;
    not_null<ExpressionSyntax*> stopExpr;
    Token semi2;
    not_null<ExpressionSyntax*> iterationExpr;
    Token closeParen;
    not_null<MemberSyntax*> block;

    LoopGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(&initialExpr), semi1(semi1), stopExpr(&stopExpr), semi2(semi2), iterationExpr(&iterationExpr), closeParen(closeParen), block(&block) {
        this->initialExpr->parent = this;
        this->stopExpr->parent = this;
        this->iterationExpr->parent = this;
        this->block->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    LoopGenerateSyntax* clone(BumpAllocator& alloc) const;
};

struct IfGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<MemberSyntax*> block;
    ElseClauseSyntax* elseClause;

    IfGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), block(&block), elseClause(elseClause) {
        this->condition->parent = this;
        this->block->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IfGenerateSyntax* clone(BumpAllocator& alloc) const;
};

struct CaseGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    SyntaxList<CaseItemSyntax> items;
    Token endCase;

    CaseGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase) :
        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(&condition), closeParen(closeParen), items(items), endCase(endCase) {
        this->condition->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CaseGenerateSyntax* clone(BumpAllocator& alloc) const;
};

struct GenerateBlockSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token begin;
    NamedBlockClauseSyntax* beginName;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endName;

    GenerateBlockSyntax(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName) {
        if (this->label) this->label->parent = this;
        if (this->beginName) this->beginName->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->endName) this->endName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    GenerateBlockSyntax* clone(BumpAllocator& alloc) const;
};

struct DividerClauseSyntax : public SyntaxNode {
    Token divide;
    Token value;

    DividerClauseSyntax(Token divide, Token value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DividerClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token time;
    DividerClauseSyntax* divider;
    Token semi;

    TimeUnitsDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi) {
        if (this->divider) this->divider->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TimeUnitsDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PortConnectionSyntax* clone(BumpAllocator& alloc) const;
};

struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
    not_null<ExpressionSyntax*> expr;

    OrderedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    OrderedPortConnectionSyntax* clone(BumpAllocator& alloc) const;
};

struct NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    NamedPortConnectionSyntax* clone(BumpAllocator& alloc) const;
};

struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token dotStar;

    WildcardPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WildcardPortConnectionSyntax* clone(BumpAllocator& alloc) const;
};

struct HierarchicalInstanceSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token closeParen;

    HierarchicalInstanceSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen) {
        this->dimensions.parent = this;
        for (auto child : this->dimensions)
            child->parent = this;
        this->connections.parent = this;
        for (auto child : this->connections)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    HierarchicalInstanceSyntax* clone(BumpAllocator& alloc) const;
};

struct HierarchyInstantiationSyntax : public MemberSyntax {
    Token type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    HierarchyInstantiationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi) {
        if (this->parameters) this->parameters->parent = this;
        this->instances.parent = this;
        for (auto child : this->instances)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    HierarchyInstantiationSyntax* clone(BumpAllocator& alloc) const;
};

struct FunctionPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token constKeyword;
    Token direction;
    Token varKeyword;
    DataTypeSyntax* dataType;
    not_null<VariableDeclaratorSyntax*> declarator;

    FunctionPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(&declarator) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        if (this->dataType) this->dataType->parent = this;
        this->declarator->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    FunctionPortSyntax* clone(BumpAllocator& alloc) const;
};

struct FunctionPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<FunctionPortSyntax> ports;
    Token closeParen;

    FunctionPortListSyntax(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    FunctionPortListSyntax* clone(BumpAllocator& alloc) const;
};

struct FunctionPrototypeSyntax : public SyntaxNode {
    Token keyword;
    Token lifetime;
    DataTypeSyntax* returnType;
    not_null<NameSyntax*> name;
    FunctionPortListSyntax* portList;

    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList) :
        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(returnType), name(&name), portList(portList) {
        if (this->returnType) this->returnType->parent = this;
        this->name->parent = this;
        if (this->portList) this->portList->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    FunctionPrototypeSyntax* clone(BumpAllocator& alloc) const;
};

struct FunctionDeclarationSyntax : public MemberSyntax {
    not_null<FunctionPrototypeSyntax*> prototype;
    Token semi;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    FunctionDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, Token semi, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(kind, attributes), prototype(&prototype), semi(semi), items(items), end(end), endBlockName(endBlockName) {
        this->prototype->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    FunctionDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct AssertionItemPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token local;
    Token direction;
    not_null<DataTypeSyntax*> type;
    not_null<VariableDeclaratorSyntax*> declarator;

    AssertionItemPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(&type), declarator(&declarator) {
        this->attributes.parent = this;
        for (auto child : this->attributes)
            child->parent = this;
        this->type->parent = this;
        this->declarator->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AssertionItemPortSyntax* clone(BumpAllocator& alloc) const;
};

struct AssertionItemPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
    Token closeParen;

    AssertionItemPortListSyntax(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    AssertionItemPortListSyntax* clone(BumpAllocator& alloc) const;
};

struct LetDeclarationSyntax : public MemberSyntax {
    Token let;
    Token identifier;
    AssertionItemPortListSyntax* portList;
    not_null<EqualsValueClauseSyntax*> initializer;
    Token semi;

    LetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) :
        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), initializer(&initializer), semi(semi) {
        if (this->portList) this->portList->parent = this;
        this->initializer->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    LetDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct PropertyDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<MemberSyntax> assertionVariables;
    not_null<PropertySpecSyntax*> propertySpec;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    PropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::PropertyDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), propertySpec(&propertySpec), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        this->assertionVariables.parent = this;
        for (auto child : this->assertionVariables)
            child->parent = this;
        this->propertySpec->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PropertyDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct SequenceDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<MemberSyntax> assertionVariables;
    not_null<ExpressionSyntax*> seqExpr;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    SequenceDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::SequenceDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), seqExpr(&seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        this->assertionVariables.parent = this;
        for (auto child : this->assertionVariables)
            child->parent = this;
        this->seqExpr->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    SequenceDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ExtendsClauseSyntax : public SyntaxNode {
    Token keyword;
    not_null<NameSyntax*> baseName;
    ArgumentListSyntax* arguments;

    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) :
        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(&baseName), arguments(arguments) {
        this->baseName->parent = this;
        if (this->arguments) this->arguments->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExtendsClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct ImplementsClauseSyntax : public SyntaxNode {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> interfaces;

    ImplementsClauseSyntax(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces) :
        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces) {
        this->interfaces.parent = this;
        for (auto child : this->interfaces)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImplementsClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct ClassDeclarationSyntax : public MemberSyntax {
    Token virtualOrInterface;
    Token classKeyword;
    Token lifetime;
    Token name;
    ParameterPortListSyntax* parameters;
    ExtendsClauseSyntax* extendsClause;
    ImplementsClauseSyntax* implementsClause;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClass;
    NamedBlockClauseSyntax* endBlockName;

    ClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName) {
        if (this->parameters) this->parameters->parent = this;
        if (this->extendsClause) this->extendsClause->parent = this;
        if (this->implementsClause) this->implementsClause->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClassDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ClassPropertyDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    not_null<MemberSyntax*> declaration;

    ClassPropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
        this->qualifiers.parent = this;
        this->declaration->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClassPropertyDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ClassMethodDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    not_null<FunctionDeclarationSyntax*> declaration;

    ClassMethodDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(&declaration) {
        this->qualifiers.parent = this;
        this->declaration->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClassMethodDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ClassMethodPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    not_null<FunctionPrototypeSyntax*> prototype;
    Token semi;

    ClassMethodPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype, Token semi) :
        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(&prototype), semi(semi) {
        this->qualifiers.parent = this;
        this->prototype->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClassMethodPrototypeSyntax* clone(BumpAllocator& alloc) const;
};

struct ContinuousAssignSyntax : public MemberSyntax {
    Token assign;
    SeparatedSyntaxList<ExpressionSyntax> assignments;
    Token semi;

    ContinuousAssignSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), assignments(assignments), semi(semi) {
        this->assignments.parent = this;
        for (auto child : this->assignments)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ContinuousAssignSyntax* clone(BumpAllocator& alloc) const;
};

struct DefParamAssignmentSyntax : public SyntaxNode {
    not_null<NameSyntax*> name;
    EqualsValueClauseSyntax* setter;

    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax* setter) :
        SyntaxNode(SyntaxKind::DefParamAssignment), name(&name), setter(setter) {
        this->name->parent = this;
        if (this->setter) this->setter->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DefParamAssignmentSyntax* clone(BumpAllocator& alloc) const;
};

struct DefParamSyntax : public MemberSyntax {
    Token defparam;
    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
    Token semi;

    DefParamSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi) {
        this->assignments.parent = this;
        for (auto child : this->assignments)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DefParamSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportClockingPortSyntax : public MemberSyntax {
    Token clocking;
    Token name;

    ModportClockingPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token clocking, Token name) :
        MemberSyntax(SyntaxKind::ModportClockingPort, attributes), clocking(clocking), name(name) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportClockingPortSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportPortSyntax : public SyntaxNode {

    ModportPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct ModportNamedPortSyntax : public ModportPortSyntax {
    Token name;

    ModportNamedPortSyntax(Token name) :
        ModportPortSyntax(SyntaxKind::ModportNamedPort), name(name) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportNamedPortSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportExplicitPortSyntax : public ModportPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ModportExplicitPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ModportPortSyntax(SyntaxKind::ModportExplicitPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen) {
        if (this->expr) this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportExplicitPortSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportSimplePortListSyntax : public MemberSyntax {
    Token direction;
    SeparatedSyntaxList<ModportPortSyntax> ports;

    ModportSimplePortListSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, SeparatedSyntaxList<ModportPortSyntax> ports) :
        MemberSyntax(SyntaxKind::ModportSimplePortList, attributes), direction(direction), ports(ports) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportSimplePortListSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportSubroutinePortSyntax : public ModportPortSyntax {
    not_null<FunctionPrototypeSyntax*> prototype;

    ModportSubroutinePortSyntax(FunctionPrototypeSyntax& prototype) :
        ModportPortSyntax(SyntaxKind::ModportSubroutinePort), prototype(&prototype) {
        this->prototype->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportSubroutinePortSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportSubroutinePortListSyntax : public MemberSyntax {
    Token importExport;
    SeparatedSyntaxList<ModportPortSyntax> ports;

    ModportSubroutinePortListSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token importExport, SeparatedSyntaxList<ModportPortSyntax> ports) :
        MemberSyntax(SyntaxKind::ModportSubroutinePortList, attributes), importExport(importExport), ports(ports) {
        this->ports.parent = this;
        for (auto child : this->ports)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportSubroutinePortListSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportItemSyntax : public SyntaxNode {
    Token name;
    not_null<AnsiPortListSyntax*> ports;

    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(&ports) {
        this->ports->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportItemSyntax* clone(BumpAllocator& alloc) const;
};

struct ModportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ModportItemSyntax> items;
    Token semi;

    ModportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ModportDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct ClockingSkewSyntax : public SyntaxNode {
    Token edge;
    Token hash;
    ExpressionSyntax* value;

    ClockingSkewSyntax(Token edge, Token hash, ExpressionSyntax* value) :
        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), hash(hash), value(value) {
        if (this->value) this->value->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClockingSkewSyntax* clone(BumpAllocator& alloc) const;
};

struct ClockingDirectionSyntax : public SyntaxNode {
    Token input;
    ClockingSkewSyntax* inputSkew;
    Token output;
    ClockingSkewSyntax* ouputSkew;
    Token inout;

    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) :
        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), ouputSkew(ouputSkew), inout(inout) {
        if (this->inputSkew) this->inputSkew->parent = this;
        if (this->ouputSkew) this->ouputSkew->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClockingDirectionSyntax* clone(BumpAllocator& alloc) const;
};

struct ClockingItemSyntax : public SyntaxNode {
    Token defaultKeyword;
    ClockingDirectionSyntax* direction;
    SeparatedSyntaxList<AttributeSpecSyntax> assignments;
    Token semi;
    MemberSyntax* declaration;

    ClockingItemSyntax(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration) :
        SyntaxNode(SyntaxKind::ClockingItem), defaultKeyword(defaultKeyword), direction(direction), assignments(assignments), semi(semi), declaration(declaration) {
        if (this->direction) this->direction->parent = this;
        this->assignments.parent = this;
        for (auto child : this->assignments)
            child->parent = this;
        if (this->declaration) this->declaration->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClockingItemSyntax* clone(BumpAllocator& alloc) const;
};

struct ClockingDeclarationSyntax : public MemberSyntax {
    Token globalOrDefault;
    Token clocking;
    Token blockName;
    Token at;
    ParenthesizedEventExpressionSyntax* event;
    Token eventIdentifier;
    Token semi;
    SyntaxList<ClockingItemSyntax> items;
    Token endClocking;
    NamedBlockClauseSyntax* endBlockName;

    ClockingDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(event), eventIdentifier(eventIdentifier), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName) {
        if (this->event) this->event->parent = this;
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ClockingDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct DPIImportExportSyntax : public MemberSyntax {
    Token keyword;
    Token stringLiteral;
    Token property;
    Token name;
    Token equals;
    not_null<FunctionPrototypeSyntax*> method;
    Token semi;

    DPIImportExportSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method, Token semi) :
        MemberSyntax(SyntaxKind::DPIImportExport, attributes), keyword(keyword), stringLiteral(stringLiteral), property(property), name(name), equals(equals), method(&method), semi(semi) {
        this->method->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DPIImportExportSyntax* clone(BumpAllocator& alloc) const;
};

// ----- CONSTRAINTS -----

struct ConstraintItemSyntax : public SyntaxNode {

    ConstraintItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct DistWeightSyntax : public SyntaxNode {
    Token op;
    not_null<ExpressionSyntax*> expr;

    DistWeightSyntax(Token op, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(&expr) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DistWeightSyntax* clone(BumpAllocator& alloc) const;
};

struct DistItemSyntax : public SyntaxNode {
    not_null<ExpressionSyntax*> range;
    DistWeightSyntax* weight;

    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
        SyntaxNode(SyntaxKind::DistItem), range(&range), weight(weight) {
        this->range->parent = this;
        if (this->weight) this->weight->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DistItemSyntax* clone(BumpAllocator& alloc) const;
};

struct DistConstraintListSyntax : public SyntaxNode {
    Token dist;
    Token openBrace;
    SeparatedSyntaxList<DistItemSyntax> items;
    Token closeBrace;

    DistConstraintListSyntax(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace) :
        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DistConstraintListSyntax* clone(BumpAllocator& alloc) const;
};

struct ExpressionOrDistSyntax : public ExpressionSyntax {
    not_null<ExpressionSyntax*> expr;
    not_null<DistConstraintListSyntax*> distribution;

    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(&expr), distribution(&distribution) {
        this->expr->parent = this;
        this->distribution->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExpressionOrDistSyntax* clone(BumpAllocator& alloc) const;
};

struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
    Token soft;
    not_null<ExpressionSyntax*> expr;
    Token semi;

    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExpressionConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
    Token unique;
    not_null<OpenRangeListSyntax*> ranges;
    Token semi;

    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax& ranges, Token semi) :
        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(&ranges), semi(semi) {
        this->ranges->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    UniquenessConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
    not_null<ExpressionSyntax*> left;
    Token arrow;
    not_null<ConstraintItemSyntax*> constraints;

    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(&left), arrow(arrow), constraints(&constraints) {
        this->left->parent = this;
        this->constraints->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ImplicationConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct ElseConstraintClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    not_null<ConstraintItemSyntax*> constraints;

    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(&constraints) {
        this->constraints->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ElseConstraintClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
    Token ifKeyword;
    Token openParen;
    not_null<ExpressionSyntax*> condition;
    Token closeParen;
    not_null<ConstraintItemSyntax*> constraints;
    ElseConstraintClauseSyntax* elseClause;

    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(&condition), closeParen(closeParen), constraints(&constraints), elseClause(elseClause) {
        this->condition->parent = this;
        this->constraints->parent = this;
        if (this->elseClause) this->elseClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConditionalConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct LoopConstraintSyntax : public ConstraintItemSyntax {
    Token foreachKeyword;
    not_null<ForeachLoopListSyntax*> loopList;
    not_null<ConstraintItemSyntax*> constraints;

    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(&loopList), constraints(&constraints) {
        this->loopList->parent = this;
        this->constraints->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    LoopConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct DisableConstraintSyntax : public ConstraintItemSyntax {
    Token disable;
    Token soft;
    not_null<NameSyntax*> name;
    Token semi;

    DisableConstraintSyntax(Token disable, Token soft, NameSyntax& name, Token semi) :
        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(&name), semi(semi) {
        this->name->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DisableConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
    Token solve;
    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
    Token before;
    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
    Token semi;

    SolveBeforeConstraintSyntax(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi) {
        this->beforeExpr.parent = this;
        for (auto child : this->beforeExpr)
            child->parent = this;
        this->afterExpr.parent = this;
        for (auto child : this->afterExpr)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    SolveBeforeConstraintSyntax* clone(BumpAllocator& alloc) const;
};

struct ConstraintBlockSyntax : public ConstraintItemSyntax {
    Token openBrace;
    SyntaxList<ConstraintItemSyntax> items;
    Token closeBrace;

    ConstraintBlockSyntax(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace) :
        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConstraintBlockSyntax* clone(BumpAllocator& alloc) const;
};

struct ConstraintPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    Token semi;

    ConstraintPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(name), semi(semi) {
        this->qualifiers.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConstraintPrototypeSyntax* clone(BumpAllocator& alloc) const;
};

struct ConstraintDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    not_null<ConstraintBlockSyntax*> block;

    ConstraintDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) :
        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(name), block(&block) {
        this->qualifiers.parent = this;
        this->block->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConstraintDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct WithClauseSyntax : public ExpressionSyntax {
    Token with;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        ExpressionSyntax(SyntaxKind::WithClause), with(with), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WithClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct IdentifierListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token closeParen;

    IdentifierListSyntax(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen) :
        SyntaxNode(SyntaxKind::IdentifierList), openParen(openParen), identifiers(identifiers), closeParen(closeParen) {
        this->identifiers.parent = this;
        for (auto child : this->identifiers)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IdentifierListSyntax* clone(BumpAllocator& alloc) const;
};

struct RandomizeMethodWithClauseSyntax : public ExpressionSyntax {
    Token with;
    IdentifierListSyntax* names;
    not_null<ConstraintBlockSyntax*> constraints;

    RandomizeMethodWithClauseSyntax(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints) :
        ExpressionSyntax(SyntaxKind::RandomizeMethodWithClause), with(with), names(names), constraints(&constraints) {
        if (this->names) this->names->parent = this;
        this->constraints->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RandomizeMethodWithClauseSyntax* clone(BumpAllocator& alloc) const;
};

// ----- COVER GROUPS -----

struct WithFunctionSampleSyntax : public SyntaxNode {
    Token with;
    Token function;
    Token sample;
    not_null<AnsiPortListSyntax*> portList;

    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax& portList) :
        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(&portList) {
        this->portList->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    WithFunctionSampleSyntax* clone(BumpAllocator& alloc) const;
};

struct BlockEventExpressionSyntax : public SyntaxNode {

    BlockEventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    not_null<BlockEventExpressionSyntax*> left;
    Token orKeyword;
    not_null<BlockEventExpressionSyntax*> right;

    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(&left), orKeyword(orKeyword), right(&right) {
        this->left->parent = this;
        this->right->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BinaryBlockEventExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    Token keyword;
    not_null<NameSyntax*> name;

    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(&name) {
        this->name->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    PrimaryBlockEventExpressionSyntax* clone(BumpAllocator& alloc) const;
};

struct BlockCoverageEventSyntax : public SyntaxNode {
    Token atat;
    Token openParen;
    not_null<BlockEventExpressionSyntax*> expr;
    Token closeParen;

    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BlockCoverageEventSyntax* clone(BumpAllocator& alloc) const;
};

struct CovergroupDeclarationSyntax : public MemberSyntax {
    Token covergroup;
    Token name;
    AnsiPortListSyntax* portList;
    SyntaxNode* event;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endgroup;
    NamedBlockClauseSyntax* endBlockName;

    CovergroupDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName) {
        if (this->portList) this->portList->parent = this;
        if (this->event) this->event->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
        if (this->endBlockName) this->endBlockName->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CovergroupDeclarationSyntax* clone(BumpAllocator& alloc) const;
};

struct CoverageOptionSyntax : public MemberSyntax {
    Token option;
    Token dot;
    Token name;
    Token equals;
    not_null<ExpressionSyntax*> expr;
    Token semi;

    CoverageOptionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(&expr), semi(semi) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CoverageOptionSyntax* clone(BumpAllocator& alloc) const;
};

struct CoverpointSyntax : public MemberSyntax {
    DataTypeSyntax* type;
    NamedLabelSyntax* label;
    Token coverpoint;
    not_null<ExpressionSyntax*> expr;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverpointSyntax(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(&expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi) {
        if (this->type) this->type->parent = this;
        if (this->label) this->label->parent = this;
        this->expr->parent = this;
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CoverpointSyntax* clone(BumpAllocator& alloc) const;
};

struct CoverageBinInitializerSyntax : public SyntaxNode {

    CoverageBinInitializerSyntax(SyntaxKind kind) :
        SyntaxNode(kind) {
    }

    static bool isKind(SyntaxKind kind);
};

struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token defaultKeyword;
    Token sequenceKeyword;

    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DefaultCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
};

struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    not_null<ExpressionSyntax*> expr;
    WithClauseSyntax* withClause;

    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(&expr), withClause(withClause) {
        this->expr->parent = this;
        if (this->withClause) this->withClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ExpressionCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
};

struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    not_null<OpenRangeListSyntax*> ranges;
    WithClauseSyntax* withClause;

    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(&ranges), withClause(withClause) {
        this->ranges->parent = this;
        if (this->withClause) this->withClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    RangeCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
};

struct TransRepeatRangeSyntax : public SyntaxNode {
    Token openBracket;
    Token specifier;
    SelectorSyntax* selector;
    Token closeBracket;

    TransRepeatRangeSyntax(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) :
        SyntaxNode(SyntaxKind::TransRepeatRange), openBracket(openBracket), specifier(specifier), selector(selector), closeBracket(closeBracket) {
        if (this->selector) this->selector->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TransRepeatRangeSyntax* clone(BumpAllocator& alloc) const;
};

struct TransRangeSyntax : public SyntaxNode {
    SeparatedSyntaxList<ExpressionSyntax> items;
    TransRepeatRangeSyntax* repeat;

    TransRangeSyntax(SeparatedSyntaxList<ExpressionSyntax> items, TransRepeatRangeSyntax* repeat) :
        SyntaxNode(SyntaxKind::TransRange), items(items), repeat(repeat) {
        this->items.parent = this;
        for (auto child : this->items)
            child->parent = this;
        if (this->repeat) this->repeat->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TransRangeSyntax* clone(BumpAllocator& alloc) const;
};

struct TransSetSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<TransRangeSyntax> ranges;
    Token closeParen;

    TransSetSyntax(Token openParen, SeparatedSyntaxList<TransRangeSyntax> ranges, Token closeParen) :
        SyntaxNode(SyntaxKind::TransSet), openParen(openParen), ranges(ranges), closeParen(closeParen) {
        this->ranges.parent = this;
        for (auto child : this->ranges)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TransSetSyntax* clone(BumpAllocator& alloc) const;
};

struct TransListCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    SeparatedSyntaxList<TransSetSyntax> sets;
    WithClauseSyntax* withClause;

    TransListCoverageBinInitializerSyntax(SeparatedSyntaxList<TransSetSyntax> sets, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::TransListCoverageBinInitializer), sets(sets), withClause(withClause) {
        this->sets.parent = this;
        for (auto child : this->sets)
            child->parent = this;
        if (this->withClause) this->withClause->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TransListCoverageBinInitializerSyntax* clone(BumpAllocator& alloc) const;
};

struct IffClauseSyntax : public SyntaxNode {
    Token iff;
    Token openParen;
    not_null<ExpressionSyntax*> expr;
    Token closeParen;

    IffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), openParen(openParen), expr(&expr), closeParen(closeParen) {
        this->expr->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IffClauseSyntax* clone(BumpAllocator& alloc) const;
};

struct CoverageBinsSyntax : public MemberSyntax {
    Token wildcard;
    Token keyword;
    Token name;
    ElementSelectSyntax* selector;
    Token equals;
    not_null<CoverageBinInitializerSyntax*> initializer;
    IffClauseSyntax* iff;
    Token semi;

    CoverageBinsSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(&initializer), iff(iff), semi(semi) {
        if (this->selector) this->selector->parent = this;
        this->initializer->parent = this;
        if (this->iff) this->iff->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CoverageBinsSyntax* clone(BumpAllocator& alloc) const;
};

// ----- TOP LEVEL -----

struct CompilationUnitSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    CompilationUnitSyntax(SyntaxList<MemberSyntax> members, Token endOfFile) :
        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile) {
        this->members.parent = this;
        for (auto child : this->members)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    CompilationUnitSyntax* clone(BumpAllocator& alloc) const;
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token directive;

    DirectiveSyntax(SyntaxKind kind, Token directive) :
        SyntaxNode(kind), directive(directive) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct SimpleDirectiveSyntax : public DirectiveSyntax {

    SimpleDirectiveSyntax(SyntaxKind kind, Token directive) :
        DirectiveSyntax(kind, directive) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    SimpleDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token fileName;

    IncludeDirectiveSyntax(Token directive, Token fileName) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    IncludeDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token name;
    TokenList disabledTokens;

    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), name(name), disabledTokens(disabledTokens) {
        this->disabledTokens.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    ConditionalBranchDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
    TokenList disabledTokens;

    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), disabledTokens(disabledTokens) {
        this->disabledTokens.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    UnconditionalBranchDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens) {
        this->tokens.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MacroArgumentDefaultSyntax* clone(BumpAllocator& alloc) const;
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue) {
        if (this->defaultValue) this->defaultValue->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MacroFormalArgumentSyntax* clone(BumpAllocator& alloc) const;
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token closeParen;

    MacroFormalArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
        this->args.parent = this;
        for (auto child : this->args)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MacroFormalArgumentListSyntax* clone(BumpAllocator& alloc) const;
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;

    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body) {
        if (this->formalArguments) this->formalArguments->parent = this;
        this->body.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DefineDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct MacroActualArgumentSyntax : public SyntaxNode {
    TokenList tokens;

    MacroActualArgumentSyntax(TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens) {
        this->tokens.parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MacroActualArgumentSyntax* clone(BumpAllocator& alloc) const;
};

struct MacroActualArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
    Token closeParen;

    MacroActualArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen) {
        this->args.parent = this;
        for (auto child : this->args)
            child->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MacroActualArgumentListSyntax* clone(BumpAllocator& alloc) const;
};

struct MacroUsageSyntax : public DirectiveSyntax {
    MacroActualArgumentListSyntax* args;

    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args) {
        if (this->args) this->args->parent = this;
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    MacroUsageSyntax* clone(BumpAllocator& alloc) const;
};

struct TimescaleDirectiveSyntax : public DirectiveSyntax {
    Token timeUnit;
    Token timeUnitUnit;
    Token slash;
    Token timePrecision;
    Token timePrecisionUnit;

    TimescaleDirectiveSyntax(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit) :
        DirectiveSyntax(SyntaxKind::TimescaleDirective, directive), timeUnit(timeUnit), timeUnitUnit(timeUnitUnit), slash(slash), timePrecision(timePrecision), timePrecisionUnit(timePrecisionUnit) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    TimescaleDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
    Token netType;

    DefaultNetTypeDirectiveSyntax(Token directive, Token netType) :
        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    DefaultNetTypeDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct LineDirectiveSyntax : public DirectiveSyntax {
    Token lineNumber;
    Token fileName;
    Token level;

    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level) :
        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    LineDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct UndefDirectiveSyntax : public DirectiveSyntax {
    Token name;

    UndefDirectiveSyntax(Token directive, Token name) :
        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    UndefDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
    Token versionSpecifier;

    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier) :
        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier) {
    }

    static bool isKind(SyntaxKind kind);

    TokenOrSyntax getChild(uint32_t index);
    ConstTokenOrSyntax getChild(uint32_t index) const;
    void setChild(uint32_t index, TokenOrSyntax child);

    BeginKeywordsDirectiveSyntax* clone(BumpAllocator& alloc) const;
};

class SyntaxFactory {
public:
    explicit SyntaxFactory(BumpAllocator& alloc) : alloc(alloc) {}

    ActionBlockSyntax& actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause);
    AnsiPortListSyntax& ansiPortList(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen);
    ArgumentListSyntax& argumentList(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen);
    AssertionItemPortListSyntax& assertionItemPortList(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen);
    AssertionItemPortSyntax& assertionItemPort(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator);
    AssignmentPatternExpressionSyntax& assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern);
    AssignmentPatternItemSyntax& assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr);
    AttributeInstanceSyntax& attributeInstance(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen);
    AttributeSpecSyntax& attributeSpec(Token name, EqualsValueClauseSyntax* value);
    BadExpressionSyntax& badExpression(ExpressionSyntax& expr);
    BeginKeywordsDirectiveSyntax& beginKeywordsDirective(Token directive, Token versionSpecifier);
    BinaryBlockEventExpressionSyntax& binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right);
    BinaryEventExpressionSyntax& binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right);
    BinaryExpressionSyntax& binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right);
    BitSelectSyntax& bitSelect(ExpressionSyntax& expr);
    BlockCoverageEventSyntax& blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen);
    BlockStatementSyntax& blockStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName);
    CaseGenerateSyntax& caseGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase);
    CaseStatementSyntax& caseStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase);
    CastExpressionSyntax& castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right);
    ChargeStrengthSyntax& chargeStrength(Token openParen, Token strength, Token closeParen);
    ClassDeclarationSyntax& classDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName);
    ClassMethodDeclarationSyntax& classMethodDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration);
    ClassMethodPrototypeSyntax& classMethodPrototype(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype, Token semi);
    ClassNameSyntax& className(Token identifier, ParameterValueAssignmentSyntax& parameters);
    ClassPropertyDeclarationSyntax& classPropertyDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration);
    ClassScopeSyntax& classScope(NameSyntax& left, Token separator);
    ClockingDeclarationSyntax& clockingDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName);
    ClockingDirectionSyntax& clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout);
    ClockingItemSyntax& clockingItem(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration);
    ClockingSkewSyntax& clockingSkew(Token edge, Token hash, ExpressionSyntax* value);
    ColonExpressionClauseSyntax& colonExpressionClause(Token colon, ExpressionSyntax& expr);
    CompilationUnitSyntax& compilationUnit(SyntaxList<MemberSyntax> members, Token endOfFile);
    ConcatenationExpressionSyntax& concatenationExpression(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace);
    ConcurrentAssertionMemberSyntax& concurrentAssertionMember(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement);
    ConcurrentAssertionStatementSyntax& concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action);
    ConditionalBranchDirectiveSyntax& conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, TokenList disabledTokens);
    ConditionalConstraintSyntax& conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause);
    ConditionalExpressionSyntax& conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right);
    ConditionalPatternSyntax& conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause);
    ConditionalPredicateSyntax& conditionalPredicate(SeparatedSyntaxList<ConditionalPatternSyntax> conditions);
    ConditionalStatementSyntax& conditionalStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause);
    ConstraintBlockSyntax& constraintBlock(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace);
    ConstraintDeclarationSyntax& constraintDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block);
    ConstraintPrototypeSyntax& constraintPrototype(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi);
    ContinuousAssignSyntax& continuousAssign(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi);
    CoverageBinsSyntax& coverageBins(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi);
    CoverageOptionSyntax& coverageOption(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi);
    CovergroupDeclarationSyntax& covergroupDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName);
    CoverpointSyntax& coverpoint(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi);
    DPIImportExportSyntax& dPIImportExport(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method, Token semi);
    DataDeclarationSyntax& dataDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    DefParamAssignmentSyntax& defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax* setter);
    DefParamSyntax& defParam(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi);
    DefaultCaseItemSyntax& defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause);
    DefaultCoverageBinInitializerSyntax& defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword);
    DefaultNetTypeDirectiveSyntax& defaultNetTypeDirective(Token directive, Token netType);
    DeferredAssertionSyntax& deferredAssertion(Token hash, Token zero, Token finalKeyword);
    DefineDirectiveSyntax& defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body);
    DelaySyntax& delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue);
    DisableConstraintSyntax& disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi);
    DisableForkStatementSyntax& disableForkStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi);
    DisableIffSyntax& disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
    DisableStatementSyntax& disableStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi);
    DistConstraintListSyntax& distConstraintList(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace);
    DistItemSyntax& distItem(ExpressionSyntax& range, DistWeightSyntax* weight);
    DistWeightSyntax& distWeight(Token op, ExpressionSyntax& expr);
    DividerClauseSyntax& dividerClause(Token divide, Token value);
    DoWhileStatementSyntax& doWhileStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
    DotMemberClauseSyntax& dotMemberClause(Token dot, Token member);
    DriveStrengthSyntax& driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen);
    ElementSelectExpressionSyntax& elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select);
    ElementSelectSyntax& elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket);
    ElseClauseSyntax& elseClause(Token elseKeyword, SyntaxNode& clause);
    ElseConstraintClauseSyntax& elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints);
    EmptyArgumentSyntax& emptyArgument();
    EmptyIdentifierNameSyntax& emptyIdentifierName();
    EmptyMemberSyntax& emptyMember(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi);
    EmptyQueueExpressionSyntax& emptyQueueExpression(Token openBrace, Token closeBrace);
    EmptyStatementSyntax& emptyStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon);
    EnumTypeSyntax& enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions);
    EqualsValueClauseSyntax& equalsValueClause(Token equals, ExpressionSyntax& expr);
    EventControlSyntax& eventControl(Token at, NameSyntax& eventName);
    EventControlWithExpressionSyntax& eventControlWithExpression(Token at, EventExpressionSyntax& expr);
    EventTriggerStatementSyntax& eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name);
    ExplicitAnsiPortSyntax& explicitAnsiPort(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ExplicitNonAnsiPortSyntax& explicitNonAnsiPort(Token dot, Token name, Token openParen, PortExpressionSyntax* expr, Token closeParen);
    ExpressionConstraintSyntax& expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi);
    ExpressionCoverageBinInitializerSyntax& expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause);
    ExpressionOrDistSyntax& expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution);
    ExpressionPatternSyntax& expressionPattern(ExpressionSyntax& expr);
    ExpressionStatementSyntax& expressionStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi);
    ExtendsClauseSyntax& extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments);
    ExternModuleSyntax& externModule(Token externKeyword, ModuleHeaderSyntax& header);
    ForLoopStatementSyntax& forLoopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement);
    ForVariableDeclarationSyntax& forVariableDeclaration(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator);
    ForeachLoopListSyntax& foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen);
    ForeachLoopStatementSyntax& foreachLoopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement);
    ForeverStatementSyntax& foreverStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement);
    ForwardInterfaceClassTypedefDeclarationSyntax& forwardInterfaceClassTypedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi);
    ForwardTypedefDeclarationSyntax& forwardTypedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi);
    FunctionDeclarationSyntax& functionDeclaration(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, Token semi, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName);
    FunctionPortListSyntax& functionPortList(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen);
    FunctionPortSyntax& functionPort(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator);
    FunctionPrototypeSyntax& functionPrototype(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList);
    GenerateBlockSyntax& generateBlock(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName);
    GenerateRegionSyntax& generateRegion(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate);
    GenvarDeclarationSyntax& genvarDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi);
    HierarchicalInstanceSyntax& hierarchicalInstance(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen);
    HierarchyInstantiationSyntax& hierarchyInstantiation(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi);
    IdentifierListSyntax& identifierList(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen);
    IdentifierNameSyntax& identifierName(Token identifier);
    IdentifierSelectNameSyntax& identifierSelectName(Token identifier, SyntaxList<ElementSelectSyntax> selectors);
    IfGenerateSyntax& ifGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause);
    IffClauseSyntax& iffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
    ImmediateAssertionMemberSyntax& immediateAssertionMember(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement);
    ImmediateAssertionStatementSyntax& immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action);
    ImplementsClauseSyntax& implementsClause(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces);
    ImplicationConstraintSyntax& implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints);
    ImplicitAnsiPortSyntax& implicitAnsiPort(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator);
    ImplicitEventControlSyntax& implicitEventControl(Token atStar);
    ImplicitNonAnsiPortSyntax& implicitNonAnsiPort(PortExpressionSyntax* expr);
    ImplicitTypeSyntax& implicitType(Token signing, SyntaxList<VariableDimensionSyntax> dimensions);
    IncludeDirectiveSyntax& includeDirective(Token directive, Token fileName);
    InsideExpressionSyntax& insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges);
    IntegerTypeSyntax& integerType(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions);
    IntegerVectorExpressionSyntax& integerVectorExpression(Token size, Token base, Token value);
    InterconnectPortHeaderSyntax& interconnectPortHeader(Token direction, Token interconnect, DataTypeSyntax* type);
    InterfacePortHeaderSyntax& interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport);
    InvocationExpressionSyntax& invocationExpression(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments);
    JumpStatementSyntax& jumpStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi);
    KeywordNameSyntax& keywordName(SyntaxKind kind, Token keyword);
    KeywordTypeSyntax& keywordType(SyntaxKind kind, Token keyword);
    LetDeclarationSyntax& letDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi);
    LineDirectiveSyntax& lineDirective(Token directive, Token lineNumber, Token fileName, Token level);
    LiteralExpressionSyntax& literalExpression(SyntaxKind kind, Token literal);
    LoopConstraintSyntax& loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints);
    LoopGenerateSyntax& loopGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block);
    LoopStatementSyntax& loopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
    MacroActualArgumentListSyntax& macroActualArgumentList(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen);
    MacroActualArgumentSyntax& macroActualArgument(TokenList tokens);
    MacroArgumentDefaultSyntax& macroArgumentDefault(Token equals, TokenList tokens);
    MacroFormalArgumentListSyntax& macroFormalArgumentList(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen);
    MacroFormalArgumentSyntax& macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue);
    MacroUsageSyntax& macroUsage(Token directive, MacroActualArgumentListSyntax* args);
    MatchesClauseSyntax& matchesClause(Token matchesKeyword, PatternSyntax& pattern);
    MemberAccessExpressionSyntax& memberAccessExpression(ExpressionSyntax& left, Token dot, Token name);
    MinTypMaxExpressionSyntax& minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max);
    ModportClockingPortSyntax& modportClockingPort(SyntaxList<AttributeInstanceSyntax> attributes, Token clocking, Token name);
    ModportDeclarationSyntax& modportDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi);
    ModportExplicitPortSyntax& modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ModportItemSyntax& modportItem(Token name, AnsiPortListSyntax& ports);
    ModportNamedPortSyntax& modportNamedPort(Token name);
    ModportSimplePortListSyntax& modportSimplePortList(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, SeparatedSyntaxList<ModportPortSyntax> ports);
    ModportSubroutinePortListSyntax& modportSubroutinePortList(SyntaxList<AttributeInstanceSyntax> attributes, Token importExport, SeparatedSyntaxList<ModportPortSyntax> ports);
    ModportSubroutinePortSyntax& modportSubroutinePort(FunctionPrototypeSyntax& prototype);
    ModuleDeclarationSyntax& moduleDeclaration(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName);
    ModuleHeaderSyntax& moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi);
    MultipleConcatenationExpressionSyntax& multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace);
    NamedArgumentSyntax& namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    NamedBlockClauseSyntax& namedBlockClause(Token colon, Token name);
    NamedLabelSyntax& namedLabel(Token name, Token colon);
    NamedPortConnectionSyntax& namedPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    NamedStructurePatternMemberSyntax& namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern);
    NamedTypeSyntax& namedType(NameSyntax& name);
    NetDeclarationSyntax& netDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    NetPortHeaderSyntax& netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType);
    NewArrayExpressionSyntax& newArrayExpression(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer);
    NewClassExpressionSyntax& newClassExpression(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments);
    NewExpressionSyntax& newExpression(Token newKeyword, ExpressionSyntax& expr);
    NonAnsiPortListSyntax& nonAnsiPortList(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen);
    OpenRangeListSyntax& openRangeList(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace);
    OrderedArgumentSyntax& orderedArgument(ExpressionSyntax& expr);
    OrderedPortConnectionSyntax& orderedPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr);
    OrderedStructurePatternMemberSyntax& orderedStructurePatternMember(PatternSyntax& pattern);
    PackageImportDeclarationSyntax& packageImportDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi);
    PackageImportItemSyntax& packageImportItem(Token package, Token doubleColon, Token item);
    ParameterDeclarationStatementSyntax& parameterDeclarationStatement(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi);
    ParameterDeclarationSyntax& parameterDeclaration(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators);
    ParameterPortListSyntax& parameterPortList(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen);
    ParameterValueAssignmentSyntax& parameterValueAssignment(Token hash, ArgumentListSyntax& parameters);
    ParenImplicitEventControlSyntax& parenImplicitEventControl(Token at, Token openParenStarCloseParen);
    ParenthesizedEventExpressionSyntax& parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen);
    ParenthesizedExpressionSyntax& parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen);
    PatternCaseItemSyntax& patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement);
    PortConcatenationSyntax& portConcatenation(Token openBrace, SeparatedSyntaxList<PortReferenceSyntax> references, Token closeBrace);
    PortDeclarationSyntax& portDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    PortReferenceSyntax& portReference(Token name, ElementSelectSyntax* select);
    PostfixUnaryExpressionSyntax& postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken);
    PrefixUnaryExpressionSyntax& prefixUnaryExpression(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand);
    PrimaryBlockEventExpressionSyntax& primaryBlockEventExpression(Token keyword, NameSyntax& name);
    ProceduralAssignStatementSyntax& proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi);
    ProceduralBlockSyntax& proceduralBlock(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement);
    ProceduralDeassignStatementSyntax& proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi);
    PropertyDeclarationSyntax& propertyDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
    PropertySpecSyntax& propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr);
    QueueDimensionSpecifierSyntax& queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause);
    RandCaseItemSyntax& randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement);
    RandCaseStatementSyntax& randCaseStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase);
    RandomizeMethodWithClauseSyntax& randomizeMethodWithClause(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints);
    RangeCoverageBinInitializerSyntax& rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause);
    RangeDimensionSpecifierSyntax& rangeDimensionSpecifier(SelectorSyntax& selector);
    RangeSelectSyntax& rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right);
    RepeatedEventControlSyntax& repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl);
    ReplicatedAssignmentPatternSyntax& replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace);
    ReturnStatementSyntax& returnStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi);
    ScopedNameSyntax& scopedName(NameSyntax& left, Token separator, NameSyntax& right);
    SequenceDeclarationSyntax& sequenceDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
    ShortcutCycleDelayRangeSyntax& shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket);
    SignalEventExpressionSyntax& signalEventExpression(Token edge, ExpressionSyntax& expr);
    SignedCastExpressionSyntax& signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner);
    SimpleAssignmentPatternSyntax& simpleAssignmentPattern(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace);
    SimpleDirectiveSyntax& simpleDirective(SyntaxKind kind, Token directive);
    SolveBeforeConstraintSyntax& solveBeforeConstraint(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi);
    StandardCaseItemSyntax& standardCaseItem(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause);
    StreamExpressionSyntax& streamExpression(ExpressionSyntax& expression, StreamExpressionWithRange* withRange);
    StreamExpressionWithRange& streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range);
    StreamingConcatenationExpressionSyntax& streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace);
    StructUnionMemberSyntax& structUnionMember(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    StructUnionTypeSyntax& structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions);
    StructurePatternSyntax& structurePattern(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace);
    StructuredAssignmentPatternSyntax& structuredAssignmentPattern(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace);
    TaggedPatternSyntax& taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern);
    TaggedUnionExpressionSyntax& taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr);
    TimeUnitsDeclarationSyntax& timeUnitsDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi);
    TimescaleDirectiveSyntax& timescaleDirective(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit);
    TimingControlExpressionConcatenationSyntax& timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right);
    TimingControlExpressionSyntax& timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr);
    TimingControlStatementSyntax& timingControlStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement);
    TransListCoverageBinInitializerSyntax& transListCoverageBinInitializer(SeparatedSyntaxList<TransSetSyntax> sets, WithClauseSyntax* withClause);
    TransRangeSyntax& transRange(SeparatedSyntaxList<ExpressionSyntax> items, TransRepeatRangeSyntax* repeat);
    TransRepeatRangeSyntax& transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket);
    TransSetSyntax& transSet(Token openParen, SeparatedSyntaxList<TransRangeSyntax> ranges, Token closeParen);
    TypeReferenceSyntax& typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen);
    TypedefDeclarationSyntax& typedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi);
    UnconditionalBranchDirectiveSyntax& unconditionalBranchDirective(SyntaxKind kind, Token directive, TokenList disabledTokens);
    UndefDirectiveSyntax& undefDirective(Token directive, Token name);
    UniquenessConstraintSyntax& uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi);
    VarDataTypeSyntax& varDataType(Token var, DataTypeSyntax& type);
    VariableDeclaratorSyntax& variableDeclarator(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer);
    VariableDimensionSyntax& variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket);
    VariablePatternSyntax& variablePattern(Token dot, Token variableName);
    VariablePortHeaderSyntax& variablePortHeader(Token direction, Token varKeyword, DataTypeSyntax& dataType);
    VirtualInterfaceTypeSyntax& virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport);
    WaitForkStatementSyntax& waitForkStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi);
    WaitOrderStatementSyntax& waitOrderStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action);
    WaitStatementSyntax& waitStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
    WildcardDimensionSpecifierSyntax& wildcardDimensionSpecifier(Token star);
    WildcardPatternSyntax& wildcardPattern(Token dotStar);
    WildcardPortConnectionSyntax& wildcardPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar);
    WildcardPortListSyntax& wildcardPortList(Token openParen, Token dotStar, Token closeParen);
    WithClauseSyntax& withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen);
    WithFunctionSampleSyntax& withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList);

private:
    BumpAllocator& alloc;
};

namespace detail {

template<typename TNode, typename TVisitor, typename... Args>
decltype(auto) visitSyntaxNode(TNode* node, TVisitor& visitor, Args&&... args) {
    static constexpr bool isConst = std::is_const_v<TNode>;    switch (node->kind) {
        case SyntaxKind::Unknown: return visitor.visitInvalid(*node, std::forward<Args>(args)...);
        case SyntaxKind::SyntaxList:
        case SyntaxKind::TokenList:
        case SyntaxKind::SeparatedList:
            return visitor.visit(*static_cast<std::conditional_t<isConst, const SyntaxListBase*, SyntaxListBase*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ActionBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ActionBlockSyntax*, ActionBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AddAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AddExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysCombBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysFFBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysLatchBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiPortListSyntax*, AnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArgumentListSyntax*, ArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayAndMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayOrMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayUniqueMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayXorMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AscendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertionItemPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortSyntax*, AssertionItemPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertionItemPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortListSyntax*, AssertionItemPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentPatternExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternExpressionSyntax*, AssignmentPatternExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentPatternItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternItemSyntax*, AssignmentPatternItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssumePropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AttributeInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeInstanceSyntax*, AttributeInstanceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AttributeSpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeSpecSyntax*, AttributeSpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BadExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BadExpressionSyntax*, BadExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BeginKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BeginKeywordsDirectiveSyntax*, BeginKeywordsDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryBlockEventExpressionSyntax*, BinaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryEventExpressionSyntax*, BinaryEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BitSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const BitSelectSyntax*, BitSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BlockCoverageEvent: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockCoverageEventSyntax*, BlockCoverageEventSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BlockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ByteType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CHandleType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseGenerateSyntax*, CaseGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseStatementSyntax*, CaseStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CastExpressionSyntax*, CastExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ChargeStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const ChargeStrengthSyntax*, ChargeStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassDeclarationSyntax*, ClassDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassMethodDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodDeclarationSyntax*, ClassMethodDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassMethodPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodPrototypeSyntax*, ClassMethodPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassNameSyntax*, ClassNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassPropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassPropertyDeclarationSyntax*, ClassPropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassScopeSyntax*, ClassScopeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDeclarationSyntax*, ClockingDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingDirection: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDirectionSyntax*, ClockingDirectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingItemSyntax*, ClockingItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingSkew: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingSkewSyntax*, ClockingSkewSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ColonExpressionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ColonExpressionClauseSyntax*, ColonExpressionClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CompilationUnit: return visitor.visit(*static_cast<std::conditional_t<isConst, const CompilationUnitSyntax*, CompilationUnitSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcatenationExpressionSyntax*, ConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConcurrentAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionMemberSyntax*, ConcurrentAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalConstraintSyntax*, ConditionalConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalExpressionSyntax*, ConditionalExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPatternSyntax*, ConditionalPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPredicate: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPredicateSyntax*, ConditionalPredicateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalStatementSyntax*, ConditionalStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintBlockSyntax*, ConstraintBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintDeclarationSyntax*, ConstraintDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintPrototypeSyntax*, ConstraintPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstructorName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ContinuousAssign: return visitor.visit(*static_cast<std::conditional_t<isConst, const ContinuousAssignSyntax*, ContinuousAssignSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverSequenceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageBins: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageBinsSyntax*, CoverageBinsSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageOption: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageOptionSyntax*, CoverageOptionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CovergroupDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CovergroupDeclarationSyntax*, CovergroupDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Coverpoint: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverpointSyntax*, CoverpointSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CycleDelay: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DPIImportExport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIImportExportSyntax*, DPIImportExportSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DataDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const DataDeclarationSyntax*, DataDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefParam: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamSyntax*, DefParamSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamAssignmentSyntax*, DefParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCaseItemSyntax*, DefaultCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCoverageBinInitializerSyntax*, DefaultCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultNetTypeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultNetTypeDirectiveSyntax*, DefaultNetTypeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultPatternKeyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DeferredAssertion: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeferredAssertionSyntax*, DeferredAssertionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefineDirectiveSyntax*, DefineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DescendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableConstraintSyntax*, DisableConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableForkStatementSyntax*, DisableForkStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableIff: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableIffSyntax*, DisableIffSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableStatementSyntax*, DisableStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistConstraintList: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistConstraintListSyntax*, DistConstraintListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistItemSyntax*, DistItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistWeight: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistWeightSyntax*, DistWeightSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DivideAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DivideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DividerClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DividerClauseSyntax*, DividerClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DoWhileStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DoWhileStatementSyntax*, DoWhileStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DotMemberClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DotMemberClauseSyntax*, DotMemberClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DriveStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const DriveStrengthSyntax*, DriveStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElementSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectSyntax*, ElementSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElementSelectExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectExpressionSyntax*, ElementSelectExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElsIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseClauseSyntax*, ElseClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseConstraintClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseConstraintClauseSyntax*, ElseConstraintClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyArgumentSyntax*, EmptyArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyIdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyIdentifierNameSyntax*, EmptyIdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyMemberSyntax*, EmptyMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyQueueExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyQueueExpressionSyntax*, EmptyQueueExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyStatementSyntax*, EmptyStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndCellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EnumType: return visitor.visit(*static_cast<std::conditional_t<isConst, const EnumTypeSyntax*, EnumTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualsValueClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsValueClauseSyntax*, EqualsValueClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlSyntax*, EventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventControlWithExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlWithExpressionSyntax*, EventControlWithExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpectPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitAnsiPortSyntax*, ExplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitNonAnsiPortSyntax*, ExplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionConstraintSyntax*, ExpressionConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionCoverageBinInitializerSyntax*, ExpressionCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionOrDist: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionOrDistSyntax*, ExpressionOrDistSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionPatternSyntax*, ExpressionPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionStatementSyntax*, ExpressionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExtendsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExtendsClauseSyntax*, ExtendsClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExternModule: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternModuleSyntax*, ExternModuleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FinalBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForLoopStatementSyntax*, ForLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForVariableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForVariableDeclarationSyntax*, ForVariableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeachLoopList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopListSyntax*, ForeachLoopListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeachLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopStatementSyntax*, ForeachLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeverStatementSyntax*, ForeverStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardInterfaceClassTypedefDeclarationSyntax*, ForwardInterfaceClassTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForwardTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardTypedefDeclarationSyntax*, ForwardTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortSyntax*, FunctionPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortListSyntax*, FunctionPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPrototypeSyntax*, FunctionPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenerateBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateBlockSyntax*, GenerateBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenerateRegion: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateRegionSyntax*, GenerateRegionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenvarDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenvarDeclarationSyntax*, GenvarDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GreaterThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GreaterThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::HierarchicalInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchicalInstanceSyntax*, HierarchicalInstanceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::HierarchyInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchyInstantiationSyntax*, HierarchyInstantiationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierList: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierListSyntax*, IdentifierListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierNameSyntax*, IdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierSelectName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierSelectNameSyntax*, IdentifierSelectNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfGenerateSyntax*, IfGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfNDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IffClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const IffClauseSyntax*, IffClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IffPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssertStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionMemberSyntax*, ImmediateAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssumeStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateCoverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplementsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplementsClauseSyntax*, ImplementsClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicationConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicationConstraintSyntax*, ImplicationConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitAnsiPortSyntax*, ImplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitEventControlSyntax*, ImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitNonAnsiPortSyntax*, ImplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitTypeSyntax*, ImplicitTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImpliesPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IncludeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const IncludeDirectiveSyntax*, IncludeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InitialBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InsideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InsideExpressionSyntax*, InsideExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerVectorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerVectorExpressionSyntax*, IntegerVectorExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterconnectPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterconnectPortHeaderSyntax*, InterconnectPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfaceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfaceHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfacePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterfacePortHeaderSyntax*, InterfacePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntersectSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InvocationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InvocationExpressionSyntax*, InvocationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::JumpStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const JumpStatementSyntax*, JumpStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LessThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LessThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LetDeclarationSyntax*, LetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const LineDirectiveSyntax*, LineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LocalScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalEquivalenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalImplicationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LongIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopConstraintSyntax*, LoopConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopGenerateSyntax*, LoopGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopStatementSyntax*, LoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroActualArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentSyntax*, MacroActualArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroActualArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentListSyntax*, MacroActualArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroArgumentDefault: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroArgumentDefaultSyntax*, MacroArgumentDefaultSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroFormalArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentSyntax*, MacroFormalArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroFormalArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentListSyntax*, MacroFormalArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroUsage: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroUsageSyntax*, MacroUsageSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MatchesClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const MatchesClauseSyntax*, MatchesClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MemberAccessExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MemberAccessExpressionSyntax*, MemberAccessExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MinTypMaxExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MinTypMaxExpressionSyntax*, MinTypMaxExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportClockingPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportClockingPortSyntax*, ModportClockingPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportDeclarationSyntax*, ModportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportExplicitPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportExplicitPortSyntax*, ModportExplicitPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportItemSyntax*, ModportItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportNamedPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportNamedPortSyntax*, ModportNamedPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSimplePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSimplePortListSyntax*, ModportSimplePortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSubroutinePort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortSyntax*, ModportSubroutinePortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSubroutinePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortListSyntax*, ModportSubroutinePortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModuleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModuleHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultipleConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MultipleConcatenationExpressionSyntax*, MultipleConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultiplyAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultiplyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedArgumentSyntax*, NamedArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedBlockClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedBlockClauseSyntax*, NamedBlockClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedLabel: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedLabelSyntax*, NamedLabelSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedPortConnectionSyntax*, NamedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedStructurePatternMemberSyntax*, NamedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedType: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedTypeSyntax*, NamedTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetDeclarationSyntax*, NetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetPortHeaderSyntax*, NetPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewArrayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewArrayExpressionSyntax*, NewArrayExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewClassExpressionSyntax*, NewClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewExpressionSyntax*, NewExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NoUnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonAnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiPortListSyntax*, NonAnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonblockingAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonblockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NullLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OneStepLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OpenRangeList: return visitor.visit(*static_cast<std::conditional_t<isConst, const OpenRangeListSyntax*, OpenRangeListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedArgumentSyntax*, OrderedArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedPortConnectionSyntax*, OrderedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedStructurePatternMemberSyntax*, OrderedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageImportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportDeclarationSyntax*, PackageImportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageImportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportItemSyntax*, PackageImportItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParallelBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationSyntax*, ParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterDeclarationStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationStatementSyntax*, ParameterDeclarationStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterPortListSyntax*, ParameterPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterValueAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterValueAssignmentSyntax*, ParameterValueAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenImplicitEventControlSyntax*, ParenImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedEventExpressionSyntax*, ParenthesizedEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedExpressionSyntax*, ParenthesizedExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PatternCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PatternCaseItemSyntax*, PatternCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortConcatenationSyntax*, PortConcatenationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortDeclarationSyntax*, PortDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortReferenceSyntax*, PortReferenceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PostdecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PostincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PowerExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PragmaDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PrimaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrimaryBlockEventExpressionSyntax*, PrimaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralAssignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralDeassignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralForceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralReleaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProgramDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProgramHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertyDeclarationSyntax*, PropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertySpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertySpecSyntax*, PropertySpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertyType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::QueueDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const QueueDimensionSpecifierSyntax*, QueueDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseItemSyntax*, RandCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandCaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseStatementSyntax*, RandCaseStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandomizeMethodWithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandomizeMethodWithClauseSyntax*, RandomizeMethodWithClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeCoverageBinInitializerSyntax*, RangeCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeDimensionSpecifierSyntax*, RangeDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealTimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RegType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RepeatedEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const RepeatedEventControlSyntax*, RepeatedEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ReplicatedAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReplicatedAssignmentPatternSyntax*, ReplicatedAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ResetAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RestrictPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ReturnStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReturnStatementSyntax*, ReturnStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RootScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SAlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SEventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SNextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SUntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SUntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ScopedName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ScopedNameSyntax*, ScopedNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceDeclarationSyntax*, SequenceDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequentialBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortRealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortcutCycleDelayRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const ShortcutCycleDelayRangeSyntax*, ShortcutCycleDelayRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SignalEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignalEventExpressionSyntax*, SignalEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SignedCastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignedCastExpressionSyntax*, SignedCastExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleAssignmentPatternSyntax*, SimpleAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SolveBeforeConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const SolveBeforeConstraintSyntax*, SolveBeforeConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StandardCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardCaseItemSyntax*, StandardCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionSyntax*, StreamExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamExpressionWithRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionWithRange*, StreamExpressionWithRange*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamingConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamingConcatenationExpressionSyntax*, StreamingConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StringLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StringType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructUnionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionMemberSyntax*, StructUnionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructurePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructurePatternSyntax*, StructurePatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructuredAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructuredAssignmentPatternSyntax*, StructuredAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SubtractAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SubtractExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SuperHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SyncAcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SyncRejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SystemName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaggedPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedPatternSyntax*, TaggedPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaggedUnionExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedUnionExpressionSyntax*, TaggedUnionExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaskDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ThisHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ThroughoutSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeUnitsDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeUnitsDeclarationSyntax*, TimeUnitsDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimescaleDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimescaleDirectiveSyntax*, TimescaleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionSyntax*, TimingControlExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlExpressionConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionConcatenationSyntax*, TimingControlExpressionConcatenationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlStatementSyntax*, TimingControlStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransListCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransListCoverageBinInitializerSyntax*, TransListCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRangeSyntax*, TransRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransRepeatRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRepeatRangeSyntax*, TransRepeatRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransSet: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransSetSyntax*, TransSetSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeReferenceSyntax*, TypeReferenceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypedefDeclarationSyntax*, TypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNandExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryLogicalNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryMinusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryNotPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPlusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPredecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPreincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnarySequenceEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnbasedUnsizedLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UndefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UndefDirectiveSyntax*, UndefDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UndefineAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnionType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UniquenessConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const UniquenessConstraintSyntax*, UniquenessConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnitScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Untyped: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VarDataType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VarDataTypeSyntax*, VarDataTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariableDeclarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDeclaratorSyntax*, VariableDeclaratorSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariableDimension: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDimensionSyntax*, VariableDimensionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariablePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePatternSyntax*, VariablePatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariablePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePortHeaderSyntax*, VariablePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VirtualInterfaceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VirtualInterfaceTypeSyntax*, VirtualInterfaceTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VoidType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitForkStatementSyntax*, WaitForkStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitOrderStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitOrderStatementSyntax*, WaitOrderStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitStatementSyntax*, WaitStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardDimensionSpecifierSyntax*, WildcardDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPatternSyntax*, WildcardPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortConnectionSyntax*, WildcardPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortListSyntax*, WildcardPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithClauseSyntax*, WithClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithFunctionSample: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionSampleSyntax*, WithFunctionSampleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithinSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::XorAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
    }
    THROW_UNREACHABLE;
}

}

template<typename TVisitor, typename... Args>
decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) {
    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
}

template<typename TVisitor, typename... Args>
decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) const {
    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);
}

}
