//------------------------------------------------------------------------------
// AllSyntax.h
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include "lexing/Token.h"
#include "util/BumpAllocator.h"
#include "SyntaxNode.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the scripts/ directory.

namespace slang {

struct ExpressionSyntax : public SyntaxNode {

    ExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct DataTypeSyntax : public ExpressionSyntax {

    DataTypeSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

// ----- ATTRIBUTES -----

struct EqualsValueClauseSyntax : public SyntaxNode {
    Token equals;
    ExpressionSyntax& expr;

    EqualsValueClauseSyntax(Token equals, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::EqualsValueClause), equals(equals), expr(expr)
    {}

    EqualsValueClauseSyntax(const EqualsValueClauseSyntax&) = delete;
    EqualsValueClauseSyntax& operator=(const EqualsValueClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return equals;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct AttributeSpecSyntax : public SyntaxNode {
    Token name;
    EqualsValueClauseSyntax* value;

    AttributeSpecSyntax(Token name, EqualsValueClauseSyntax* value) :
        SyntaxNode(SyntaxKind::AttributeSpec), name(name), value(value)
    {}

    AttributeSpecSyntax(const AttributeSpecSyntax&) = delete;
    AttributeSpecSyntax& operator=(const AttributeSpecSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return value;
            default: return nullptr;
        }
    }
};

struct AttributeInstanceSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AttributeSpecSyntax> specs;
    Token closeParen;

    AttributeInstanceSyntax(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen) :
        SyntaxNode(SyntaxKind::AttributeInstance), openParen(openParen), specs(specs), closeParen(closeParen)
    {}

    AttributeInstanceSyntax(const AttributeInstanceSyntax&) = delete;
    AttributeInstanceSyntax& operator=(const AttributeInstanceSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &specs;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct NamedLabelSyntax : public SyntaxNode {
    Token name;
    Token colon;

    NamedLabelSyntax(Token name, Token colon) :
        SyntaxNode(SyntaxKind::NamedLabel), name(name), colon(colon)
    {}

    NamedLabelSyntax(const NamedLabelSyntax&) = delete;
    NamedLabelSyntax& operator=(const NamedLabelSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            default: return nullptr;
        }
    }
};

struct StatementSyntax : public SyntaxNode {
    NamedLabelSyntax* label;
    SyntaxList<AttributeInstanceSyntax> attributes;

    StatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), label(label), attributes(attributes)
    {}

    StatementSyntax(const StatementSyntax&) = delete;
    StatementSyntax& operator=(const StatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            default: return nullptr;
        }
    }
};

struct MemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    MemberSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {}

    MemberSyntax(const MemberSyntax&) = delete;
    MemberSyntax& operator=(const MemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

// ----- ARGUMENTS -----

struct ArgumentSyntax : public SyntaxNode {

    ArgumentSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct EmptyArgumentSyntax : public ArgumentSyntax {

    EmptyArgumentSyntax() :
        ArgumentSyntax(SyntaxKind::EmptyArgument)
    {}

    EmptyArgumentSyntax(const EmptyArgumentSyntax&) = delete;
    EmptyArgumentSyntax& operator=(const EmptyArgumentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        (void)index;
        return nullptr;
    }
};

struct OrderedArgumentSyntax : public ArgumentSyntax {
    ExpressionSyntax& expr;

    OrderedArgumentSyntax(ExpressionSyntax& expr) :
        ArgumentSyntax(SyntaxKind::OrderedArgument), expr(expr)
    {}

    OrderedArgumentSyntax(const OrderedArgumentSyntax&) = delete;
    OrderedArgumentSyntax& operator=(const OrderedArgumentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct NamedArgumentSyntax : public ArgumentSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedArgumentSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ArgumentSyntax(SyntaxKind::NamedArgument), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    NamedArgumentSyntax(const NamedArgumentSyntax&) = delete;
    NamedArgumentSyntax& operator=(const NamedArgumentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct ArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<ArgumentSyntax> parameters;
    Token closeParen;

    ArgumentListSyntax(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen) :
        SyntaxNode(SyntaxKind::ArgumentList), openParen(openParen), parameters(parameters), closeParen(closeParen)
    {}

    ArgumentListSyntax(const ArgumentListSyntax&) = delete;
    ArgumentListSyntax& operator=(const ArgumentListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &parameters;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterValueAssignmentSyntax : public SyntaxNode {
    Token hash;
    ArgumentListSyntax& parameters;

    ParameterValueAssignmentSyntax(Token hash, ArgumentListSyntax& parameters) :
        SyntaxNode(SyntaxKind::ParameterValueAssignment), hash(hash), parameters(parameters)
    {}

    ParameterValueAssignmentSyntax(const ParameterValueAssignmentSyntax&) = delete;
    ParameterValueAssignmentSyntax& operator=(const ParameterValueAssignmentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return &parameters;
            default: return nullptr;
        }
    }
};

// ----- PATTERNS -----

struct PatternSyntax : public SyntaxNode {

    PatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct VariablePatternSyntax : public PatternSyntax {
    Token dot;
    Token variableName;

    VariablePatternSyntax(Token dot, Token variableName) :
        PatternSyntax(SyntaxKind::VariablePattern), dot(dot), variableName(variableName)
    {}

    VariablePatternSyntax(const VariablePatternSyntax&) = delete;
    VariablePatternSyntax& operator=(const VariablePatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return variableName;
            default: return nullptr;
        }
    }
};

struct WildcardPatternSyntax : public PatternSyntax {
    Token dotStar;

    WildcardPatternSyntax(Token dotStar) :
        PatternSyntax(SyntaxKind::WildcardPattern), dotStar(dotStar)
    {}

    WildcardPatternSyntax(const WildcardPatternSyntax&) = delete;
    WildcardPatternSyntax& operator=(const WildcardPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dotStar;
            default: return nullptr;
        }
    }
};

struct ExpressionPatternSyntax : public PatternSyntax {
    ExpressionSyntax& expr;

    ExpressionPatternSyntax(ExpressionSyntax& expr) :
        PatternSyntax(SyntaxKind::ExpressionPattern), expr(expr)
    {}

    ExpressionPatternSyntax(const ExpressionPatternSyntax&) = delete;
    ExpressionPatternSyntax& operator=(const ExpressionPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct TaggedPatternSyntax : public PatternSyntax {
    Token tagged;
    Token memberName;
    PatternSyntax* pattern;

    TaggedPatternSyntax(Token tagged, Token memberName, PatternSyntax* pattern) :
        PatternSyntax(SyntaxKind::TaggedPattern), tagged(tagged), memberName(memberName), pattern(pattern)
    {}

    TaggedPatternSyntax(const TaggedPatternSyntax&) = delete;
    TaggedPatternSyntax& operator=(const TaggedPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return tagged;
            case 1: return memberName;
            case 2: return pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternMemberSyntax : public SyntaxNode {

    StructurePatternMemberSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct OrderedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    PatternSyntax& pattern;

    OrderedStructurePatternMemberSyntax(PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::OrderedStructurePatternMember), pattern(pattern)
    {}

    OrderedStructurePatternMemberSyntax(const OrderedStructurePatternMemberSyntax&) = delete;
    OrderedStructurePatternMemberSyntax& operator=(const OrderedStructurePatternMemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &pattern;
            default: return nullptr;
        }
    }
};

struct NamedStructurePatternMemberSyntax : public StructurePatternMemberSyntax {
    Token name;
    Token colon;
    PatternSyntax& pattern;

    NamedStructurePatternMemberSyntax(Token name, Token colon, PatternSyntax& pattern) :
        StructurePatternMemberSyntax(SyntaxKind::NamedStructurePatternMember), name(name), colon(colon), pattern(pattern)
    {}

    NamedStructurePatternMemberSyntax(const NamedStructurePatternMemberSyntax&) = delete;
    NamedStructurePatternMemberSyntax& operator=(const NamedStructurePatternMemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return colon;
            case 2: return &pattern;
            default: return nullptr;
        }
    }
};

struct StructurePatternSyntax : public PatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<StructurePatternMemberSyntax> members;
    Token closeBrace;

    StructurePatternSyntax(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace) :
        PatternSyntax(SyntaxKind::StructurePattern), openBrace(openBrace), members(members), closeBrace(closeBrace)
    {}

    StructurePatternSyntax(const StructurePatternSyntax&) = delete;
    StructurePatternSyntax& operator=(const StructurePatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &members;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MatchesClauseSyntax : public SyntaxNode {
    Token matchesKeyword;
    PatternSyntax& pattern;

    MatchesClauseSyntax(Token matchesKeyword, PatternSyntax& pattern) :
        SyntaxNode(SyntaxKind::MatchesClause), matchesKeyword(matchesKeyword), pattern(pattern)
    {}

    MatchesClauseSyntax(const MatchesClauseSyntax&) = delete;
    MatchesClauseSyntax& operator=(const MatchesClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return matchesKeyword;
            case 1: return &pattern;
            default: return nullptr;
        }
    }
};

struct ConditionalPatternSyntax : public SyntaxNode {
    ExpressionSyntax& expr;
    MatchesClauseSyntax* matchesClause;

    ConditionalPatternSyntax(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) :
        SyntaxNode(SyntaxKind::ConditionalPattern), expr(expr), matchesClause(matchesClause)
    {}

    ConditionalPatternSyntax(const ConditionalPatternSyntax&) = delete;
    ConditionalPatternSyntax& operator=(const ConditionalPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return matchesClause;
            default: return nullptr;
        }
    }
};

struct ConditionalPredicateSyntax : public SyntaxNode {
    SeparatedSyntaxList<ConditionalPatternSyntax> conditions;

    ConditionalPredicateSyntax(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) :
        SyntaxNode(SyntaxKind::ConditionalPredicate), conditions(conditions)
    {}

    ConditionalPredicateSyntax(const ConditionalPredicateSyntax&) = delete;
    ConditionalPredicateSyntax& operator=(const ConditionalPredicateSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &conditions;
            default: return nullptr;
        }
    }
};

struct AssignmentPatternSyntax : public SyntaxNode {

    AssignmentPatternSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct SimpleAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token closeBrace;

    SimpleAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::SimpleAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {}

    SimpleAssignmentPatternSyntax(const SimpleAssignmentPatternSyntax&) = delete;
    SimpleAssignmentPatternSyntax& operator=(const SimpleAssignmentPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct AssignmentPatternItemSyntax : public SyntaxNode {
    ExpressionSyntax& key;
    Token colon;
    ExpressionSyntax& expr;

    AssignmentPatternItemSyntax(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::AssignmentPatternItem), key(key), colon(colon), expr(expr)
    {}

    AssignmentPatternItemSyntax(const AssignmentPatternItemSyntax&) = delete;
    AssignmentPatternItemSyntax& operator=(const AssignmentPatternItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &key;
            case 1: return colon;
            case 2: return &expr;
            default: return nullptr;
        }
    }
};

struct StructuredAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    SeparatedSyntaxList<AssignmentPatternItemSyntax> items;
    Token closeBrace;

    StructuredAssignmentPatternSyntax(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::StructuredAssignmentPattern), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {}

    StructuredAssignmentPatternSyntax(const StructuredAssignmentPatternSyntax&) = delete;
    StructuredAssignmentPatternSyntax& operator=(const StructuredAssignmentPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ReplicatedAssignmentPatternSyntax : public AssignmentPatternSyntax {
    Token openBrace;
    ExpressionSyntax& countExpr;
    Token innerOpenBrace;
    SeparatedSyntaxList<ExpressionSyntax> items;
    Token innerCloseBrace;
    Token closeBrace;

    ReplicatedAssignmentPatternSyntax(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace) :
        AssignmentPatternSyntax(SyntaxKind::ReplicatedAssignmentPattern), openBrace(openBrace), countExpr(countExpr), innerOpenBrace(innerOpenBrace), items(items), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {}

    ReplicatedAssignmentPatternSyntax(const ReplicatedAssignmentPatternSyntax&) = delete;
    ReplicatedAssignmentPatternSyntax& operator=(const ReplicatedAssignmentPatternSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &countExpr;
            case 2: return innerOpenBrace;
            case 3: return &items;
            case 4: return innerCloseBrace;
            case 5: return closeBrace;
            default: return nullptr;
        }
    }
};

// ----- EXPRESSIONS -----

struct BadExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;

    BadExpressionSyntax(ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::BadExpression), expr(expr)
    {}

    BadExpressionSyntax(const BadExpressionSyntax&) = delete;
    BadExpressionSyntax& operator=(const BadExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct PrimaryExpressionSyntax : public ExpressionSyntax {

    PrimaryExpressionSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct PrefixUnaryExpressionSyntax : public ExpressionSyntax {
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& operand;

    PrefixUnaryExpressionSyntax(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand) :
        ExpressionSyntax(kind), operatorToken(operatorToken), attributes(attributes), operand(operand)
    {}

    PrefixUnaryExpressionSyntax(const PrefixUnaryExpressionSyntax&) = delete;
    PrefixUnaryExpressionSyntax& operator=(const PrefixUnaryExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return operatorToken;
            case 1: return &attributes;
            case 2: return &operand;
            default: return nullptr;
        }
    }
};

struct PostfixUnaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& operand;
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token operatorToken;

    PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken) :
        ExpressionSyntax(kind), operand(operand), attributes(attributes), operatorToken(operatorToken)
    {}

    PostfixUnaryExpressionSyntax(const PostfixUnaryExpressionSyntax&) = delete;
    PostfixUnaryExpressionSyntax& operator=(const PostfixUnaryExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &operand;
            case 1: return &attributes;
            case 2: return operatorToken;
            default: return nullptr;
        }
    }
};

struct BinaryExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token operatorToken;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& right;

    BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right) :
        ExpressionSyntax(kind), left(left), operatorToken(operatorToken), attributes(attributes), right(right)
    {}

    BinaryExpressionSyntax(const BinaryExpressionSyntax&) = delete;
    BinaryExpressionSyntax& operator=(const BinaryExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return operatorToken;
            case 2: return &attributes;
            case 3: return &right;
            default: return nullptr;
        }
    }
};

struct MinTypMaxExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& min;
    Token colon1;
    ExpressionSyntax& typ;
    Token colon2;
    ExpressionSyntax& max;

    MinTypMaxExpressionSyntax(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) :
        ExpressionSyntax(SyntaxKind::MinTypMaxExpression), min(min), colon1(colon1), typ(typ), colon2(colon2), max(max)
    {}

    MinTypMaxExpressionSyntax(const MinTypMaxExpressionSyntax&) = delete;
    MinTypMaxExpressionSyntax& operator=(const MinTypMaxExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &min;
            case 1: return colon1;
            case 2: return &typ;
            case 3: return colon2;
            case 4: return &max;
            default: return nullptr;
        }
    }
};

struct TaggedUnionExpressionSyntax : public ExpressionSyntax {
    Token tagged;
    Token member;
    ExpressionSyntax* expr;

    TaggedUnionExpressionSyntax(Token tagged, Token member, ExpressionSyntax* expr) :
        ExpressionSyntax(SyntaxKind::TaggedUnionExpression), tagged(tagged), member(member), expr(expr)
    {}

    TaggedUnionExpressionSyntax(const TaggedUnionExpressionSyntax&) = delete;
    TaggedUnionExpressionSyntax& operator=(const TaggedUnionExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return tagged;
            case 1: return member;
            case 2: return expr;
            default: return nullptr;
        }
    }
};

struct OpenRangeListSyntax : public SyntaxNode {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> valueRanges;
    Token closeBrace;

    OpenRangeListSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace) :
        SyntaxNode(SyntaxKind::OpenRangeList), openBrace(openBrace), valueRanges(valueRanges), closeBrace(closeBrace)
    {}

    OpenRangeListSyntax(const OpenRangeListSyntax&) = delete;
    OpenRangeListSyntax& operator=(const OpenRangeListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &valueRanges;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct InsideExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;
    Token inside;
    OpenRangeListSyntax& ranges;

    InsideExpressionSyntax(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) :
        ExpressionSyntax(SyntaxKind::InsideExpression), expr(expr), inside(inside), ranges(ranges)
    {}

    InsideExpressionSyntax(const InsideExpressionSyntax&) = delete;
    InsideExpressionSyntax& operator=(const InsideExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return inside;
            case 2: return &ranges;
            default: return nullptr;
        }
    }
};

struct ConditionalExpressionSyntax : public ExpressionSyntax {
    ConditionalPredicateSyntax& predicate;
    Token question;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ExpressionSyntax& left;
    Token colon;
    ExpressionSyntax& right;

    ConditionalExpressionSyntax(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::ConditionalExpression), predicate(predicate), question(question), attributes(attributes), left(left), colon(colon), right(right)
    {}

    ConditionalExpressionSyntax(const ConditionalExpressionSyntax&) = delete;
    ConditionalExpressionSyntax& operator=(const ConditionalExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &predicate;
            case 1: return question;
            case 2: return &attributes;
            case 3: return &left;
            case 4: return colon;
            case 5: return &right;
            default: return nullptr;
        }
    }
};

struct AssignmentPatternExpressionSyntax : public PrimaryExpressionSyntax {
    DataTypeSyntax* type;
    AssignmentPatternSyntax& pattern;

    AssignmentPatternExpressionSyntax(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) :
        PrimaryExpressionSyntax(SyntaxKind::AssignmentPatternExpression), type(type), pattern(pattern)
    {}

    AssignmentPatternExpressionSyntax(const AssignmentPatternExpressionSyntax&) = delete;
    AssignmentPatternExpressionSyntax& operator=(const AssignmentPatternExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return type;
            case 1: return &pattern;
            default: return nullptr;
        }
    }
};

// ----- SELECTORS -----

struct SelectorSyntax : public SyntaxNode {

    SelectorSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct BitSelectSyntax : public SelectorSyntax {
    ExpressionSyntax& expr;

    BitSelectSyntax(ExpressionSyntax& expr) :
        SelectorSyntax(SyntaxKind::BitSelect), expr(expr)
    {}

    BitSelectSyntax(const BitSelectSyntax&) = delete;
    BitSelectSyntax& operator=(const BitSelectSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct RangeSelectSyntax : public SelectorSyntax {
    ExpressionSyntax& left;
    Token range;
    ExpressionSyntax& right;

    RangeSelectSyntax(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) :
        SelectorSyntax(kind), left(left), range(range), right(right)
    {}

    RangeSelectSyntax(const RangeSelectSyntax&) = delete;
    RangeSelectSyntax& operator=(const RangeSelectSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return range;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ElementSelectSyntax : public ExpressionSyntax {
    Token openBracket;
    SelectorSyntax* selector;
    Token closeBracket;

    ElementSelectSyntax(Token openBracket, SelectorSyntax* selector, Token closeBracket) :
        ExpressionSyntax(SyntaxKind::ElementSelect), openBracket(openBracket), selector(selector), closeBracket(closeBracket)
    {}

    ElementSelectSyntax(const ElementSelectSyntax&) = delete;
    ElementSelectSyntax& operator=(const ElementSelectSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return selector;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

// ----- NAMES -----

struct NameSyntax : public ExpressionSyntax {

    NameSyntax(SyntaxKind kind) :
        ExpressionSyntax(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct IdentifierNameSyntax : public NameSyntax {
    Token identifier;

    IdentifierNameSyntax(Token identifier) :
        NameSyntax(SyntaxKind::IdentifierName), identifier(identifier)
    {}

    IdentifierNameSyntax(const IdentifierNameSyntax&) = delete;
    IdentifierNameSyntax& operator=(const IdentifierNameSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return identifier;
            default: return nullptr;
        }
    }
};

struct IdentifierSelectNameSyntax : public NameSyntax {
    Token identifier;
    SyntaxList<ElementSelectSyntax> selectors;

    IdentifierSelectNameSyntax(Token identifier, SyntaxList<ElementSelectSyntax> selectors) :
        NameSyntax(SyntaxKind::IdentifierSelectName), identifier(identifier), selectors(selectors)
    {}

    IdentifierSelectNameSyntax(const IdentifierSelectNameSyntax&) = delete;
    IdentifierSelectNameSyntax& operator=(const IdentifierSelectNameSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &selectors;
            default: return nullptr;
        }
    }
};

struct EmptyIdentifierNameSyntax : public NameSyntax {

    EmptyIdentifierNameSyntax() :
        NameSyntax(SyntaxKind::EmptyIdentifierName)
    {}

    EmptyIdentifierNameSyntax(const EmptyIdentifierNameSyntax&) = delete;
    EmptyIdentifierNameSyntax& operator=(const EmptyIdentifierNameSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        (void)index;
        return nullptr;
    }
};

struct KeywordNameSyntax : public NameSyntax {
    Token keyword;

    KeywordNameSyntax(SyntaxKind kind, Token keyword) :
        NameSyntax(kind), keyword(keyword)
    {}

    KeywordNameSyntax(const KeywordNameSyntax&) = delete;
    KeywordNameSyntax& operator=(const KeywordNameSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct ClassNameSyntax : public NameSyntax {
    Token identifier;
    ParameterValueAssignmentSyntax& parameters;

    ClassNameSyntax(Token identifier, ParameterValueAssignmentSyntax& parameters) :
        NameSyntax(SyntaxKind::ClassName), identifier(identifier), parameters(parameters)
    {}

    ClassNameSyntax(const ClassNameSyntax&) = delete;
    ClassNameSyntax& operator=(const ClassNameSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return identifier;
            case 1: return &parameters;
            default: return nullptr;
        }
    }
};

struct ScopedNameSyntax : public NameSyntax {
    NameSyntax& left;
    Token separator;
    NameSyntax& right;

    ScopedNameSyntax(NameSyntax& left, Token separator, NameSyntax& right) :
        NameSyntax(SyntaxKind::ScopedName), left(left), separator(separator), right(right)
    {}

    ScopedNameSyntax(const ScopedNameSyntax&) = delete;
    ScopedNameSyntax& operator=(const ScopedNameSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return separator;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ClassScopeSyntax : public NameSyntax {
    NameSyntax& left;
    Token separator;

    ClassScopeSyntax(NameSyntax& left, Token separator) :
        NameSyntax(SyntaxKind::ClassScope), left(left), separator(separator)
    {}

    ClassScopeSyntax(const ClassScopeSyntax&) = delete;
    ClassScopeSyntax& operator=(const ClassScopeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return separator;
            default: return nullptr;
        }
    }
};

// ----- PRIMARY EXPRESSIONS -----

struct LiteralExpressionSyntax : public PrimaryExpressionSyntax {
    Token literal;

    LiteralExpressionSyntax(SyntaxKind kind, Token literal) :
        PrimaryExpressionSyntax(kind), literal(literal)
    {}

    LiteralExpressionSyntax(const LiteralExpressionSyntax&) = delete;
    LiteralExpressionSyntax& operator=(const LiteralExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return literal;
            default: return nullptr;
        }
    }
};

struct IntegerVectorExpressionSyntax : public PrimaryExpressionSyntax {
    Token size;
    Token base;
    Token value;

    IntegerVectorExpressionSyntax(Token size, Token base, Token value) :
        PrimaryExpressionSyntax(SyntaxKind::IntegerVectorExpression), size(size), base(base), value(value)
    {}

    IntegerVectorExpressionSyntax(const IntegerVectorExpressionSyntax&) = delete;
    IntegerVectorExpressionSyntax& operator=(const IntegerVectorExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return size;
            case 1: return base;
            case 2: return value;
            default: return nullptr;
        }
    }
};

struct EmptyQueueExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token closeBrace;

    EmptyQueueExpressionSyntax(Token openBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::EmptyQueueExpression), openBrace(openBrace), closeBrace(closeBrace)
    {}

    EmptyQueueExpressionSyntax(const EmptyQueueExpressionSyntax&) = delete;
    EmptyQueueExpressionSyntax& operator=(const EmptyQueueExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token closeBrace;

    ConcatenationExpressionSyntax(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::ConcatenationExpression), openBrace(openBrace), expressions(expressions), closeBrace(closeBrace)
    {}

    ConcatenationExpressionSyntax(const ConcatenationExpressionSyntax&) = delete;
    ConcatenationExpressionSyntax& operator=(const ConcatenationExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expressions;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct MultipleConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    ExpressionSyntax& expression;
    ConcatenationExpressionSyntax& concatenation;
    Token closeBrace;

    MultipleConcatenationExpressionSyntax(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::MultipleConcatenationExpression), openBrace(openBrace), expression(expression), concatenation(concatenation), closeBrace(closeBrace)
    {}

    MultipleConcatenationExpressionSyntax(const MultipleConcatenationExpressionSyntax&) = delete;
    MultipleConcatenationExpressionSyntax& operator=(const MultipleConcatenationExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &expression;
            case 2: return &concatenation;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }
};

struct StreamExpressionWithRange : public SyntaxNode {
    Token withKeyword;
    ElementSelectSyntax& range;

    StreamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) :
        SyntaxNode(SyntaxKind::StreamExpressionWithRange), withKeyword(withKeyword), range(range)
    {}

    StreamExpressionWithRange(const StreamExpressionWithRange&) = delete;
    StreamExpressionWithRange& operator=(const StreamExpressionWithRange&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return withKeyword;
            case 1: return &range;
            default: return nullptr;
        }
    }
};

struct StreamExpressionSyntax : public SyntaxNode {
    ExpressionSyntax& expression;
    StreamExpressionWithRange* withRange;

    StreamExpressionSyntax(ExpressionSyntax& expression, StreamExpressionWithRange* withRange) :
        SyntaxNode(SyntaxKind::StreamExpression), expression(expression), withRange(withRange)
    {}

    StreamExpressionSyntax(const StreamExpressionSyntax&) = delete;
    StreamExpressionSyntax& operator=(const StreamExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expression;
            case 1: return withRange;
            default: return nullptr;
        }
    }
};

struct StreamingConcatenationExpressionSyntax : public PrimaryExpressionSyntax {
    Token openBrace;
    Token operatorToken;
    ExpressionSyntax* sliceSize;
    Token innerOpenBrace;
    SeparatedSyntaxList<StreamExpressionSyntax> expressions;
    Token innerCloseBrace;
    Token closeBrace;

    StreamingConcatenationExpressionSyntax(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace) :
        PrimaryExpressionSyntax(SyntaxKind::StreamingConcatenationExpression), openBrace(openBrace), operatorToken(operatorToken), sliceSize(sliceSize), innerOpenBrace(innerOpenBrace), expressions(expressions), innerCloseBrace(innerCloseBrace), closeBrace(closeBrace)
    {}

    StreamingConcatenationExpressionSyntax(const StreamingConcatenationExpressionSyntax&) = delete;
    StreamingConcatenationExpressionSyntax& operator=(const StreamingConcatenationExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return operatorToken;
            case 2: return sliceSize;
            case 3: return innerOpenBrace;
            case 4: return &expressions;
            case 5: return innerCloseBrace;
            case 6: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ParenthesizedExpressionSyntax : public PrimaryExpressionSyntax {
    Token openParen;
    ExpressionSyntax& expression;
    Token closeParen;

    ParenthesizedExpressionSyntax(Token openParen, ExpressionSyntax& expression, Token closeParen) :
        PrimaryExpressionSyntax(SyntaxKind::ParenthesizedExpression), openParen(openParen), expression(expression), closeParen(closeParen)
    {}

    ParenthesizedExpressionSyntax(const ParenthesizedExpressionSyntax&) = delete;
    ParenthesizedExpressionSyntax& operator=(const ParenthesizedExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &expression;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct NewClassExpressionSyntax : public ExpressionSyntax {
    ClassScopeSyntax* classScope;
    Token newKeyword;
    ArgumentListSyntax* arguments;

    NewClassExpressionSyntax(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::NewClassExpression), classScope(classScope), newKeyword(newKeyword), arguments(arguments)
    {}

    NewClassExpressionSyntax(const NewClassExpressionSyntax&) = delete;
    NewClassExpressionSyntax& operator=(const NewClassExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return classScope;
            case 1: return newKeyword;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct NewArrayExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    Token openBracket;
    ExpressionSyntax& sizeExpr;
    Token closeBracket;
    ParenthesizedExpressionSyntax* initializer;

    NewArrayExpressionSyntax(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) :
        ExpressionSyntax(SyntaxKind::NewArrayExpression), newKeyword(newKeyword), openBracket(openBracket), sizeExpr(sizeExpr), closeBracket(closeBracket), initializer(initializer)
    {}

    NewArrayExpressionSyntax(const NewArrayExpressionSyntax&) = delete;
    NewArrayExpressionSyntax& operator=(const NewArrayExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return openBracket;
            case 2: return &sizeExpr;
            case 3: return closeBracket;
            case 4: return initializer;
            default: return nullptr;
        }
    }
};

struct NewExpressionSyntax : public ExpressionSyntax {
    Token newKeyword;
    ExpressionSyntax& expr;

    NewExpressionSyntax(Token newKeyword, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::NewExpression), newKeyword(newKeyword), expr(expr)
    {}

    NewExpressionSyntax(const NewExpressionSyntax&) = delete;
    NewExpressionSyntax& operator=(const NewExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return newKeyword;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

// ----- POSTFIX EXPRESSIONS -----

struct ElementSelectExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    ElementSelectSyntax& select;

    ElementSelectExpressionSyntax(ExpressionSyntax& left, ElementSelectSyntax& select) :
        ExpressionSyntax(SyntaxKind::ElementSelectExpression), left(left), select(select)
    {}

    ElementSelectExpressionSyntax(const ElementSelectExpressionSyntax&) = delete;
    ElementSelectExpressionSyntax& operator=(const ElementSelectExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return &select;
            default: return nullptr;
        }
    }
};

struct MemberAccessExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token dot;
    Token name;

    MemberAccessExpressionSyntax(ExpressionSyntax& left, Token dot, Token name) :
        ExpressionSyntax(SyntaxKind::MemberAccessExpression), left(left), dot(dot), name(name)
    {}

    MemberAccessExpressionSyntax(const MemberAccessExpressionSyntax&) = delete;
    MemberAccessExpressionSyntax& operator=(const MemberAccessExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return dot;
            case 2: return name;
            default: return nullptr;
        }
    }
};

struct InvocationExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    SyntaxList<AttributeInstanceSyntax> attributes;
    ArgumentListSyntax* arguments;

    InvocationExpressionSyntax(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) :
        ExpressionSyntax(SyntaxKind::InvocationExpression), left(left), attributes(attributes), arguments(arguments)
    {}

    InvocationExpressionSyntax(const InvocationExpressionSyntax&) = delete;
    InvocationExpressionSyntax& operator=(const InvocationExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return &attributes;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct CastExpressionSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    Token apostrophe;
    ParenthesizedExpressionSyntax& right;

    CastExpressionSyntax(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::CastExpression), left(left), apostrophe(apostrophe), right(right)
    {}

    CastExpressionSyntax(const CastExpressionSyntax&) = delete;
    CastExpressionSyntax& operator=(const CastExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return apostrophe;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct SignedCastExpressionSyntax : public ExpressionSyntax {
    Token signing;
    Token apostrophe;
    ParenthesizedExpressionSyntax& inner;

    SignedCastExpressionSyntax(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) :
        ExpressionSyntax(SyntaxKind::SignedCastExpression), signing(signing), apostrophe(apostrophe), inner(inner)
    {}

    SignedCastExpressionSyntax(const SignedCastExpressionSyntax&) = delete;
    SignedCastExpressionSyntax& operator=(const SignedCastExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return signing;
            case 1: return apostrophe;
            case 2: return &inner;
            default: return nullptr;
        }
    }
};

// ----- TIMING CONTROL -----

struct TimingControlSyntax : public SyntaxNode {

    TimingControlSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct DelaySyntax : public TimingControlSyntax {
    Token hash;
    ExpressionSyntax& delayValue;

    DelaySyntax(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) :
        TimingControlSyntax(kind), hash(hash), delayValue(delayValue)
    {}

    DelaySyntax(const DelaySyntax&) = delete;
    DelaySyntax& operator=(const DelaySyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return &delayValue;
            default: return nullptr;
        }
    }
};

struct EventControlSyntax : public TimingControlSyntax {
    Token at;
    NameSyntax& eventName;

    EventControlSyntax(Token at, NameSyntax& eventName) :
        TimingControlSyntax(SyntaxKind::EventControl), at(at), eventName(eventName)
    {}

    EventControlSyntax(const EventControlSyntax&) = delete;
    EventControlSyntax& operator=(const EventControlSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return at;
            case 1: return &eventName;
            default: return nullptr;
        }
    }
};

struct EventExpressionSyntax : public SyntaxNode {

    EventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct SignalEventExpressionSyntax : public EventExpressionSyntax {
    Token edge;
    ExpressionSyntax& expr;

    SignalEventExpressionSyntax(Token edge, ExpressionSyntax& expr) :
        EventExpressionSyntax(SyntaxKind::SignalEventExpression), edge(edge), expr(expr)
    {}

    SignalEventExpressionSyntax(const SignalEventExpressionSyntax&) = delete;
    SignalEventExpressionSyntax& operator=(const SignalEventExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return edge;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct BinaryEventExpressionSyntax : public EventExpressionSyntax {
    EventExpressionSyntax& left;
    Token operatorToken;
    EventExpressionSyntax& right;

    BinaryEventExpressionSyntax(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) :
        EventExpressionSyntax(SyntaxKind::BinaryEventExpression), left(left), operatorToken(operatorToken), right(right)
    {}

    BinaryEventExpressionSyntax(const BinaryEventExpressionSyntax&) = delete;
    BinaryEventExpressionSyntax& operator=(const BinaryEventExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return operatorToken;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ParenthesizedEventExpressionSyntax : public EventExpressionSyntax {
    Token openParen;
    EventExpressionSyntax& expr;
    Token closeParen;

    ParenthesizedEventExpressionSyntax(Token openParen, EventExpressionSyntax& expr, Token closeParen) :
        EventExpressionSyntax(SyntaxKind::ParenthesizedEventExpression), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    ParenthesizedEventExpressionSyntax(const ParenthesizedEventExpressionSyntax&) = delete;
    ParenthesizedEventExpressionSyntax& operator=(const ParenthesizedEventExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &expr;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ImplicitEventControlSyntax : public TimingControlSyntax {
    Token atStar;

    ImplicitEventControlSyntax(Token atStar) :
        TimingControlSyntax(SyntaxKind::ImplicitEventControl), atStar(atStar)
    {}

    ImplicitEventControlSyntax(const ImplicitEventControlSyntax&) = delete;
    ImplicitEventControlSyntax& operator=(const ImplicitEventControlSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return atStar;
            default: return nullptr;
        }
    }
};

struct ParenImplicitEventControlSyntax : public TimingControlSyntax {
    Token at;
    Token openParenStarCloseParen;

    ParenImplicitEventControlSyntax(Token at, Token openParenStarCloseParen) :
        TimingControlSyntax(SyntaxKind::ParenImplicitEventControl), at(at), openParenStarCloseParen(openParenStarCloseParen)
    {}

    ParenImplicitEventControlSyntax(const ParenImplicitEventControlSyntax&) = delete;
    ParenImplicitEventControlSyntax& operator=(const ParenImplicitEventControlSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return at;
            case 1: return openParenStarCloseParen;
            default: return nullptr;
        }
    }
};

struct EventControlWithExpressionSyntax : public TimingControlSyntax {
    Token at;
    EventExpressionSyntax& expr;

    EventControlWithExpressionSyntax(Token at, EventExpressionSyntax& expr) :
        TimingControlSyntax(SyntaxKind::EventControlWithExpression), at(at), expr(expr)
    {}

    EventControlWithExpressionSyntax(const EventControlWithExpressionSyntax&) = delete;
    EventControlWithExpressionSyntax& operator=(const EventControlWithExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return at;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct RepeatedEventControlSyntax : public TimingControlSyntax {
    Token repeat;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    TimingControlSyntax* eventControl;

    RepeatedEventControlSyntax(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) :
        TimingControlSyntax(SyntaxKind::RepeatedEventControl), repeat(repeat), openParen(openParen), expr(expr), closeParen(closeParen), eventControl(eventControl)
    {}

    RepeatedEventControlSyntax(const RepeatedEventControlSyntax&) = delete;
    RepeatedEventControlSyntax& operator=(const RepeatedEventControlSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return repeat;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            case 4: return eventControl;
            default: return nullptr;
        }
    }
};

struct TimingControlExpressionSyntax : public ExpressionSyntax {
    TimingControlSyntax& timing;
    ExpressionSyntax& expr;

    TimingControlExpressionSyntax(TimingControlSyntax& timing, ExpressionSyntax& expr) :
        ExpressionSyntax(SyntaxKind::TimingControlExpression), timing(timing), expr(expr)
    {}

    TimingControlExpressionSyntax(const TimingControlExpressionSyntax&) = delete;
    TimingControlExpressionSyntax& operator=(const TimingControlExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &timing;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct TimingControlExpressionConcatenationSyntax : public ExpressionSyntax {
    ExpressionSyntax& left;
    TimingControlSyntax& timing;
    ExpressionSyntax& right;

    TimingControlExpressionConcatenationSyntax(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) :
        ExpressionSyntax(SyntaxKind::TimingControlExpressionConcatenation), left(left), timing(timing), right(right)
    {}

    TimingControlExpressionConcatenationSyntax(const TimingControlExpressionConcatenationSyntax&) = delete;
    TimingControlExpressionConcatenationSyntax& operator=(const TimingControlExpressionConcatenationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return &timing;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct ShortcutCycleDelayRangeSyntax : public TimingControlSyntax {
    Token doubleHash;
    Token openBracket;
    Token op;
    Token closeBracket;

    ShortcutCycleDelayRangeSyntax(Token doubleHash, Token openBracket, Token op, Token closeBracket) :
        TimingControlSyntax(SyntaxKind::ShortcutCycleDelayRange), doubleHash(doubleHash), openBracket(openBracket), op(op), closeBracket(closeBracket)
    {}

    ShortcutCycleDelayRangeSyntax(const ShortcutCycleDelayRangeSyntax&) = delete;
    ShortcutCycleDelayRangeSyntax& operator=(const ShortcutCycleDelayRangeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return doubleHash;
            case 1: return openBracket;
            case 2: return op;
            case 3: return closeBracket;
            default: return nullptr;
        }
    }
};

// ----- DECLARATIONS -----

struct DimensionSpecifierSyntax : public SyntaxNode {

    DimensionSpecifierSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct RangeDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    SelectorSyntax& selector;

    RangeDimensionSpecifierSyntax(SelectorSyntax& selector) :
        DimensionSpecifierSyntax(SyntaxKind::RangeDimensionSpecifier), selector(selector)
    {}

    RangeDimensionSpecifierSyntax(const RangeDimensionSpecifierSyntax&) = delete;
    RangeDimensionSpecifierSyntax& operator=(const RangeDimensionSpecifierSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &selector;
            default: return nullptr;
        }
    }
};

struct WildcardDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token star;

    WildcardDimensionSpecifierSyntax(Token star) :
        DimensionSpecifierSyntax(SyntaxKind::WildcardDimensionSpecifier), star(star)
    {}

    WildcardDimensionSpecifierSyntax(const WildcardDimensionSpecifierSyntax&) = delete;
    WildcardDimensionSpecifierSyntax& operator=(const WildcardDimensionSpecifierSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return star;
            default: return nullptr;
        }
    }
};

struct ColonExpressionClauseSyntax : public SyntaxNode {
    Token colon;
    ExpressionSyntax& expr;

    ColonExpressionClauseSyntax(Token colon, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::ColonExpressionClause), colon(colon), expr(expr)
    {}

    ColonExpressionClauseSyntax(const ColonExpressionClauseSyntax&) = delete;
    ColonExpressionClauseSyntax& operator=(const ColonExpressionClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return colon;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct QueueDimensionSpecifierSyntax : public DimensionSpecifierSyntax {
    Token dollar;
    ColonExpressionClauseSyntax* maxSizeClause;

    QueueDimensionSpecifierSyntax(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) :
        DimensionSpecifierSyntax(SyntaxKind::QueueDimensionSpecifier), dollar(dollar), maxSizeClause(maxSizeClause)
    {}

    QueueDimensionSpecifierSyntax(const QueueDimensionSpecifierSyntax&) = delete;
    QueueDimensionSpecifierSyntax& operator=(const QueueDimensionSpecifierSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dollar;
            case 1: return maxSizeClause;
            default: return nullptr;
        }
    }
};

struct VariableDimensionSyntax : public SyntaxNode {
    Token openBracket;
    DimensionSpecifierSyntax* specifier;
    Token closeBracket;

    VariableDimensionSyntax(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) :
        SyntaxNode(SyntaxKind::VariableDimension), openBracket(openBracket), specifier(specifier), closeBracket(closeBracket)
    {}

    VariableDimensionSyntax(const VariableDimensionSyntax&) = delete;
    VariableDimensionSyntax& operator=(const VariableDimensionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return closeBracket;
            default: return nullptr;
        }
    }
};

struct VariableDeclaratorSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    EqualsValueClauseSyntax* initializer;

    VariableDeclaratorSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) :
        SyntaxNode(SyntaxKind::VariableDeclarator), name(name), dimensions(dimensions), initializer(initializer)
    {}

    VariableDeclaratorSyntax(const VariableDeclaratorSyntax&) = delete;
    VariableDeclaratorSyntax& operator=(const VariableDeclaratorSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return initializer;
            default: return nullptr;
        }
    }
};

struct DataDeclarationSyntax : public MemberSyntax {
    TokenList modifiers;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    DataDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::DataDeclaration, attributes), modifiers(modifiers), type(type), declarators(declarators), semi(semi)
    {}

    DataDeclarationSyntax(const DataDeclarationSyntax&) = delete;
    DataDeclarationSyntax& operator=(const DataDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &modifiers;
            case 2: return &type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct TypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    DataTypeSyntax& type;
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token semi;

    TypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi) :
        MemberSyntax(SyntaxKind::TypedefDeclaration, attributes), typedefKeyword(typedefKeyword), type(type), name(name), dimensions(dimensions), semi(semi)
    {}

    TypedefDeclarationSyntax(const TypedefDeclarationSyntax&) = delete;
    TypedefDeclarationSyntax& operator=(const TypedefDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return &type;
            case 3: return name;
            case 4: return &dimensions;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct ForwardTypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token keyword;
    Token name;
    Token semi;

    ForwardTypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ForwardTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), keyword(keyword), name(name), semi(semi)
    {}

    ForwardTypedefDeclarationSyntax(const ForwardTypedefDeclarationSyntax&) = delete;
    ForwardTypedefDeclarationSyntax& operator=(const ForwardTypedefDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ForwardInterfaceClassTypedefDeclarationSyntax : public MemberSyntax {
    Token typedefKeyword;
    Token interfaceKeyword;
    Token classKeyword;
    Token name;
    Token semi;

    ForwardInterfaceClassTypedefDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ForwardInterfaceClassTypedefDeclaration, attributes), typedefKeyword(typedefKeyword), interfaceKeyword(interfaceKeyword), classKeyword(classKeyword), name(name), semi(semi)
    {}

    ForwardInterfaceClassTypedefDeclarationSyntax(const ForwardInterfaceClassTypedefDeclarationSyntax&) = delete;
    ForwardInterfaceClassTypedefDeclarationSyntax& operator=(const ForwardInterfaceClassTypedefDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return typedefKeyword;
            case 2: return interfaceKeyword;
            case 3: return classKeyword;
            case 4: return name;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct NetStrengthSyntax : public SyntaxNode {

    NetStrengthSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct ChargeStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength;
    Token closeParen;

    ChargeStrengthSyntax(Token openParen, Token strength, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::ChargeStrength), openParen(openParen), strength(strength), closeParen(closeParen)
    {}

    ChargeStrengthSyntax(const ChargeStrengthSyntax&) = delete;
    ChargeStrengthSyntax& operator=(const ChargeStrengthSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct DriveStrengthSyntax : public NetStrengthSyntax {
    Token openParen;
    Token strength0;
    Token comma;
    Token strength1;
    Token closeParen;

    DriveStrengthSyntax(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) :
        NetStrengthSyntax(SyntaxKind::DriveStrength), openParen(openParen), strength0(strength0), comma(comma), strength1(strength1), closeParen(closeParen)
    {}

    DriveStrengthSyntax(const DriveStrengthSyntax&) = delete;
    DriveStrengthSyntax& operator=(const DriveStrengthSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return strength0;
            case 2: return comma;
            case 3: return strength1;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct NetDeclarationSyntax : public MemberSyntax {
    Token netType;
    NetStrengthSyntax* strength;
    Token expansionHint;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    NetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::NetDeclaration, attributes), netType(netType), strength(strength), expansionHint(expansionHint), type(type), declarators(declarators), semi(semi)
    {}

    NetDeclarationSyntax(const NetDeclarationSyntax&) = delete;
    NetDeclarationSyntax& operator=(const NetDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return netType;
            case 2: return strength;
            case 3: return expansionHint;
            case 4: return &type;
            case 5: return &declarators;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct PackageImportItemSyntax : public SyntaxNode {
    Token package;
    Token doubleColon;
    Token item;

    PackageImportItemSyntax(Token package, Token doubleColon, Token item) :
        SyntaxNode(SyntaxKind::PackageImportItem), package(package), doubleColon(doubleColon), item(item)
    {}

    PackageImportItemSyntax(const PackageImportItemSyntax&) = delete;
    PackageImportItemSyntax& operator=(const PackageImportItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return package;
            case 1: return doubleColon;
            case 2: return item;
            default: return nullptr;
        }
    }
};

struct PackageImportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<PackageImportItemSyntax> items;
    Token semi;

    PackageImportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::PackageImportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {}

    PackageImportDeclarationSyntax(const PackageImportDeclarationSyntax&) = delete;
    PackageImportDeclarationSyntax& operator=(const PackageImportDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ParameterDeclarationSyntax : public SyntaxNode {
    Token keyword;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;

    ParameterDeclarationSyntax(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators) :
        SyntaxNode(SyntaxKind::ParameterDeclaration), keyword(keyword), type(type), declarators(declarators)
    {}

    ParameterDeclarationSyntax(const ParameterDeclarationSyntax&) = delete;
    ParameterDeclarationSyntax& operator=(const ParameterDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &type;
            case 2: return &declarators;
            default: return nullptr;
        }
    }
};

struct ParameterDeclarationStatementSyntax : public MemberSyntax {
    ParameterDeclarationSyntax& parameter;
    Token semi;

    ParameterDeclarationStatementSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi) :
        MemberSyntax(SyntaxKind::ParameterDeclarationStatement, attributes), parameter(parameter), semi(semi)
    {}

    ParameterDeclarationStatementSyntax(const ParameterDeclarationStatementSyntax&) = delete;
    ParameterDeclarationStatementSyntax& operator=(const ParameterDeclarationStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &parameter;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct PortHeaderSyntax : public SyntaxNode {

    PortHeaderSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct PortDeclarationSyntax : public MemberSyntax {
    PortHeaderSyntax& header;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    PortDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        MemberSyntax(SyntaxKind::PortDeclaration, attributes), header(header), declarators(declarators), semi(semi)
    {}

    PortDeclarationSyntax(const PortDeclarationSyntax&) = delete;
    PortDeclarationSyntax& operator=(const PortDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &declarators;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct GenvarDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token semi;

    GenvarDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi) :
        MemberSyntax(SyntaxKind::GenvarDeclaration, attributes), keyword(keyword), identifiers(identifiers), semi(semi)
    {}

    GenvarDeclarationSyntax(const GenvarDeclarationSyntax&) = delete;
    GenvarDeclarationSyntax& operator=(const GenvarDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &identifiers;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

// ----- TYPES -----

struct IntegerTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    IntegerTypeSyntax(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), signing(signing), dimensions(dimensions)
    {}

    IntegerTypeSyntax(const IntegerTypeSyntax&) = delete;
    IntegerTypeSyntax& operator=(const IntegerTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return signing;
            case 2: return &dimensions;
            default: return nullptr;
        }
    }
};

struct KeywordTypeSyntax : public DataTypeSyntax {
    Token keyword;

    KeywordTypeSyntax(SyntaxKind kind, Token keyword) :
        DataTypeSyntax(kind), keyword(keyword)
    {}

    KeywordTypeSyntax(const KeywordTypeSyntax&) = delete;
    KeywordTypeSyntax& operator=(const KeywordTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            default: return nullptr;
        }
    }
};

struct NamedTypeSyntax : public DataTypeSyntax {
    NameSyntax& name;

    NamedTypeSyntax(NameSyntax& name) :
        DataTypeSyntax(SyntaxKind::NamedType), name(name)
    {}

    NamedTypeSyntax(const NamedTypeSyntax&) = delete;
    NamedTypeSyntax& operator=(const NamedTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &name;
            default: return nullptr;
        }
    }
};

struct StructUnionMemberSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token randomQualifier;
    DataTypeSyntax& type;
    SeparatedSyntaxList<VariableDeclaratorSyntax> declarators;
    Token semi;

    StructUnionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) :
        SyntaxNode(SyntaxKind::StructUnionMember), attributes(attributes), randomQualifier(randomQualifier), type(type), declarators(declarators), semi(semi)
    {}

    StructUnionMemberSyntax(const StructUnionMemberSyntax&) = delete;
    StructUnionMemberSyntax& operator=(const StructUnionMemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return randomQualifier;
            case 2: return &type;
            case 3: return &declarators;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct StructUnionTypeSyntax : public DataTypeSyntax {
    Token keyword;
    Token tagged;
    Token packed;
    Token signing;
    Token openBrace;
    SyntaxList<StructUnionMemberSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    StructUnionTypeSyntax(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(kind), keyword(keyword), tagged(tagged), packed(packed), signing(signing), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {}

    StructUnionTypeSyntax(const StructUnionTypeSyntax&) = delete;
    StructUnionTypeSyntax& operator=(const StructUnionTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return tagged;
            case 2: return packed;
            case 3: return signing;
            case 4: return openBrace;
            case 5: return &members;
            case 6: return closeBrace;
            case 7: return &dimensions;
            default: return nullptr;
        }
    }
};

struct EnumTypeSyntax : public DataTypeSyntax {
    Token keyword;
    DataTypeSyntax* baseType;
    Token openBrace;
    SeparatedSyntaxList<VariableDeclaratorSyntax> members;
    Token closeBrace;
    SyntaxList<VariableDimensionSyntax> dimensions;

    EnumTypeSyntax(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::EnumType), keyword(keyword), baseType(baseType), openBrace(openBrace), members(members), closeBrace(closeBrace), dimensions(dimensions)
    {}

    EnumTypeSyntax(const EnumTypeSyntax&) = delete;
    EnumTypeSyntax& operator=(const EnumTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return baseType;
            case 2: return openBrace;
            case 3: return &members;
            case 4: return closeBrace;
            case 5: return &dimensions;
            default: return nullptr;
        }
    }
};

struct TypeReferenceSyntax : public DataTypeSyntax {
    Token typeKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    TypeReferenceSyntax(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        DataTypeSyntax(SyntaxKind::TypeReference), typeKeyword(typeKeyword), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    TypeReferenceSyntax(const TypeReferenceSyntax&) = delete;
    TypeReferenceSyntax& operator=(const TypeReferenceSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return typeKeyword;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct DotMemberClauseSyntax : public SyntaxNode {
    Token dot;
    Token member;

    DotMemberClauseSyntax(Token dot, Token member) :
        SyntaxNode(SyntaxKind::DotMemberClause), dot(dot), member(member)
    {}

    DotMemberClauseSyntax(const DotMemberClauseSyntax&) = delete;
    DotMemberClauseSyntax& operator=(const DotMemberClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return member;
            default: return nullptr;
        }
    }
};

struct VirtualInterfaceTypeSyntax : public DataTypeSyntax {
    Token virtualKeyword;
    Token interfaceKeyword;
    Token name;
    ParameterValueAssignmentSyntax* parameters;
    DotMemberClauseSyntax* modport;

    VirtualInterfaceTypeSyntax(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) :
        DataTypeSyntax(SyntaxKind::VirtualInterfaceType), virtualKeyword(virtualKeyword), interfaceKeyword(interfaceKeyword), name(name), parameters(parameters), modport(modport)
    {}

    VirtualInterfaceTypeSyntax(const VirtualInterfaceTypeSyntax&) = delete;
    VirtualInterfaceTypeSyntax& operator=(const VirtualInterfaceTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return virtualKeyword;
            case 1: return interfaceKeyword;
            case 2: return name;
            case 3: return parameters;
            case 4: return modport;
            default: return nullptr;
        }
    }
};

struct ImplicitTypeSyntax : public DataTypeSyntax {
    Token signing;
    SyntaxList<VariableDimensionSyntax> dimensions;

    ImplicitTypeSyntax(Token signing, SyntaxList<VariableDimensionSyntax> dimensions) :
        DataTypeSyntax(SyntaxKind::ImplicitType), signing(signing), dimensions(dimensions)
    {}

    ImplicitTypeSyntax(const ImplicitTypeSyntax&) = delete;
    ImplicitTypeSyntax& operator=(const ImplicitTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return signing;
            case 1: return &dimensions;
            default: return nullptr;
        }
    }
};

struct VarDataTypeSyntax : public DataTypeSyntax {
    Token var;
    DataTypeSyntax& type;

    VarDataTypeSyntax(Token var, DataTypeSyntax& type) :
        DataTypeSyntax(SyntaxKind::VarDataType), var(var), type(type)
    {}

    VarDataTypeSyntax(const VarDataTypeSyntax&) = delete;
    VarDataTypeSyntax& operator=(const VarDataTypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return var;
            case 1: return &type;
            default: return nullptr;
        }
    }
};

// ----- ASSERTIONS -----

struct DeferredAssertionSyntax : public SyntaxNode {
    Token hash;
    Token zero;
    Token finalKeyword;

    DeferredAssertionSyntax(Token hash, Token zero, Token finalKeyword) :
        SyntaxNode(SyntaxKind::DeferredAssertion), hash(hash), zero(zero), finalKeyword(finalKeyword)
    {}

    DeferredAssertionSyntax(const DeferredAssertionSyntax&) = delete;
    DeferredAssertionSyntax& operator=(const DeferredAssertionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return zero;
            case 2: return finalKeyword;
            default: return nullptr;
        }
    }
};

struct ElseClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    SyntaxNode& clause;

    ElseClauseSyntax(Token elseKeyword, SyntaxNode& clause) :
        SyntaxNode(SyntaxKind::ElseClause), elseKeyword(elseKeyword), clause(clause)
    {}

    ElseClauseSyntax(const ElseClauseSyntax&) = delete;
    ElseClauseSyntax& operator=(const ElseClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return &clause;
            default: return nullptr;
        }
    }
};

struct ActionBlockSyntax : public SyntaxNode {
    StatementSyntax* statement;
    ElseClauseSyntax* elseClause;

    ActionBlockSyntax(StatementSyntax* statement, ElseClauseSyntax* elseClause) :
        SyntaxNode(SyntaxKind::ActionBlock), statement(statement), elseClause(elseClause)
    {}

    ActionBlockSyntax(const ActionBlockSyntax&) = delete;
    ActionBlockSyntax& operator=(const ActionBlockSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return statement;
            case 1: return elseClause;
            default: return nullptr;
        }
    }
};

struct ImmediateAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    DeferredAssertionSyntax* delay;
    ParenthesizedExpressionSyntax& expr;
    ActionBlockSyntax& action;

    ImmediateAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), delay(delay), expr(expr), action(action)
    {}

    ImmediateAssertionStatementSyntax(const ImmediateAssertionStatementSyntax&) = delete;
    ImmediateAssertionStatementSyntax& operator=(const ImmediateAssertionStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return delay;
            case 4: return &expr;
            case 5: return &action;
            default: return nullptr;
        }
    }
};

struct DisableIffSyntax : public SyntaxNode {
    Token disable;
    Token iff;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    DisableIffSyntax(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::DisableIff), disable(disable), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    DisableIffSyntax(const DisableIffSyntax&) = delete;
    DisableIffSyntax& operator=(const DisableIffSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return disable;
            case 1: return iff;
            case 2: return openParen;
            case 3: return &expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct PropertySpecSyntax : public SyntaxNode {
    TimingControlSyntax* clocking;
    DisableIffSyntax* disable;
    ExpressionSyntax& expr;

    PropertySpecSyntax(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::PropertySpec), clocking(clocking), disable(disable), expr(expr)
    {}

    PropertySpecSyntax(const PropertySpecSyntax&) = delete;
    PropertySpecSyntax& operator=(const PropertySpecSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return clocking;
            case 1: return disable;
            case 2: return &expr;
            default: return nullptr;
        }
    }
};

struct ConcurrentAssertionStatementSyntax : public StatementSyntax {
    Token keyword;
    Token propertyOrSequence;
    Token openParen;
    PropertySpecSyntax& propertySpec;
    Token closeParen;
    ActionBlockSyntax& action;

    ConcurrentAssertionStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(kind, label, attributes), keyword(keyword), propertyOrSequence(propertyOrSequence), openParen(openParen), propertySpec(propertySpec), closeParen(closeParen), action(action)
    {}

    ConcurrentAssertionStatementSyntax(const ConcurrentAssertionStatementSyntax&) = delete;
    ConcurrentAssertionStatementSyntax& operator=(const ConcurrentAssertionStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return propertyOrSequence;
            case 4: return openParen;
            case 5: return &propertySpec;
            case 6: return closeParen;
            case 7: return &action;
            default: return nullptr;
        }
    }
};

struct ConcurrentAssertionMemberSyntax : public MemberSyntax {
    ConcurrentAssertionStatementSyntax& statement;

    ConcurrentAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ConcurrentAssertionMember, attributes), statement(statement)
    {}

    ConcurrentAssertionMemberSyntax(const ConcurrentAssertionMemberSyntax&) = delete;
    ConcurrentAssertionMemberSyntax& operator=(const ConcurrentAssertionMemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &statement;
            default: return nullptr;
        }
    }
};

struct ImmediateAssertionMemberSyntax : public MemberSyntax {
    ImmediateAssertionStatementSyntax& statement;

    ImmediateAssertionMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement) :
        MemberSyntax(SyntaxKind::ImmediateAssertionMember, attributes), statement(statement)
    {}

    ImmediateAssertionMemberSyntax(const ImmediateAssertionMemberSyntax&) = delete;
    ImmediateAssertionMemberSyntax& operator=(const ImmediateAssertionMemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &statement;
            default: return nullptr;
        }
    }
};

// ----- STATEMENTS -----

struct EmptyStatementSyntax : public StatementSyntax {
    Token semicolon;

    EmptyStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon) :
        StatementSyntax(SyntaxKind::EmptyStatement, label, attributes), semicolon(semicolon)
    {}

    EmptyStatementSyntax(const EmptyStatementSyntax&) = delete;
    EmptyStatementSyntax& operator=(const EmptyStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return semicolon;
            default: return nullptr;
        }
    }
};

struct ConditionalStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token ifKeyword;
    Token openParen;
    ConditionalPredicateSyntax& predicate;
    Token closeParen;
    StatementSyntax& statement;
    ElseClauseSyntax* elseClause;

    ConditionalStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) :
        StatementSyntax(SyntaxKind::ConditionalStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), ifKeyword(ifKeyword), openParen(openParen), predicate(predicate), closeParen(closeParen), statement(statement), elseClause(elseClause)
    {}

    ConditionalStatementSyntax(const ConditionalStatementSyntax&) = delete;
    ConditionalStatementSyntax& operator=(const ConditionalStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return ifKeyword;
            case 4: return openParen;
            case 5: return &predicate;
            case 6: return closeParen;
            case 7: return &statement;
            case 8: return elseClause;
            default: return nullptr;
        }
    }
};

struct CaseItemSyntax : public SyntaxNode {

    CaseItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct DefaultCaseItemSyntax : public CaseItemSyntax {
    Token defaultKeyword;
    Token colon;
    SyntaxNode& clause;

    DefaultCaseItemSyntax(Token defaultKeyword, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::DefaultCaseItem), defaultKeyword(defaultKeyword), colon(colon), clause(clause)
    {}

    DefaultCaseItemSyntax(const DefaultCaseItemSyntax&) = delete;
    DefaultCaseItemSyntax& operator=(const DefaultCaseItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return colon;
            case 2: return &clause;
            default: return nullptr;
        }
    }
};

struct PatternCaseItemSyntax : public CaseItemSyntax {
    PatternSyntax& pattern;
    Token tripleAnd;
    ExpressionSyntax* expr;
    Token colon;
    StatementSyntax& statement;

    PatternCaseItemSyntax(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) :
        CaseItemSyntax(SyntaxKind::PatternCaseItem), pattern(pattern), tripleAnd(tripleAnd), expr(expr), colon(colon), statement(statement)
    {}

    PatternCaseItemSyntax(const PatternCaseItemSyntax&) = delete;
    PatternCaseItemSyntax& operator=(const PatternCaseItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &pattern;
            case 1: return tripleAnd;
            case 2: return expr;
            case 3: return colon;
            case 4: return &statement;
            default: return nullptr;
        }
    }
};

struct StandardCaseItemSyntax : public CaseItemSyntax {
    SeparatedSyntaxList<ExpressionSyntax> expressions;
    Token colon;
    SyntaxNode& clause;

    StandardCaseItemSyntax(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause) :
        CaseItemSyntax(SyntaxKind::StandardCaseItem), expressions(expressions), colon(colon), clause(clause)
    {}

    StandardCaseItemSyntax(const StandardCaseItemSyntax&) = delete;
    StandardCaseItemSyntax& operator=(const StandardCaseItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expressions;
            case 1: return colon;
            case 2: return &clause;
            default: return nullptr;
        }
    }
};

struct CaseStatementSyntax : public StatementSyntax {
    Token uniqueOrPriority;
    Token caseKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    Token matchesOrInside;
    SyntaxList<CaseItemSyntax> items;
    Token endcase;

    CaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase) :
        StatementSyntax(SyntaxKind::CaseStatement, label, attributes), uniqueOrPriority(uniqueOrPriority), caseKeyword(caseKeyword), openParen(openParen), expr(expr), closeParen(closeParen), matchesOrInside(matchesOrInside), items(items), endcase(endcase)
    {}

    CaseStatementSyntax(const CaseStatementSyntax&) = delete;
    CaseStatementSyntax& operator=(const CaseStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return uniqueOrPriority;
            case 3: return caseKeyword;
            case 4: return openParen;
            case 5: return &expr;
            case 6: return closeParen;
            case 7: return matchesOrInside;
            case 8: return &items;
            case 9: return endcase;
            default: return nullptr;
        }
    }
};

struct ForeverStatementSyntax : public StatementSyntax {
    Token foreverKeyword;
    StatementSyntax& statement;

    ForeverStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeverStatement, label, attributes), foreverKeyword(foreverKeyword), statement(statement)
    {}

    ForeverStatementSyntax(const ForeverStatementSyntax&) = delete;
    ForeverStatementSyntax& operator=(const ForeverStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return foreverKeyword;
            case 3: return &statement;
            default: return nullptr;
        }
    }
};

struct LoopStatementSyntax : public StatementSyntax {
    Token repeatOrWhile;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    StatementSyntax& statement;

    LoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::LoopStatement, label, attributes), repeatOrWhile(repeatOrWhile), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {}

    LoopStatementSyntax(const LoopStatementSyntax&) = delete;
    LoopStatementSyntax& operator=(const LoopStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return repeatOrWhile;
            case 3: return openParen;
            case 4: return &expr;
            case 5: return closeParen;
            case 6: return &statement;
            default: return nullptr;
        }
    }
};

struct DoWhileStatementSyntax : public StatementSyntax {
    Token doKeyword;
    StatementSyntax& statement;
    Token whileKeyword;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    Token semi;

    DoWhileStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) :
        StatementSyntax(SyntaxKind::DoWhileStatement, label, attributes), doKeyword(doKeyword), statement(statement), whileKeyword(whileKeyword), openParen(openParen), expr(expr), closeParen(closeParen), semi(semi)
    {}

    DoWhileStatementSyntax(const DoWhileStatementSyntax&) = delete;
    DoWhileStatementSyntax& operator=(const DoWhileStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return doKeyword;
            case 3: return &statement;
            case 4: return whileKeyword;
            case 5: return openParen;
            case 6: return &expr;
            case 7: return closeParen;
            case 8: return semi;
            default: return nullptr;
        }
    }
};

struct ForVariableDeclarationSyntax : public SyntaxNode {
    Token varKeyword;
    DataTypeSyntax& type;
    VariableDeclaratorSyntax& declarator;

    ForVariableDeclarationSyntax(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::ForVariableDeclaration), varKeyword(varKeyword), type(type), declarator(declarator)
    {}

    ForVariableDeclarationSyntax(const ForVariableDeclarationSyntax&) = delete;
    ForVariableDeclarationSyntax& operator=(const ForVariableDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return varKeyword;
            case 1: return &type;
            case 2: return &declarator;
            default: return nullptr;
        }
    }
};

struct ForLoopStatementSyntax : public StatementSyntax {
    Token forKeyword;
    Token openParen;
    SeparatedSyntaxList<SyntaxNode> initializers;
    Token semi1;
    ExpressionSyntax& stopExpr;
    Token semi2;
    SeparatedSyntaxList<ExpressionSyntax> steps;
    Token closeParen;
    StatementSyntax& statement;

    ForLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForLoopStatement, label, attributes), forKeyword(forKeyword), openParen(openParen), initializers(initializers), semi1(semi1), stopExpr(stopExpr), semi2(semi2), steps(steps), closeParen(closeParen), statement(statement)
    {}

    ForLoopStatementSyntax(const ForLoopStatementSyntax&) = delete;
    ForLoopStatementSyntax& operator=(const ForLoopStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return forKeyword;
            case 3: return openParen;
            case 4: return &initializers;
            case 5: return semi1;
            case 6: return &stopExpr;
            case 7: return semi2;
            case 8: return &steps;
            case 9: return closeParen;
            case 10: return &statement;
            default: return nullptr;
        }
    }
};

struct ForeachLoopListSyntax : public SyntaxNode {
    Token openParen;
    NameSyntax& arrayName;
    Token openBracket;
    SeparatedSyntaxList<NameSyntax> loopVariables;
    Token closeBracket;
    Token closeParen;

    ForeachLoopListSyntax(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen) :
        SyntaxNode(SyntaxKind::ForeachLoopList), openParen(openParen), arrayName(arrayName), openBracket(openBracket), loopVariables(loopVariables), closeBracket(closeBracket), closeParen(closeParen)
    {}

    ForeachLoopListSyntax(const ForeachLoopListSyntax&) = delete;
    ForeachLoopListSyntax& operator=(const ForeachLoopListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &arrayName;
            case 2: return openBracket;
            case 3: return &loopVariables;
            case 4: return closeBracket;
            case 5: return closeParen;
            default: return nullptr;
        }
    }
};

struct ForeachLoopStatementSyntax : public StatementSyntax {
    Token keyword;
    ForeachLoopListSyntax& loopList;
    StatementSyntax& statement;

    ForeachLoopStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::ForeachLoopStatement, label, attributes), keyword(keyword), loopList(loopList), statement(statement)
    {}

    ForeachLoopStatementSyntax(const ForeachLoopStatementSyntax&) = delete;
    ForeachLoopStatementSyntax& operator=(const ForeachLoopStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &loopList;
            case 4: return &statement;
            default: return nullptr;
        }
    }
};

struct ReturnStatementSyntax : public StatementSyntax {
    Token returnKeyword;
    ExpressionSyntax* returnValue;
    Token semi;

    ReturnStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) :
        StatementSyntax(SyntaxKind::ReturnStatement, label, attributes), returnKeyword(returnKeyword), returnValue(returnValue), semi(semi)
    {}

    ReturnStatementSyntax(const ReturnStatementSyntax&) = delete;
    ReturnStatementSyntax& operator=(const ReturnStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return returnKeyword;
            case 3: return returnValue;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct JumpStatementSyntax : public StatementSyntax {
    Token breakOrContinue;
    Token semi;

    JumpStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi) :
        StatementSyntax(SyntaxKind::JumpStatement, label, attributes), breakOrContinue(breakOrContinue), semi(semi)
    {}

    JumpStatementSyntax(const JumpStatementSyntax&) = delete;
    JumpStatementSyntax& operator=(const JumpStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return breakOrContinue;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct TimingControlStatementSyntax : public StatementSyntax {
    TimingControlSyntax& timingControl;
    StatementSyntax& statement;

    TimingControlStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::TimingControlStatement, label, attributes), timingControl(timingControl), statement(statement)
    {}

    TimingControlStatementSyntax(const TimingControlStatementSyntax&) = delete;
    TimingControlStatementSyntax& operator=(const TimingControlStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return &timingControl;
            case 3: return &statement;
            default: return nullptr;
        }
    }
};

struct ExpressionStatementSyntax : public StatementSyntax {
    ExpressionSyntax& expr;
    Token semi;

    ExpressionStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi) :
        StatementSyntax(SyntaxKind::ExpressionStatement, label, attributes), expr(expr), semi(semi)
    {}

    ExpressionStatementSyntax(const ExpressionStatementSyntax&) = delete;
    ExpressionStatementSyntax& operator=(const ExpressionStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return &expr;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralAssignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax& lvalue;
    Token equals;
    ExpressionSyntax& value;
    Token semi;

    ProceduralAssignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), lvalue(lvalue), equals(equals), value(value), semi(semi)
    {}

    ProceduralAssignStatementSyntax(const ProceduralAssignStatementSyntax&) = delete;
    ProceduralAssignStatementSyntax& operator=(const ProceduralAssignStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &lvalue;
            case 4: return equals;
            case 5: return &value;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralDeassignStatementSyntax : public StatementSyntax {
    Token keyword;
    ExpressionSyntax& variable;
    Token semi;

    ProceduralDeassignStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi) :
        StatementSyntax(kind, label, attributes), keyword(keyword), variable(variable), semi(semi)
    {}

    ProceduralDeassignStatementSyntax(const ProceduralDeassignStatementSyntax&) = delete;
    ProceduralDeassignStatementSyntax& operator=(const ProceduralDeassignStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return keyword;
            case 3: return &variable;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct DisableStatementSyntax : public StatementSyntax {
    Token disable;
    NameSyntax& name;
    Token semi;

    DisableStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi) :
        StatementSyntax(SyntaxKind::DisableStatement, label, attributes), disable(disable), name(name), semi(semi)
    {}

    DisableStatementSyntax(const DisableStatementSyntax&) = delete;
    DisableStatementSyntax& operator=(const DisableStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return &name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct DisableForkStatementSyntax : public StatementSyntax {
    Token disable;
    Token fork;
    Token semi;

    DisableForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::DisableForkStatement, label, attributes), disable(disable), fork(fork), semi(semi)
    {}

    DisableForkStatementSyntax(const DisableForkStatementSyntax&) = delete;
    DisableForkStatementSyntax& operator=(const DisableForkStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return disable;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct NamedBlockClauseSyntax : public SyntaxNode {
    Token colon;
    Token name;

    NamedBlockClauseSyntax(Token colon, Token name) :
        SyntaxNode(SyntaxKind::NamedBlockClause), colon(colon), name(name)
    {}

    NamedBlockClauseSyntax(const NamedBlockClauseSyntax&) = delete;
    NamedBlockClauseSyntax& operator=(const NamedBlockClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return colon;
            case 1: return name;
            default: return nullptr;
        }
    }
};

struct BlockStatementSyntax : public StatementSyntax {
    Token begin;
    NamedBlockClauseSyntax* blockName;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    BlockStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        StatementSyntax(kind, label, attributes), begin(begin), blockName(blockName), items(items), end(end), endBlockName(endBlockName)
    {}

    BlockStatementSyntax(const BlockStatementSyntax&) = delete;
    BlockStatementSyntax& operator=(const BlockStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return begin;
            case 3: return blockName;
            case 4: return &items;
            case 5: return end;
            case 6: return endBlockName;
            default: return nullptr;
        }
    }
};

struct WaitStatementSyntax : public StatementSyntax {
    Token wait;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;
    StatementSyntax& statement;

    WaitStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) :
        StatementSyntax(SyntaxKind::WaitStatement, label, attributes), wait(wait), openParen(openParen), expr(expr), closeParen(closeParen), statement(statement)
    {}

    WaitStatementSyntax(const WaitStatementSyntax&) = delete;
    WaitStatementSyntax& operator=(const WaitStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return openParen;
            case 4: return &expr;
            case 5: return closeParen;
            case 6: return &statement;
            default: return nullptr;
        }
    }
};

struct WaitForkStatementSyntax : public StatementSyntax {
    Token wait;
    Token fork;
    Token semi;

    WaitForkStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi) :
        StatementSyntax(SyntaxKind::WaitForkStatement, label, attributes), wait(wait), fork(fork), semi(semi)
    {}

    WaitForkStatementSyntax(const WaitForkStatementSyntax&) = delete;
    WaitForkStatementSyntax& operator=(const WaitForkStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait;
            case 3: return fork;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct WaitOrderStatementSyntax : public StatementSyntax {
    Token wait_order;
    Token openParen;
    SeparatedSyntaxList<NameSyntax> names;
    Token closeParen;
    ActionBlockSyntax& action;

    WaitOrderStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action) :
        StatementSyntax(SyntaxKind::WaitOrderStatement, label, attributes), wait_order(wait_order), openParen(openParen), names(names), closeParen(closeParen), action(action)
    {}

    WaitOrderStatementSyntax(const WaitOrderStatementSyntax&) = delete;
    WaitOrderStatementSyntax& operator=(const WaitOrderStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return wait_order;
            case 3: return openParen;
            case 4: return &names;
            case 5: return closeParen;
            case 6: return &action;
            default: return nullptr;
        }
    }
};

struct RandCaseItemSyntax : public SyntaxNode {
    ExpressionSyntax& expr;
    Token colon;
    StatementSyntax& statement;

    RandCaseItemSyntax(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) :
        SyntaxNode(SyntaxKind::RandCaseItem), expr(expr), colon(colon), statement(statement)
    {}

    RandCaseItemSyntax(const RandCaseItemSyntax&) = delete;
    RandCaseItemSyntax& operator=(const RandCaseItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return colon;
            case 2: return &statement;
            default: return nullptr;
        }
    }
};

struct RandCaseStatementSyntax : public StatementSyntax {
    Token randCase;
    SyntaxList<RandCaseItemSyntax> items;
    Token endCase;

    RandCaseStatementSyntax(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase) :
        StatementSyntax(SyntaxKind::RandCaseStatement, label, attributes), randCase(randCase), items(items), endCase(endCase)
    {}

    RandCaseStatementSyntax(const RandCaseStatementSyntax&) = delete;
    RandCaseStatementSyntax& operator=(const RandCaseStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return randCase;
            case 3: return &items;
            case 4: return endCase;
            default: return nullptr;
        }
    }
};

struct EventTriggerStatementSyntax : public StatementSyntax {
    Token trigger;
    TimingControlSyntax* timing;
    NameSyntax& name;

    EventTriggerStatementSyntax(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) :
        StatementSyntax(kind, label, attributes), trigger(trigger), timing(timing), name(name)
    {}

    EventTriggerStatementSyntax(const EventTriggerStatementSyntax&) = delete;
    EventTriggerStatementSyntax& operator=(const EventTriggerStatementSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return label;
            case 1: return &attributes;
            case 2: return trigger;
            case 3: return timing;
            case 4: return &name;
            default: return nullptr;
        }
    }
};

// ----- MODULES -----

struct PortListSyntax : public SyntaxNode {

    PortListSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct NonAnsiPortSyntax : public SyntaxNode {

    NonAnsiPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct ImplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    ExpressionSyntax& expr;

    ImplicitNonAnsiPortSyntax(ExpressionSyntax& expr) :
        NonAnsiPortSyntax(SyntaxKind::ImplicitNonAnsiPort), expr(expr)
    {}

    ImplicitNonAnsiPortSyntax(const ImplicitNonAnsiPortSyntax&) = delete;
    ImplicitNonAnsiPortSyntax& operator=(const ImplicitNonAnsiPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            default: return nullptr;
        }
    }
};

struct ExplicitNonAnsiPortSyntax : public NonAnsiPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitNonAnsiPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        NonAnsiPortSyntax(SyntaxKind::ExplicitNonAnsiPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    ExplicitNonAnsiPortSyntax(const ExplicitNonAnsiPortSyntax&) = delete;
    ExplicitNonAnsiPortSyntax& operator=(const ExplicitNonAnsiPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct NonAnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<NonAnsiPortSyntax> ports;
    Token closeParen;

    NonAnsiPortListSyntax(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::NonAnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {}

    NonAnsiPortListSyntax(const NonAnsiPortListSyntax&) = delete;
    NonAnsiPortListSyntax& operator=(const NonAnsiPortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct InterfacePortHeaderSyntax : public PortHeaderSyntax {
    Token nameOrKeyword;
    DotMemberClauseSyntax* modport;

    InterfacePortHeaderSyntax(Token nameOrKeyword, DotMemberClauseSyntax* modport) :
        PortHeaderSyntax(SyntaxKind::InterfacePortHeader), nameOrKeyword(nameOrKeyword), modport(modport)
    {}

    InterfacePortHeaderSyntax(const InterfacePortHeaderSyntax&) = delete;
    InterfacePortHeaderSyntax& operator=(const InterfacePortHeaderSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return nameOrKeyword;
            case 1: return modport;
            default: return nullptr;
        }
    }
};

struct VariablePortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token varKeyword;
    DataTypeSyntax& dataType;

    VariablePortHeaderSyntax(Token direction, Token varKeyword, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::VariablePortHeader), direction(direction), varKeyword(varKeyword), dataType(dataType)
    {}

    VariablePortHeaderSyntax(const VariablePortHeaderSyntax&) = delete;
    VariablePortHeaderSyntax& operator=(const VariablePortHeaderSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return direction;
            case 1: return varKeyword;
            case 2: return &dataType;
            default: return nullptr;
        }
    }
};

struct InterconnectPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token interconnect;
    DataTypeSyntax* type;

    InterconnectPortHeaderSyntax(Token direction, Token interconnect, DataTypeSyntax* type) :
        PortHeaderSyntax(SyntaxKind::InterconnectPortHeader), direction(direction), interconnect(interconnect), type(type)
    {}

    InterconnectPortHeaderSyntax(const InterconnectPortHeaderSyntax&) = delete;
    InterconnectPortHeaderSyntax& operator=(const InterconnectPortHeaderSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return direction;
            case 1: return interconnect;
            case 2: return type;
            default: return nullptr;
        }
    }
};

struct NetPortHeaderSyntax : public PortHeaderSyntax {
    Token direction;
    Token netType;
    DataTypeSyntax& dataType;

    NetPortHeaderSyntax(Token direction, Token netType, DataTypeSyntax& dataType) :
        PortHeaderSyntax(SyntaxKind::NetPortHeader), direction(direction), netType(netType), dataType(dataType)
    {}

    NetPortHeaderSyntax(const NetPortHeaderSyntax&) = delete;
    NetPortHeaderSyntax& operator=(const NetPortHeaderSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return direction;
            case 1: return netType;
            case 2: return &dataType;
            default: return nullptr;
        }
    }
};

struct ImplicitAnsiPortSyntax : public MemberSyntax {
    PortHeaderSyntax& header;
    VariableDeclaratorSyntax& declarator;

    ImplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator) :
        MemberSyntax(SyntaxKind::ImplicitAnsiPort, attributes), header(header), declarator(declarator)
    {}

    ImplicitAnsiPortSyntax(const ImplicitAnsiPortSyntax&) = delete;
    ImplicitAnsiPortSyntax& operator=(const ImplicitAnsiPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &declarator;
            default: return nullptr;
        }
    }
};

struct ExplicitAnsiPortSyntax : public MemberSyntax {
    Token direction;
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ExplicitAnsiPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        MemberSyntax(SyntaxKind::ExplicitAnsiPort, attributes), direction(direction), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    ExplicitAnsiPortSyntax(const ExplicitAnsiPortSyntax&) = delete;
    ExplicitAnsiPortSyntax& operator=(const ExplicitAnsiPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return direction;
            case 2: return dot;
            case 3: return name;
            case 4: return openParen;
            case 5: return expr;
            case 6: return closeParen;
            default: return nullptr;
        }
    }
};

struct AnsiPortListSyntax : public PortListSyntax {
    Token openParen;
    SeparatedSyntaxList<MemberSyntax> ports;
    Token closeParen;

    AnsiPortListSyntax(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen) :
        PortListSyntax(SyntaxKind::AnsiPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {}

    AnsiPortListSyntax(const AnsiPortListSyntax&) = delete;
    AnsiPortListSyntax& operator=(const AnsiPortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct WildcardPortListSyntax : public PortListSyntax {
    Token openParen;
    Token dotStar;
    Token closeParen;

    WildcardPortListSyntax(Token openParen, Token dotStar, Token closeParen) :
        PortListSyntax(SyntaxKind::WildcardPortList), openParen(openParen), dotStar(dotStar), closeParen(closeParen)
    {}

    WildcardPortListSyntax(const WildcardPortListSyntax&) = delete;
    WildcardPortListSyntax& operator=(const WildcardPortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return dotStar;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct ParameterPortListSyntax : public SyntaxNode {
    Token hash;
    Token openParen;
    SeparatedSyntaxList<ParameterDeclarationSyntax> declarations;
    Token closeParen;

    ParameterPortListSyntax(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen) :
        SyntaxNode(SyntaxKind::ParameterPortList), hash(hash), openParen(openParen), declarations(declarations), closeParen(closeParen)
    {}

    ParameterPortListSyntax(const ParameterPortListSyntax&) = delete;
    ParameterPortListSyntax& operator=(const ParameterPortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return hash;
            case 1: return openParen;
            case 2: return &declarations;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct ModuleHeaderSyntax : public SyntaxNode {
    Token moduleKeyword;
    Token lifetime;
    Token name;
    SyntaxList<PackageImportDeclarationSyntax> imports;
    ParameterPortListSyntax* parameters;
    PortListSyntax* ports;
    Token semi;

    ModuleHeaderSyntax(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) :
        SyntaxNode(kind), moduleKeyword(moduleKeyword), lifetime(lifetime), name(name), imports(imports), parameters(parameters), ports(ports), semi(semi)
    {}

    ModuleHeaderSyntax(const ModuleHeaderSyntax&) = delete;
    ModuleHeaderSyntax& operator=(const ModuleHeaderSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return moduleKeyword;
            case 1: return lifetime;
            case 2: return name;
            case 3: return &imports;
            case 4: return parameters;
            case 5: return ports;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct ModuleDeclarationSyntax : public MemberSyntax {
    ModuleHeaderSyntax& header;
    SyntaxList<MemberSyntax> members;
    Token endmodule;
    NamedBlockClauseSyntax* blockName;

    ModuleDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName) :
        MemberSyntax(kind, attributes), header(header), members(members), endmodule(endmodule), blockName(blockName)
    {}

    ModuleDeclarationSyntax(const ModuleDeclarationSyntax&) = delete;
    ModuleDeclarationSyntax& operator=(const ModuleDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &header;
            case 2: return &members;
            case 3: return endmodule;
            case 4: return blockName;
            default: return nullptr;
        }
    }
};

struct ExternModuleSyntax : public SyntaxNode {
    Token externKeyword;
    ModuleHeaderSyntax& header;

    ExternModuleSyntax(Token externKeyword, ModuleHeaderSyntax& header) :
        SyntaxNode(SyntaxKind::ExternModule), externKeyword(externKeyword), header(header)
    {}

    ExternModuleSyntax(const ExternModuleSyntax&) = delete;
    ExternModuleSyntax& operator=(const ExternModuleSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return externKeyword;
            case 1: return &header;
            default: return nullptr;
        }
    }
};

// ----- MEMBERS -----

struct EmptyMemberSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token semi;

    EmptyMemberSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi) :
        MemberSyntax(SyntaxKind::EmptyMember, attributes), qualifiers(qualifiers), semi(semi)
    {}

    EmptyMemberSyntax(const EmptyMemberSyntax&) = delete;
    EmptyMemberSyntax& operator=(const EmptyMemberSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct ProceduralBlockSyntax : public MemberSyntax {
    Token keyword;
    StatementSyntax& statement;

    ProceduralBlockSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement) :
        MemberSyntax(kind, attributes), keyword(keyword), statement(statement)
    {}

    ProceduralBlockSyntax(const ProceduralBlockSyntax&) = delete;
    ProceduralBlockSyntax& operator=(const ProceduralBlockSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &statement;
            default: return nullptr;
        }
    }
};

struct GenerateRegionSyntax : public MemberSyntax {
    Token keyword;
    SyntaxList<MemberSyntax> members;
    Token endgenerate;

    GenerateRegionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate) :
        MemberSyntax(SyntaxKind::GenerateRegion, attributes), keyword(keyword), members(members), endgenerate(endgenerate)
    {}

    GenerateRegionSyntax(const GenerateRegionSyntax&) = delete;
    GenerateRegionSyntax& operator=(const GenerateRegionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &members;
            case 3: return endgenerate;
            default: return nullptr;
        }
    }
};

struct LoopGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    Token genvar;
    Token identifier;
    Token equals;
    ExpressionSyntax& initialExpr;
    Token semi1;
    ExpressionSyntax& stopExpr;
    Token semi2;
    ExpressionSyntax& iterationExpr;
    Token closeParen;
    MemberSyntax& block;

    LoopGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) :
        MemberSyntax(SyntaxKind::LoopGenerate, attributes), keyword(keyword), openParen(openParen), genvar(genvar), identifier(identifier), equals(equals), initialExpr(initialExpr), semi1(semi1), stopExpr(stopExpr), semi2(semi2), iterationExpr(iterationExpr), closeParen(closeParen), block(block)
    {}

    LoopGenerateSyntax(const LoopGenerateSyntax&) = delete;
    LoopGenerateSyntax& operator=(const LoopGenerateSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return genvar;
            case 4: return identifier;
            case 5: return equals;
            case 6: return &initialExpr;
            case 7: return semi1;
            case 8: return &stopExpr;
            case 9: return semi2;
            case 10: return &iterationExpr;
            case 11: return closeParen;
            case 12: return &block;
            default: return nullptr;
        }
    }
};

struct IfGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    MemberSyntax& block;
    ElseClauseSyntax* elseClause;

    IfGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) :
        MemberSyntax(SyntaxKind::IfGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), block(block), elseClause(elseClause)
    {}

    IfGenerateSyntax(const IfGenerateSyntax&) = delete;
    IfGenerateSyntax& operator=(const IfGenerateSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return &condition;
            case 4: return closeParen;
            case 5: return &block;
            case 6: return elseClause;
            default: return nullptr;
        }
    }
};

struct CaseGenerateSyntax : public MemberSyntax {
    Token keyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    SyntaxList<CaseItemSyntax> items;
    Token endCase;

    CaseGenerateSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase) :
        MemberSyntax(SyntaxKind::CaseGenerate, attributes), keyword(keyword), openParen(openParen), condition(condition), closeParen(closeParen), items(items), endCase(endCase)
    {}

    CaseGenerateSyntax(const CaseGenerateSyntax&) = delete;
    CaseGenerateSyntax& operator=(const CaseGenerateSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return openParen;
            case 3: return &condition;
            case 4: return closeParen;
            case 5: return &items;
            case 6: return endCase;
            default: return nullptr;
        }
    }
};

struct GenerateBlockSyntax : public MemberSyntax {
    NamedLabelSyntax* label;
    Token begin;
    NamedBlockClauseSyntax* beginName;
    SyntaxList<MemberSyntax> members;
    Token end;
    NamedBlockClauseSyntax* endName;

    GenerateBlockSyntax(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName) :
        MemberSyntax(SyntaxKind::GenerateBlock, attributes), label(label), begin(begin), beginName(beginName), members(members), end(end), endName(endName)
    {}

    GenerateBlockSyntax(const GenerateBlockSyntax&) = delete;
    GenerateBlockSyntax& operator=(const GenerateBlockSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return label;
            case 2: return begin;
            case 3: return beginName;
            case 4: return &members;
            case 5: return end;
            case 6: return endName;
            default: return nullptr;
        }
    }
};

struct DividerClauseSyntax : public SyntaxNode {
    Token divide;
    Token value;

    DividerClauseSyntax(Token divide, Token value) :
        SyntaxNode(SyntaxKind::DividerClause), divide(divide), value(value)
    {}

    DividerClauseSyntax(const DividerClauseSyntax&) = delete;
    DividerClauseSyntax& operator=(const DividerClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return divide;
            case 1: return value;
            default: return nullptr;
        }
    }
};

struct TimeUnitsDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token time;
    DividerClauseSyntax* divider;
    Token semi;

    TimeUnitsDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) :
        MemberSyntax(SyntaxKind::TimeUnitsDeclaration, attributes), keyword(keyword), time(time), divider(divider), semi(semi)
    {}

    TimeUnitsDeclarationSyntax(const TimeUnitsDeclarationSyntax&) = delete;
    TimeUnitsDeclarationSyntax& operator=(const TimeUnitsDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return time;
            case 3: return divider;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct PortConnectionSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;

    PortConnectionSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes) :
        SyntaxNode(kind), attributes(attributes)
    {}

    PortConnectionSyntax(const PortConnectionSyntax&) = delete;
    PortConnectionSyntax& operator=(const PortConnectionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return &attributes;
            default: return nullptr;
        }
    }
};

struct OrderedPortConnectionSyntax : public PortConnectionSyntax {
    ExpressionSyntax& expr;

    OrderedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr) :
        PortConnectionSyntax(SyntaxKind::OrderedPortConnection, attributes), expr(expr)
    {}

    OrderedPortConnectionSyntax(const OrderedPortConnectionSyntax&) = delete;
    OrderedPortConnectionSyntax& operator=(const OrderedPortConnectionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct NamedPortConnectionSyntax : public PortConnectionSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    NamedPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        PortConnectionSyntax(SyntaxKind::NamedPortConnection, attributes), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    NamedPortConnectionSyntax(const NamedPortConnectionSyntax&) = delete;
    NamedPortConnectionSyntax& operator=(const NamedPortConnectionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dot;
            case 2: return name;
            case 3: return openParen;
            case 4: return expr;
            case 5: return closeParen;
            default: return nullptr;
        }
    }
};

struct WildcardPortConnectionSyntax : public PortConnectionSyntax {
    Token dotStar;

    WildcardPortConnectionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar) :
        PortConnectionSyntax(SyntaxKind::WildcardPortConnection, attributes), dotStar(dotStar)
    {}

    WildcardPortConnectionSyntax(const WildcardPortConnectionSyntax&) = delete;
    WildcardPortConnectionSyntax& operator=(const WildcardPortConnectionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return dotStar;
            default: return nullptr;
        }
    }
};

struct HierarchicalInstanceSyntax : public SyntaxNode {
    Token name;
    SyntaxList<VariableDimensionSyntax> dimensions;
    Token openParen;
    SeparatedSyntaxList<PortConnectionSyntax> connections;
    Token closeParen;

    HierarchicalInstanceSyntax(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen) :
        SyntaxNode(SyntaxKind::HierarchicalInstance), name(name), dimensions(dimensions), openParen(openParen), connections(connections), closeParen(closeParen)
    {}

    HierarchicalInstanceSyntax(const HierarchicalInstanceSyntax&) = delete;
    HierarchicalInstanceSyntax& operator=(const HierarchicalInstanceSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return &dimensions;
            case 2: return openParen;
            case 3: return &connections;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct HierarchyInstantiationSyntax : public MemberSyntax {
    Token type;
    ParameterValueAssignmentSyntax* parameters;
    SeparatedSyntaxList<HierarchicalInstanceSyntax> instances;
    Token semi;

    HierarchyInstantiationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi) :
        MemberSyntax(SyntaxKind::HierarchyInstantiation, attributes), type(type), parameters(parameters), instances(instances), semi(semi)
    {}

    HierarchyInstantiationSyntax(const HierarchyInstantiationSyntax&) = delete;
    HierarchyInstantiationSyntax& operator=(const HierarchyInstantiationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return parameters;
            case 3: return &instances;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct FunctionPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token constKeyword;
    Token direction;
    Token varKeyword;
    DataTypeSyntax* dataType;
    VariableDeclaratorSyntax& declarator;

    FunctionPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::FunctionPort), attributes(attributes), constKeyword(constKeyword), direction(direction), varKeyword(varKeyword), dataType(dataType), declarator(declarator)
    {}

    FunctionPortSyntax(const FunctionPortSyntax&) = delete;
    FunctionPortSyntax& operator=(const FunctionPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return constKeyword;
            case 2: return direction;
            case 3: return varKeyword;
            case 4: return dataType;
            case 5: return &declarator;
            default: return nullptr;
        }
    }
};

struct FunctionPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<FunctionPortSyntax> ports;
    Token closeParen;

    FunctionPortListSyntax(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::FunctionPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {}

    FunctionPortListSyntax(const FunctionPortListSyntax&) = delete;
    FunctionPortListSyntax& operator=(const FunctionPortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct FunctionPrototypeSyntax : public SyntaxNode {
    Token keyword;
    Token lifetime;
    DataTypeSyntax* returnType;
    NameSyntax& name;
    FunctionPortListSyntax* portList;

    FunctionPrototypeSyntax(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList) :
        SyntaxNode(SyntaxKind::FunctionPrototype), keyword(keyword), lifetime(lifetime), returnType(returnType), name(name), portList(portList)
    {}

    FunctionPrototypeSyntax(const FunctionPrototypeSyntax&) = delete;
    FunctionPrototypeSyntax& operator=(const FunctionPrototypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return lifetime;
            case 2: return returnType;
            case 3: return &name;
            case 4: return portList;
            default: return nullptr;
        }
    }
};

struct FunctionDeclarationSyntax : public MemberSyntax {
    FunctionPrototypeSyntax& prototype;
    Token semi;
    SyntaxList<SyntaxNode> items;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    FunctionDeclarationSyntax(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, Token semi, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(kind, attributes), prototype(prototype), semi(semi), items(items), end(end), endBlockName(endBlockName)
    {}

    FunctionDeclarationSyntax(const FunctionDeclarationSyntax&) = delete;
    FunctionDeclarationSyntax& operator=(const FunctionDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &prototype;
            case 2: return semi;
            case 3: return &items;
            case 4: return end;
            case 5: return endBlockName;
            default: return nullptr;
        }
    }
};

struct AssertionItemPortSyntax : public SyntaxNode {
    SyntaxList<AttributeInstanceSyntax> attributes;
    Token local;
    Token direction;
    DataTypeSyntax& type;
    VariableDeclaratorSyntax& declarator;

    AssertionItemPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) :
        SyntaxNode(SyntaxKind::AssertionItemPort), attributes(attributes), local(local), direction(direction), type(type), declarator(declarator)
    {}

    AssertionItemPortSyntax(const AssertionItemPortSyntax&) = delete;
    AssertionItemPortSyntax& operator=(const AssertionItemPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return local;
            case 2: return direction;
            case 3: return &type;
            case 4: return &declarator;
            default: return nullptr;
        }
    }
};

struct AssertionItemPortListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<AssertionItemPortSyntax> ports;
    Token closeParen;

    AssertionItemPortListSyntax(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen) :
        SyntaxNode(SyntaxKind::AssertionItemPortList), openParen(openParen), ports(ports), closeParen(closeParen)
    {}

    AssertionItemPortListSyntax(const AssertionItemPortListSyntax&) = delete;
    AssertionItemPortListSyntax& operator=(const AssertionItemPortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ports;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct LetDeclarationSyntax : public MemberSyntax {
    Token let;
    Token identifier;
    AssertionItemPortListSyntax* portList;
    EqualsValueClauseSyntax& initializer;
    Token semi;

    LetDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) :
        MemberSyntax(SyntaxKind::LetDeclaration, attributes), let(let), identifier(identifier), portList(portList), initializer(initializer), semi(semi)
    {}

    LetDeclarationSyntax(const LetDeclarationSyntax&) = delete;
    LetDeclarationSyntax& operator=(const LetDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return let;
            case 2: return identifier;
            case 3: return portList;
            case 4: return &initializer;
            case 5: return semi;
            default: return nullptr;
        }
    }
};

struct PropertyDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<MemberSyntax> assertionVariables;
    PropertySpecSyntax& propertySpec;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    PropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::PropertyDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), propertySpec(propertySpec), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName)
    {}

    PropertyDeclarationSyntax(const PropertyDeclarationSyntax&) = delete;
    PropertyDeclarationSyntax& operator=(const PropertyDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return name;
            case 3: return portList;
            case 4: return semi;
            case 5: return &assertionVariables;
            case 6: return &propertySpec;
            case 7: return optionalSemi;
            case 8: return end;
            case 9: return endBlockName;
            default: return nullptr;
        }
    }
};

struct SequenceDeclarationSyntax : public MemberSyntax {
    Token keyword;
    Token name;
    AssertionItemPortListSyntax* portList;
    Token semi;
    SyntaxList<MemberSyntax> assertionVariables;
    ExpressionSyntax& seqExpr;
    Token optionalSemi;
    Token end;
    NamedBlockClauseSyntax* endBlockName;

    SequenceDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::SequenceDeclaration, attributes), keyword(keyword), name(name), portList(portList), semi(semi), assertionVariables(assertionVariables), seqExpr(seqExpr), optionalSemi(optionalSemi), end(end), endBlockName(endBlockName)
    {}

    SequenceDeclarationSyntax(const SequenceDeclarationSyntax&) = delete;
    SequenceDeclarationSyntax& operator=(const SequenceDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return name;
            case 3: return portList;
            case 4: return semi;
            case 5: return &assertionVariables;
            case 6: return &seqExpr;
            case 7: return optionalSemi;
            case 8: return end;
            case 9: return endBlockName;
            default: return nullptr;
        }
    }
};

struct ExtendsClauseSyntax : public SyntaxNode {
    Token keyword;
    NameSyntax& baseName;
    ArgumentListSyntax* arguments;

    ExtendsClauseSyntax(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) :
        SyntaxNode(SyntaxKind::ExtendsClause), keyword(keyword), baseName(baseName), arguments(arguments)
    {}

    ExtendsClauseSyntax(const ExtendsClauseSyntax&) = delete;
    ExtendsClauseSyntax& operator=(const ExtendsClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &baseName;
            case 2: return arguments;
            default: return nullptr;
        }
    }
};

struct ImplementsClauseSyntax : public SyntaxNode {
    Token keyword;
    SeparatedSyntaxList<NameSyntax> interfaces;

    ImplementsClauseSyntax(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces) :
        SyntaxNode(SyntaxKind::ImplementsClause), keyword(keyword), interfaces(interfaces)
    {}

    ImplementsClauseSyntax(const ImplementsClauseSyntax&) = delete;
    ImplementsClauseSyntax& operator=(const ImplementsClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &interfaces;
            default: return nullptr;
        }
    }
};

struct ClassDeclarationSyntax : public MemberSyntax {
    Token virtualOrInterface;
    Token classKeyword;
    Token lifetime;
    Token name;
    ParameterPortListSyntax* parameters;
    ExtendsClauseSyntax* extendsClause;
    ImplementsClauseSyntax* implementsClause;
    Token semi;
    SyntaxList<MemberSyntax> items;
    Token endClass;
    NamedBlockClauseSyntax* endBlockName;

    ClassDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClassDeclaration, attributes), virtualOrInterface(virtualOrInterface), classKeyword(classKeyword), lifetime(lifetime), name(name), parameters(parameters), extendsClause(extendsClause), implementsClause(implementsClause), semi(semi), items(items), endClass(endClass), endBlockName(endBlockName)
    {}

    ClassDeclarationSyntax(const ClassDeclarationSyntax&) = delete;
    ClassDeclarationSyntax& operator=(const ClassDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return virtualOrInterface;
            case 2: return classKeyword;
            case 3: return lifetime;
            case 4: return name;
            case 5: return parameters;
            case 6: return extendsClause;
            case 7: return implementsClause;
            case 8: return semi;
            case 9: return &items;
            case 10: return endClass;
            case 11: return endBlockName;
            default: return nullptr;
        }
    }
};

struct ClassPropertyDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    MemberSyntax& declaration;

    ClassPropertyDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassPropertyDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {}

    ClassPropertyDeclarationSyntax(const ClassPropertyDeclarationSyntax&) = delete;
    ClassPropertyDeclarationSyntax& operator=(const ClassPropertyDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &declaration;
            default: return nullptr;
        }
    }
};

struct ClassMethodDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionDeclarationSyntax& declaration;

    ClassMethodDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration) :
        MemberSyntax(SyntaxKind::ClassMethodDeclaration, attributes), qualifiers(qualifiers), declaration(declaration)
    {}

    ClassMethodDeclarationSyntax(const ClassMethodDeclarationSyntax&) = delete;
    ClassMethodDeclarationSyntax& operator=(const ClassMethodDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &declaration;
            default: return nullptr;
        }
    }
};

struct ClassMethodPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    FunctionPrototypeSyntax& prototype;
    Token semi;

    ClassMethodPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype, Token semi) :
        MemberSyntax(SyntaxKind::ClassMethodPrototype, attributes), qualifiers(qualifiers), prototype(prototype), semi(semi)
    {}

    ClassMethodPrototypeSyntax(const ClassMethodPrototypeSyntax&) = delete;
    ClassMethodPrototypeSyntax& operator=(const ClassMethodPrototypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return &prototype;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ContinuousAssignSyntax : public MemberSyntax {
    Token assign;
    SeparatedSyntaxList<ExpressionSyntax> assignments;
    Token semi;

    ContinuousAssignSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::ContinuousAssign, attributes), assign(assign), assignments(assignments), semi(semi)
    {}

    ContinuousAssignSyntax(const ContinuousAssignSyntax&) = delete;
    ContinuousAssignSyntax& operator=(const ContinuousAssignSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return assign;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct DefParamAssignmentSyntax : public SyntaxNode {
    NameSyntax& name;
    EqualsValueClauseSyntax* setter;

    DefParamAssignmentSyntax(NameSyntax& name, EqualsValueClauseSyntax* setter) :
        SyntaxNode(SyntaxKind::DefParamAssignment), name(name), setter(setter)
    {}

    DefParamAssignmentSyntax(const DefParamAssignmentSyntax&) = delete;
    DefParamAssignmentSyntax& operator=(const DefParamAssignmentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &name;
            case 1: return setter;
            default: return nullptr;
        }
    }
};

struct DefParamSyntax : public MemberSyntax {
    Token defparam;
    SeparatedSyntaxList<DefParamAssignmentSyntax> assignments;
    Token semi;

    DefParamSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi) :
        MemberSyntax(SyntaxKind::DefParam, attributes), defparam(defparam), assignments(assignments), semi(semi)
    {}

    DefParamSyntax(const DefParamSyntax&) = delete;
    DefParamSyntax& operator=(const DefParamSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return defparam;
            case 2: return &assignments;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ModportClockingPortSyntax : public MemberSyntax {
    Token clocking;
    Token name;

    ModportClockingPortSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token clocking, Token name) :
        MemberSyntax(SyntaxKind::ModportClockingPort, attributes), clocking(clocking), name(name)
    {}

    ModportClockingPortSyntax(const ModportClockingPortSyntax&) = delete;
    ModportClockingPortSyntax& operator=(const ModportClockingPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return clocking;
            case 2: return name;
            default: return nullptr;
        }
    }
};

struct ModportPortSyntax : public SyntaxNode {

    ModportPortSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct ModportNamedPortSyntax : public ModportPortSyntax {
    Token name;

    ModportNamedPortSyntax(Token name) :
        ModportPortSyntax(SyntaxKind::ModportNamedPort), name(name)
    {}

    ModportNamedPortSyntax(const ModportNamedPortSyntax&) = delete;
    ModportNamedPortSyntax& operator=(const ModportNamedPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            default: return nullptr;
        }
    }
};

struct ModportExplicitPortSyntax : public ModportPortSyntax {
    Token dot;
    Token name;
    Token openParen;
    ExpressionSyntax* expr;
    Token closeParen;

    ModportExplicitPortSyntax(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) :
        ModportPortSyntax(SyntaxKind::ModportExplicitPort), dot(dot), name(name), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    ModportExplicitPortSyntax(const ModportExplicitPortSyntax&) = delete;
    ModportExplicitPortSyntax& operator=(const ModportExplicitPortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dot;
            case 1: return name;
            case 2: return openParen;
            case 3: return expr;
            case 4: return closeParen;
            default: return nullptr;
        }
    }
};

struct ModportSimplePortListSyntax : public MemberSyntax {
    Token direction;
    SeparatedSyntaxList<ModportPortSyntax> ports;

    ModportSimplePortListSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, SeparatedSyntaxList<ModportPortSyntax> ports) :
        MemberSyntax(SyntaxKind::ModportSimplePortList, attributes), direction(direction), ports(ports)
    {}

    ModportSimplePortListSyntax(const ModportSimplePortListSyntax&) = delete;
    ModportSimplePortListSyntax& operator=(const ModportSimplePortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return direction;
            case 2: return &ports;
            default: return nullptr;
        }
    }
};

struct ModportSubroutinePortSyntax : public ModportPortSyntax {
    FunctionPrototypeSyntax& prototype;

    ModportSubroutinePortSyntax(FunctionPrototypeSyntax& prototype) :
        ModportPortSyntax(SyntaxKind::ModportSubroutinePort), prototype(prototype)
    {}

    ModportSubroutinePortSyntax(const ModportSubroutinePortSyntax&) = delete;
    ModportSubroutinePortSyntax& operator=(const ModportSubroutinePortSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &prototype;
            default: return nullptr;
        }
    }
};

struct ModportSubroutinePortListSyntax : public MemberSyntax {
    Token importExport;
    SeparatedSyntaxList<ModportPortSyntax> ports;

    ModportSubroutinePortListSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token importExport, SeparatedSyntaxList<ModportPortSyntax> ports) :
        MemberSyntax(SyntaxKind::ModportSubroutinePortList, attributes), importExport(importExport), ports(ports)
    {}

    ModportSubroutinePortListSyntax(const ModportSubroutinePortListSyntax&) = delete;
    ModportSubroutinePortListSyntax& operator=(const ModportSubroutinePortListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return importExport;
            case 2: return &ports;
            default: return nullptr;
        }
    }
};

struct ModportItemSyntax : public SyntaxNode {
    Token name;
    AnsiPortListSyntax& ports;

    ModportItemSyntax(Token name, AnsiPortListSyntax& ports) :
        SyntaxNode(SyntaxKind::ModportItem), name(name), ports(ports)
    {}

    ModportItemSyntax(const ModportItemSyntax&) = delete;
    ModportItemSyntax& operator=(const ModportItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return &ports;
            default: return nullptr;
        }
    }
};

struct ModportDeclarationSyntax : public MemberSyntax {
    Token keyword;
    SeparatedSyntaxList<ModportItemSyntax> items;
    Token semi;

    ModportDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi) :
        MemberSyntax(SyntaxKind::ModportDeclaration, attributes), keyword(keyword), items(items), semi(semi)
    {}

    ModportDeclarationSyntax(const ModportDeclarationSyntax&) = delete;
    ModportDeclarationSyntax& operator=(const ModportDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return &items;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct ClockingSkewSyntax : public SyntaxNode {
    Token edge;
    Token hash;
    ExpressionSyntax* value;

    ClockingSkewSyntax(Token edge, Token hash, ExpressionSyntax* value) :
        SyntaxNode(SyntaxKind::ClockingSkew), edge(edge), hash(hash), value(value)
    {}

    ClockingSkewSyntax(const ClockingSkewSyntax&) = delete;
    ClockingSkewSyntax& operator=(const ClockingSkewSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return edge;
            case 1: return hash;
            case 2: return value;
            default: return nullptr;
        }
    }
};

struct ClockingDirectionSyntax : public SyntaxNode {
    Token input;
    ClockingSkewSyntax* inputSkew;
    Token output;
    ClockingSkewSyntax* ouputSkew;
    Token inout;

    ClockingDirectionSyntax(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) :
        SyntaxNode(SyntaxKind::ClockingDirection), input(input), inputSkew(inputSkew), output(output), ouputSkew(ouputSkew), inout(inout)
    {}

    ClockingDirectionSyntax(const ClockingDirectionSyntax&) = delete;
    ClockingDirectionSyntax& operator=(const ClockingDirectionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return input;
            case 1: return inputSkew;
            case 2: return output;
            case 3: return ouputSkew;
            case 4: return inout;
            default: return nullptr;
        }
    }
};

struct ClockingItemSyntax : public SyntaxNode {
    Token defaultKeyword;
    ClockingDirectionSyntax* direction;
    SeparatedSyntaxList<AttributeSpecSyntax> assignments;
    Token semi;
    MemberSyntax* declaration;

    ClockingItemSyntax(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration) :
        SyntaxNode(SyntaxKind::ClockingItem), defaultKeyword(defaultKeyword), direction(direction), assignments(assignments), semi(semi), declaration(declaration)
    {}

    ClockingItemSyntax(const ClockingItemSyntax&) = delete;
    ClockingItemSyntax& operator=(const ClockingItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return direction;
            case 2: return &assignments;
            case 3: return semi;
            case 4: return declaration;
            default: return nullptr;
        }
    }
};

struct ClockingDeclarationSyntax : public MemberSyntax {
    Token globalOrDefault;
    Token clocking;
    Token blockName;
    Token at;
    ParenthesizedEventExpressionSyntax* event;
    Token eventIdentifier;
    Token semi;
    SyntaxList<ClockingItemSyntax> items;
    Token endClocking;
    NamedBlockClauseSyntax* endBlockName;

    ClockingDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::ClockingDeclaration, attributes), globalOrDefault(globalOrDefault), clocking(clocking), blockName(blockName), at(at), event(event), eventIdentifier(eventIdentifier), semi(semi), items(items), endClocking(endClocking), endBlockName(endBlockName)
    {}

    ClockingDeclarationSyntax(const ClockingDeclarationSyntax&) = delete;
    ClockingDeclarationSyntax& operator=(const ClockingDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return globalOrDefault;
            case 2: return clocking;
            case 3: return blockName;
            case 4: return at;
            case 5: return event;
            case 6: return eventIdentifier;
            case 7: return semi;
            case 8: return &items;
            case 9: return endClocking;
            case 10: return endBlockName;
            default: return nullptr;
        }
    }
};

struct DPIImportExportSyntax : public MemberSyntax {
    Token keyword;
    Token stringLiteral;
    Token property;
    Token name;
    Token equals;
    FunctionPrototypeSyntax& method;
    Token semi;

    DPIImportExportSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method, Token semi) :
        MemberSyntax(SyntaxKind::DPIImportExport, attributes), keyword(keyword), stringLiteral(stringLiteral), property(property), name(name), equals(equals), method(method), semi(semi)
    {}

    DPIImportExportSyntax(const DPIImportExportSyntax&) = delete;
    DPIImportExportSyntax& operator=(const DPIImportExportSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return keyword;
            case 2: return stringLiteral;
            case 3: return property;
            case 4: return name;
            case 5: return equals;
            case 6: return &method;
            case 7: return semi;
            default: return nullptr;
        }
    }
};

// ----- CONSTRAINTS -----

struct ConstraintItemSyntax : public SyntaxNode {

    ConstraintItemSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct DistWeightSyntax : public SyntaxNode {
    Token op;
    ExpressionSyntax& expr;

    DistWeightSyntax(Token op, ExpressionSyntax& expr) :
        SyntaxNode(SyntaxKind::DistWeight), op(op), expr(expr)
    {}

    DistWeightSyntax(const DistWeightSyntax&) = delete;
    DistWeightSyntax& operator=(const DistWeightSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return op;
            case 1: return &expr;
            default: return nullptr;
        }
    }
};

struct DistItemSyntax : public SyntaxNode {
    ExpressionSyntax& range;
    DistWeightSyntax* weight;

    DistItemSyntax(ExpressionSyntax& range, DistWeightSyntax* weight) :
        SyntaxNode(SyntaxKind::DistItem), range(range), weight(weight)
    {}

    DistItemSyntax(const DistItemSyntax&) = delete;
    DistItemSyntax& operator=(const DistItemSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &range;
            case 1: return weight;
            default: return nullptr;
        }
    }
};

struct DistConstraintListSyntax : public SyntaxNode {
    Token dist;
    Token openBrace;
    SeparatedSyntaxList<DistItemSyntax> items;
    Token closeBrace;

    DistConstraintListSyntax(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace) :
        SyntaxNode(SyntaxKind::DistConstraintList), dist(dist), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {}

    DistConstraintListSyntax(const DistConstraintListSyntax&) = delete;
    DistConstraintListSyntax& operator=(const DistConstraintListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return dist;
            case 1: return openBrace;
            case 2: return &items;
            case 3: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ExpressionOrDistSyntax : public ExpressionSyntax {
    ExpressionSyntax& expr;
    DistConstraintListSyntax& distribution;

    ExpressionOrDistSyntax(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) :
        ExpressionSyntax(SyntaxKind::ExpressionOrDist), expr(expr), distribution(distribution)
    {}

    ExpressionOrDistSyntax(const ExpressionOrDistSyntax&) = delete;
    ExpressionOrDistSyntax& operator=(const ExpressionOrDistSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return &distribution;
            default: return nullptr;
        }
    }
};

struct ExpressionConstraintSyntax : public ConstraintItemSyntax {
    Token soft;
    ExpressionSyntax& expr;
    Token semi;

    ExpressionConstraintSyntax(Token soft, ExpressionSyntax& expr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::ExpressionConstraint), soft(soft), expr(expr), semi(semi)
    {}

    ExpressionConstraintSyntax(const ExpressionConstraintSyntax&) = delete;
    ExpressionConstraintSyntax& operator=(const ExpressionConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return soft;
            case 1: return &expr;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct UniquenessConstraintSyntax : public ConstraintItemSyntax {
    Token unique;
    OpenRangeListSyntax& ranges;
    Token semi;

    UniquenessConstraintSyntax(Token unique, OpenRangeListSyntax& ranges, Token semi) :
        ConstraintItemSyntax(SyntaxKind::UniquenessConstraint), unique(unique), ranges(ranges), semi(semi)
    {}

    UniquenessConstraintSyntax(const UniquenessConstraintSyntax&) = delete;
    UniquenessConstraintSyntax& operator=(const UniquenessConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return unique;
            case 1: return &ranges;
            case 2: return semi;
            default: return nullptr;
        }
    }
};

struct ImplicationConstraintSyntax : public ConstraintItemSyntax {
    ExpressionSyntax& left;
    Token arrow;
    ConstraintItemSyntax& constraints;

    ImplicationConstraintSyntax(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::ImplicationConstraint), left(left), arrow(arrow), constraints(constraints)
    {}

    ImplicationConstraintSyntax(const ImplicationConstraintSyntax&) = delete;
    ImplicationConstraintSyntax& operator=(const ImplicationConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return arrow;
            case 2: return &constraints;
            default: return nullptr;
        }
    }
};

struct ElseConstraintClauseSyntax : public SyntaxNode {
    Token elseKeyword;
    ConstraintItemSyntax& constraints;

    ElseConstraintClauseSyntax(Token elseKeyword, ConstraintItemSyntax& constraints) :
        SyntaxNode(SyntaxKind::ElseConstraintClause), elseKeyword(elseKeyword), constraints(constraints)
    {}

    ElseConstraintClauseSyntax(const ElseConstraintClauseSyntax&) = delete;
    ElseConstraintClauseSyntax& operator=(const ElseConstraintClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return elseKeyword;
            case 1: return &constraints;
            default: return nullptr;
        }
    }
};

struct ConditionalConstraintSyntax : public ConstraintItemSyntax {
    Token ifKeyword;
    Token openParen;
    ExpressionSyntax& condition;
    Token closeParen;
    ConstraintItemSyntax& constraints;
    ElseConstraintClauseSyntax* elseClause;

    ConditionalConstraintSyntax(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) :
        ConstraintItemSyntax(SyntaxKind::ConditionalConstraint), ifKeyword(ifKeyword), openParen(openParen), condition(condition), closeParen(closeParen), constraints(constraints), elseClause(elseClause)
    {}

    ConditionalConstraintSyntax(const ConditionalConstraintSyntax&) = delete;
    ConditionalConstraintSyntax& operator=(const ConditionalConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return ifKeyword;
            case 1: return openParen;
            case 2: return &condition;
            case 3: return closeParen;
            case 4: return &constraints;
            case 5: return elseClause;
            default: return nullptr;
        }
    }
};

struct LoopConstraintSyntax : public ConstraintItemSyntax {
    Token foreachKeyword;
    ForeachLoopListSyntax& loopList;
    ConstraintItemSyntax& constraints;

    LoopConstraintSyntax(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) :
        ConstraintItemSyntax(SyntaxKind::LoopConstraint), foreachKeyword(foreachKeyword), loopList(loopList), constraints(constraints)
    {}

    LoopConstraintSyntax(const LoopConstraintSyntax&) = delete;
    LoopConstraintSyntax& operator=(const LoopConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return foreachKeyword;
            case 1: return &loopList;
            case 2: return &constraints;
            default: return nullptr;
        }
    }
};

struct DisableConstraintSyntax : public ConstraintItemSyntax {
    Token disable;
    Token soft;
    NameSyntax& name;
    Token semi;

    DisableConstraintSyntax(Token disable, Token soft, NameSyntax& name, Token semi) :
        ConstraintItemSyntax(SyntaxKind::DisableConstraint), disable(disable), soft(soft), name(name), semi(semi)
    {}

    DisableConstraintSyntax(const DisableConstraintSyntax&) = delete;
    DisableConstraintSyntax& operator=(const DisableConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return disable;
            case 1: return soft;
            case 2: return &name;
            case 3: return semi;
            default: return nullptr;
        }
    }
};

struct SolveBeforeConstraintSyntax : public ConstraintItemSyntax {
    Token solve;
    SeparatedSyntaxList<ExpressionSyntax> beforeExpr;
    Token before;
    SeparatedSyntaxList<ExpressionSyntax> afterExpr;
    Token semi;

    SolveBeforeConstraintSyntax(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi) :
        ConstraintItemSyntax(SyntaxKind::SolveBeforeConstraint), solve(solve), beforeExpr(beforeExpr), before(before), afterExpr(afterExpr), semi(semi)
    {}

    SolveBeforeConstraintSyntax(const SolveBeforeConstraintSyntax&) = delete;
    SolveBeforeConstraintSyntax& operator=(const SolveBeforeConstraintSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return solve;
            case 1: return &beforeExpr;
            case 2: return before;
            case 3: return &afterExpr;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ConstraintBlockSyntax : public ConstraintItemSyntax {
    Token openBrace;
    SyntaxList<ConstraintItemSyntax> items;
    Token closeBrace;

    ConstraintBlockSyntax(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace) :
        ConstraintItemSyntax(SyntaxKind::ConstraintBlock), openBrace(openBrace), items(items), closeBrace(closeBrace)
    {}

    ConstraintBlockSyntax(const ConstraintBlockSyntax&) = delete;
    ConstraintBlockSyntax& operator=(const ConstraintBlockSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBrace;
            case 1: return &items;
            case 2: return closeBrace;
            default: return nullptr;
        }
    }
};

struct ConstraintPrototypeSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    Token semi;

    ConstraintPrototypeSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi) :
        MemberSyntax(SyntaxKind::ConstraintPrototype, attributes), qualifiers(qualifiers), keyword(keyword), name(name), semi(semi)
    {}

    ConstraintPrototypeSyntax(const ConstraintPrototypeSyntax&) = delete;
    ConstraintPrototypeSyntax& operator=(const ConstraintPrototypeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return semi;
            default: return nullptr;
        }
    }
};

struct ConstraintDeclarationSyntax : public MemberSyntax {
    TokenList qualifiers;
    Token keyword;
    Token name;
    ConstraintBlockSyntax& block;

    ConstraintDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) :
        MemberSyntax(SyntaxKind::ConstraintDeclaration, attributes), qualifiers(qualifiers), keyword(keyword), name(name), block(block)
    {}

    ConstraintDeclarationSyntax(const ConstraintDeclarationSyntax&) = delete;
    ConstraintDeclarationSyntax& operator=(const ConstraintDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return &qualifiers;
            case 2: return keyword;
            case 3: return name;
            case 4: return &block;
            default: return nullptr;
        }
    }
};

struct WithClauseSyntax : public ExpressionSyntax {
    Token with;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    WithClauseSyntax(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        ExpressionSyntax(SyntaxKind::WithClause), with(with), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    WithClauseSyntax(const WithClauseSyntax&) = delete;
    WithClauseSyntax& operator=(const WithClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return with;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct IdentifierListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<IdentifierNameSyntax> identifiers;
    Token closeParen;

    IdentifierListSyntax(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen) :
        SyntaxNode(SyntaxKind::IdentifierList), openParen(openParen), identifiers(identifiers), closeParen(closeParen)
    {}

    IdentifierListSyntax(const IdentifierListSyntax&) = delete;
    IdentifierListSyntax& operator=(const IdentifierListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &identifiers;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct RandomizeMethodWithClauseSyntax : public ExpressionSyntax {
    Token with;
    IdentifierListSyntax* names;
    ConstraintBlockSyntax& constraints;

    RandomizeMethodWithClauseSyntax(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints) :
        ExpressionSyntax(SyntaxKind::RandomizeMethodWithClause), with(with), names(names), constraints(constraints)
    {}

    RandomizeMethodWithClauseSyntax(const RandomizeMethodWithClauseSyntax&) = delete;
    RandomizeMethodWithClauseSyntax& operator=(const RandomizeMethodWithClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return with;
            case 1: return names;
            case 2: return &constraints;
            default: return nullptr;
        }
    }
};

// ----- COVER GROUPS -----

struct WithFunctionSampleSyntax : public SyntaxNode {
    Token with;
    Token function;
    Token sample;
    AnsiPortListSyntax& portList;

    WithFunctionSampleSyntax(Token with, Token function, Token sample, AnsiPortListSyntax& portList) :
        SyntaxNode(SyntaxKind::WithFunctionSample), with(with), function(function), sample(sample), portList(portList)
    {}

    WithFunctionSampleSyntax(const WithFunctionSampleSyntax&) = delete;
    WithFunctionSampleSyntax& operator=(const WithFunctionSampleSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return with;
            case 1: return function;
            case 2: return sample;
            case 3: return &portList;
            default: return nullptr;
        }
    }
};

struct BlockEventExpressionSyntax : public SyntaxNode {

    BlockEventExpressionSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct BinaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    BlockEventExpressionSyntax& left;
    Token orKeyword;
    BlockEventExpressionSyntax& right;

    BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) :
        BlockEventExpressionSyntax(SyntaxKind::BinaryBlockEventExpression), left(left), orKeyword(orKeyword), right(right)
    {}

    BinaryBlockEventExpressionSyntax(const BinaryBlockEventExpressionSyntax&) = delete;
    BinaryBlockEventExpressionSyntax& operator=(const BinaryBlockEventExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &left;
            case 1: return orKeyword;
            case 2: return &right;
            default: return nullptr;
        }
    }
};

struct PrimaryBlockEventExpressionSyntax : public BlockEventExpressionSyntax {
    Token keyword;
    NameSyntax& name;

    PrimaryBlockEventExpressionSyntax(Token keyword, NameSyntax& name) :
        BlockEventExpressionSyntax(SyntaxKind::PrimaryBlockEventExpression), keyword(keyword), name(name)
    {}

    PrimaryBlockEventExpressionSyntax(const PrimaryBlockEventExpressionSyntax&) = delete;
    PrimaryBlockEventExpressionSyntax& operator=(const PrimaryBlockEventExpressionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return keyword;
            case 1: return &name;
            default: return nullptr;
        }
    }
};

struct BlockCoverageEventSyntax : public SyntaxNode {
    Token atat;
    Token openParen;
    BlockEventExpressionSyntax& expr;
    Token closeParen;

    BlockCoverageEventSyntax(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::BlockCoverageEvent), atat(atat), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    BlockCoverageEventSyntax(const BlockCoverageEventSyntax&) = delete;
    BlockCoverageEventSyntax& operator=(const BlockCoverageEventSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return atat;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct CovergroupDeclarationSyntax : public MemberSyntax {
    Token covergroup;
    Token name;
    AnsiPortListSyntax* portList;
    SyntaxNode* event;
    Token semi;
    SyntaxList<MemberSyntax> members;
    Token endgroup;
    NamedBlockClauseSyntax* endBlockName;

    CovergroupDeclarationSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName) :
        MemberSyntax(SyntaxKind::CovergroupDeclaration, attributes), covergroup(covergroup), name(name), portList(portList), event(event), semi(semi), members(members), endgroup(endgroup), endBlockName(endBlockName)
    {}

    CovergroupDeclarationSyntax(const CovergroupDeclarationSyntax&) = delete;
    CovergroupDeclarationSyntax& operator=(const CovergroupDeclarationSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return covergroup;
            case 2: return name;
            case 3: return portList;
            case 4: return event;
            case 5: return semi;
            case 6: return &members;
            case 7: return endgroup;
            case 8: return endBlockName;
            default: return nullptr;
        }
    }
};

struct CoverageOptionSyntax : public MemberSyntax {
    Token option;
    Token dot;
    Token name;
    Token equals;
    ExpressionSyntax& expr;
    Token semi;

    CoverageOptionSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) :
        MemberSyntax(SyntaxKind::CoverageOption, attributes), option(option), dot(dot), name(name), equals(equals), expr(expr), semi(semi)
    {}

    CoverageOptionSyntax(const CoverageOptionSyntax&) = delete;
    CoverageOptionSyntax& operator=(const CoverageOptionSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return option;
            case 2: return dot;
            case 3: return name;
            case 4: return equals;
            case 5: return &expr;
            case 6: return semi;
            default: return nullptr;
        }
    }
};

struct CoverpointSyntax : public MemberSyntax {
    DataTypeSyntax* type;
    NamedLabelSyntax* label;
    Token coverpoint;
    ExpressionSyntax& expr;
    Token openBrace;
    SyntaxList<MemberSyntax> members;
    Token closeBrace;
    Token emptySemi;

    CoverpointSyntax(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi) :
        MemberSyntax(SyntaxKind::Coverpoint, attributes), type(type), label(label), coverpoint(coverpoint), expr(expr), openBrace(openBrace), members(members), closeBrace(closeBrace), emptySemi(emptySemi)
    {}

    CoverpointSyntax(const CoverpointSyntax&) = delete;
    CoverpointSyntax& operator=(const CoverpointSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return type;
            case 2: return label;
            case 3: return coverpoint;
            case 4: return &expr;
            case 5: return openBrace;
            case 6: return &members;
            case 7: return closeBrace;
            case 8: return emptySemi;
            default: return nullptr;
        }
    }
};

struct CoverageBinInitializerSyntax : public SyntaxNode {

    CoverageBinInitializerSyntax(SyntaxKind kind) :
        SyntaxNode(kind)
    {}

    static bool isKind(SyntaxKind kind);
};

struct DefaultCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    Token defaultKeyword;
    Token sequenceKeyword;

    DefaultCoverageBinInitializerSyntax(Token defaultKeyword, Token sequenceKeyword) :
        CoverageBinInitializerSyntax(SyntaxKind::DefaultCoverageBinInitializer), defaultKeyword(defaultKeyword), sequenceKeyword(sequenceKeyword)
    {}

    DefaultCoverageBinInitializerSyntax(const DefaultCoverageBinInitializerSyntax&) = delete;
    DefaultCoverageBinInitializerSyntax& operator=(const DefaultCoverageBinInitializerSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return defaultKeyword;
            case 1: return sequenceKeyword;
            default: return nullptr;
        }
    }
};

struct ExpressionCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    ExpressionSyntax& expr;
    WithClauseSyntax* withClause;

    ExpressionCoverageBinInitializerSyntax(ExpressionSyntax& expr, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::ExpressionCoverageBinInitializer), expr(expr), withClause(withClause)
    {}

    ExpressionCoverageBinInitializerSyntax(const ExpressionCoverageBinInitializerSyntax&) = delete;
    ExpressionCoverageBinInitializerSyntax& operator=(const ExpressionCoverageBinInitializerSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &expr;
            case 1: return withClause;
            default: return nullptr;
        }
    }
};

struct RangeCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    OpenRangeListSyntax& ranges;
    WithClauseSyntax* withClause;

    RangeCoverageBinInitializerSyntax(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::RangeCoverageBinInitializer), ranges(ranges), withClause(withClause)
    {}

    RangeCoverageBinInitializerSyntax(const RangeCoverageBinInitializerSyntax&) = delete;
    RangeCoverageBinInitializerSyntax& operator=(const RangeCoverageBinInitializerSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &ranges;
            case 1: return withClause;
            default: return nullptr;
        }
    }
};

struct TransRepeatRangeSyntax : public SyntaxNode {
    Token openBracket;
    Token specifier;
    SelectorSyntax* selector;
    Token closeBracket;

    TransRepeatRangeSyntax(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) :
        SyntaxNode(SyntaxKind::TransRepeatRange), openBracket(openBracket), specifier(specifier), selector(selector), closeBracket(closeBracket)
    {}

    TransRepeatRangeSyntax(const TransRepeatRangeSyntax&) = delete;
    TransRepeatRangeSyntax& operator=(const TransRepeatRangeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openBracket;
            case 1: return specifier;
            case 2: return selector;
            case 3: return closeBracket;
            default: return nullptr;
        }
    }
};

struct TransRangeSyntax : public SyntaxNode {
    SeparatedSyntaxList<ExpressionSyntax> items;
    TransRepeatRangeSyntax* repeat;

    TransRangeSyntax(SeparatedSyntaxList<ExpressionSyntax> items, TransRepeatRangeSyntax* repeat) :
        SyntaxNode(SyntaxKind::TransRange), items(items), repeat(repeat)
    {}

    TransRangeSyntax(const TransRangeSyntax&) = delete;
    TransRangeSyntax& operator=(const TransRangeSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &items;
            case 1: return repeat;
            default: return nullptr;
        }
    }
};

struct TransSetSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<TransRangeSyntax> ranges;
    Token closeParen;

    TransSetSyntax(Token openParen, SeparatedSyntaxList<TransRangeSyntax> ranges, Token closeParen) :
        SyntaxNode(SyntaxKind::TransSet), openParen(openParen), ranges(ranges), closeParen(closeParen)
    {}

    TransSetSyntax(const TransSetSyntax&) = delete;
    TransSetSyntax& operator=(const TransSetSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &ranges;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct TransListCoverageBinInitializerSyntax : public CoverageBinInitializerSyntax {
    SeparatedSyntaxList<TransSetSyntax> sets;
    WithClauseSyntax* withClause;

    TransListCoverageBinInitializerSyntax(SeparatedSyntaxList<TransSetSyntax> sets, WithClauseSyntax* withClause) :
        CoverageBinInitializerSyntax(SyntaxKind::TransListCoverageBinInitializer), sets(sets), withClause(withClause)
    {}

    TransListCoverageBinInitializerSyntax(const TransListCoverageBinInitializerSyntax&) = delete;
    TransListCoverageBinInitializerSyntax& operator=(const TransListCoverageBinInitializerSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &sets;
            case 1: return withClause;
            default: return nullptr;
        }
    }
};

struct IffClauseSyntax : public SyntaxNode {
    Token iff;
    Token openParen;
    ExpressionSyntax& expr;
    Token closeParen;

    IffClauseSyntax(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) :
        SyntaxNode(SyntaxKind::IffClause), iff(iff), openParen(openParen), expr(expr), closeParen(closeParen)
    {}

    IffClauseSyntax(const IffClauseSyntax&) = delete;
    IffClauseSyntax& operator=(const IffClauseSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return iff;
            case 1: return openParen;
            case 2: return &expr;
            case 3: return closeParen;
            default: return nullptr;
        }
    }
};

struct CoverageBinsSyntax : public MemberSyntax {
    Token wildcard;
    Token keyword;
    Token name;
    ElementSelectSyntax* selector;
    Token equals;
    CoverageBinInitializerSyntax& initializer;
    IffClauseSyntax* iff;
    Token semi;

    CoverageBinsSyntax(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) :
        MemberSyntax(SyntaxKind::CoverageBins, attributes), wildcard(wildcard), keyword(keyword), name(name), selector(selector), equals(equals), initializer(initializer), iff(iff), semi(semi)
    {}

    CoverageBinsSyntax(const CoverageBinsSyntax&) = delete;
    CoverageBinsSyntax& operator=(const CoverageBinsSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &attributes;
            case 1: return wildcard;
            case 2: return keyword;
            case 3: return name;
            case 4: return selector;
            case 5: return equals;
            case 6: return &initializer;
            case 7: return iff;
            case 8: return semi;
            default: return nullptr;
        }
    }
};

// ----- TOP LEVEL -----

struct CompilationUnitSyntax : public SyntaxNode {
    SyntaxList<MemberSyntax> members;
    Token endOfFile;

    CompilationUnitSyntax(SyntaxList<MemberSyntax> members, Token endOfFile) :
        SyntaxNode(SyntaxKind::CompilationUnit), members(members), endOfFile(endOfFile)
    {}

    CompilationUnitSyntax(const CompilationUnitSyntax&) = delete;
    CompilationUnitSyntax& operator=(const CompilationUnitSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &members;
            case 1: return endOfFile;
            default: return nullptr;
        }
    }
};

// ----- DIRECTIVES -----

struct DirectiveSyntax : public SyntaxNode {
    Token directive;

    DirectiveSyntax(SyntaxKind kind, Token directive) :
        SyntaxNode(kind), directive(directive)
    {}

    DirectiveSyntax(const DirectiveSyntax&) = delete;
    DirectiveSyntax& operator=(const DirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override {
        switch (index) {
            case 0: return directive;
            default: return nullptr;
        }
    }
};

struct SimpleDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;

    SimpleDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective)
    {}

    SimpleDirectiveSyntax(const SimpleDirectiveSyntax&) = delete;
    SimpleDirectiveSyntax& operator=(const SimpleDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct IncludeDirectiveSyntax : public DirectiveSyntax {
    Token fileName;
    Token endOfDirective;

    IncludeDirectiveSyntax(Token directive, Token fileName, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::IncludeDirective, directive), fileName(fileName), endOfDirective(endOfDirective)
    {}

    IncludeDirectiveSyntax(const IncludeDirectiveSyntax&) = delete;
    IncludeDirectiveSyntax& operator=(const IncludeDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return fileName;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct ConditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;
    TokenList disabledTokens;

    ConditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token name, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), name(name), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {}

    ConditionalBranchDirectiveSyntax(const ConditionalBranchDirectiveSyntax&) = delete;
    ConditionalBranchDirectiveSyntax& operator=(const ConditionalBranchDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            case 3: return &disabledTokens;
            default: return nullptr;
        }
    }
};

struct UnconditionalBranchDirectiveSyntax : public DirectiveSyntax {
    Token endOfDirective;
    TokenList disabledTokens;

    UnconditionalBranchDirectiveSyntax(SyntaxKind kind, Token directive, Token endOfDirective, TokenList disabledTokens) :
        DirectiveSyntax(kind, directive), endOfDirective(endOfDirective), disabledTokens(disabledTokens)
    {}

    UnconditionalBranchDirectiveSyntax(const UnconditionalBranchDirectiveSyntax&) = delete;
    UnconditionalBranchDirectiveSyntax& operator=(const UnconditionalBranchDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return endOfDirective;
            case 2: return &disabledTokens;
            default: return nullptr;
        }
    }
};

struct MacroArgumentDefaultSyntax : public SyntaxNode {
    Token equals;
    TokenList tokens;

    MacroArgumentDefaultSyntax(Token equals, TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroArgumentDefault), equals(equals), tokens(tokens)
    {}

    MacroArgumentDefaultSyntax(const MacroArgumentDefaultSyntax&) = delete;
    MacroArgumentDefaultSyntax& operator=(const MacroArgumentDefaultSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return equals;
            case 1: return &tokens;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentSyntax : public SyntaxNode {
    Token name;
    MacroArgumentDefaultSyntax* defaultValue;

    MacroFormalArgumentSyntax(Token name, MacroArgumentDefaultSyntax* defaultValue) :
        SyntaxNode(SyntaxKind::MacroFormalArgument), name(name), defaultValue(defaultValue)
    {}

    MacroFormalArgumentSyntax(const MacroFormalArgumentSyntax&) = delete;
    MacroFormalArgumentSyntax& operator=(const MacroFormalArgumentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return name;
            case 1: return defaultValue;
            default: return nullptr;
        }
    }
};

struct MacroFormalArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroFormalArgumentSyntax> args;
    Token closeParen;

    MacroFormalArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroFormalArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {}

    MacroFormalArgumentListSyntax(const MacroFormalArgumentListSyntax&) = delete;
    MacroFormalArgumentListSyntax& operator=(const MacroFormalArgumentListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct DefineDirectiveSyntax : public DirectiveSyntax {
    Token name;
    MacroFormalArgumentListSyntax* formalArguments;
    TokenList body;
    Token endOfDirective;

    DefineDirectiveSyntax(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefineDirective, directive), name(name), formalArguments(formalArguments), body(body), endOfDirective(endOfDirective)
    {}

    DefineDirectiveSyntax(const DefineDirectiveSyntax&) = delete;
    DefineDirectiveSyntax& operator=(const DefineDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return formalArguments;
            case 3: return &body;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct MacroActualArgumentSyntax : public SyntaxNode {
    TokenList tokens;

    MacroActualArgumentSyntax(TokenList tokens) :
        SyntaxNode(SyntaxKind::MacroActualArgument), tokens(tokens)
    {}

    MacroActualArgumentSyntax(const MacroActualArgumentSyntax&) = delete;
    MacroActualArgumentSyntax& operator=(const MacroActualArgumentSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return &tokens;
            default: return nullptr;
        }
    }
};

struct MacroActualArgumentListSyntax : public SyntaxNode {
    Token openParen;
    SeparatedSyntaxList<MacroActualArgumentSyntax> args;
    Token closeParen;

    MacroActualArgumentListSyntax(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen) :
        SyntaxNode(SyntaxKind::MacroActualArgumentList), openParen(openParen), args(args), closeParen(closeParen)
    {}

    MacroActualArgumentListSyntax(const MacroActualArgumentListSyntax&) = delete;
    MacroActualArgumentListSyntax& operator=(const MacroActualArgumentListSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return openParen;
            case 1: return &args;
            case 2: return closeParen;
            default: return nullptr;
        }
    }
};

struct MacroUsageSyntax : public DirectiveSyntax {
    MacroActualArgumentListSyntax* args;

    MacroUsageSyntax(Token directive, MacroActualArgumentListSyntax* args) :
        DirectiveSyntax(SyntaxKind::MacroUsage, directive), args(args)
    {}

    MacroUsageSyntax(const MacroUsageSyntax&) = delete;
    MacroUsageSyntax& operator=(const MacroUsageSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return args;
            default: return nullptr;
        }
    }
};

struct TimescaleDirectiveSyntax : public DirectiveSyntax {
    Token timeUnit;
    Token timeUnitUnit;
    Token slash;
    Token timePrecision;
    Token timePrecisionUnit;
    Token endOfDirective;

    TimescaleDirectiveSyntax(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::TimescaleDirective, directive), timeUnit(timeUnit), timeUnitUnit(timeUnitUnit), slash(slash), timePrecision(timePrecision), timePrecisionUnit(timePrecisionUnit), endOfDirective(endOfDirective)
    {}

    TimescaleDirectiveSyntax(const TimescaleDirectiveSyntax&) = delete;
    TimescaleDirectiveSyntax& operator=(const TimescaleDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return timeUnit;
            case 2: return timeUnitUnit;
            case 3: return slash;
            case 4: return timePrecision;
            case 5: return timePrecisionUnit;
            case 6: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct DefaultNetTypeDirectiveSyntax : public DirectiveSyntax {
    Token netType;
    Token endOfDirective;

    DefaultNetTypeDirectiveSyntax(Token directive, Token netType, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::DefaultNetTypeDirective, directive), netType(netType), endOfDirective(endOfDirective)
    {}

    DefaultNetTypeDirectiveSyntax(const DefaultNetTypeDirectiveSyntax&) = delete;
    DefaultNetTypeDirectiveSyntax& operator=(const DefaultNetTypeDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return netType;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct LineDirectiveSyntax : public DirectiveSyntax {
    Token lineNumber;
    Token fileName;
    Token level;
    Token endOfDirective;

    LineDirectiveSyntax(Token directive, Token lineNumber, Token fileName, Token level, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::LineDirective, directive), lineNumber(lineNumber), fileName(fileName), level(level), endOfDirective(endOfDirective)
    {}

    LineDirectiveSyntax(const LineDirectiveSyntax&) = delete;
    LineDirectiveSyntax& operator=(const LineDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return lineNumber;
            case 2: return fileName;
            case 3: return level;
            case 4: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct UndefDirectiveSyntax : public DirectiveSyntax {
    Token name;
    Token endOfDirective;

    UndefDirectiveSyntax(Token directive, Token name, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::UndefDirective, directive), name(name), endOfDirective(endOfDirective)
    {}

    UndefDirectiveSyntax(const UndefDirectiveSyntax&) = delete;
    UndefDirectiveSyntax& operator=(const UndefDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return name;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

struct BeginKeywordsDirectiveSyntax : public DirectiveSyntax {
    Token versionSpecifier;
    Token endOfDirective;

    BeginKeywordsDirectiveSyntax(Token directive, Token versionSpecifier, Token endOfDirective) :
        DirectiveSyntax(SyntaxKind::BeginKeywordsDirective, directive), versionSpecifier(versionSpecifier), endOfDirective(endOfDirective)
    {}

    BeginKeywordsDirectiveSyntax(const BeginKeywordsDirectiveSyntax&) = delete;
    BeginKeywordsDirectiveSyntax& operator=(const BeginKeywordsDirectiveSyntax&) = delete;

    static bool isKind(SyntaxKind kind);

protected:
    TokenOrSyntax getChild(uint32_t index) const override final {
        switch (index) {
            case 0: return directive;
            case 1: return versionSpecifier;
            case 2: return endOfDirective;
            default: return nullptr;
        }
    }
};

class SyntaxFactory {
public:
    explicit SyntaxFactory(BumpAllocator& alloc) : alloc(alloc) {}

    ActionBlockSyntax& actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause);
    AnsiPortListSyntax& ansiPortList(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen);
    ArgumentListSyntax& argumentList(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen);
    AssertionItemPortListSyntax& assertionItemPortList(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen);
    AssertionItemPortSyntax& assertionItemPort(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator);
    AssignmentPatternExpressionSyntax& assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern);
    AssignmentPatternItemSyntax& assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr);
    AttributeInstanceSyntax& attributeInstance(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen);
    AttributeSpecSyntax& attributeSpec(Token name, EqualsValueClauseSyntax* value);
    BadExpressionSyntax& badExpression(ExpressionSyntax& expr);
    BeginKeywordsDirectiveSyntax& beginKeywordsDirective(Token directive, Token versionSpecifier, Token endOfDirective);
    BinaryBlockEventExpressionSyntax& binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right);
    BinaryEventExpressionSyntax& binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right);
    BinaryExpressionSyntax& binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right);
    BitSelectSyntax& bitSelect(ExpressionSyntax& expr);
    BlockCoverageEventSyntax& blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen);
    BlockStatementSyntax& blockStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName);
    CaseGenerateSyntax& caseGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase);
    CaseStatementSyntax& caseStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase);
    CastExpressionSyntax& castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right);
    ChargeStrengthSyntax& chargeStrength(Token openParen, Token strength, Token closeParen);
    ClassDeclarationSyntax& classDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName);
    ClassMethodDeclarationSyntax& classMethodDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration);
    ClassMethodPrototypeSyntax& classMethodPrototype(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype, Token semi);
    ClassNameSyntax& className(Token identifier, ParameterValueAssignmentSyntax& parameters);
    ClassPropertyDeclarationSyntax& classPropertyDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration);
    ClassScopeSyntax& classScope(NameSyntax& left, Token separator);
    ClockingDeclarationSyntax& clockingDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName);
    ClockingDirectionSyntax& clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout);
    ClockingItemSyntax& clockingItem(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration);
    ClockingSkewSyntax& clockingSkew(Token edge, Token hash, ExpressionSyntax* value);
    ColonExpressionClauseSyntax& colonExpressionClause(Token colon, ExpressionSyntax& expr);
    CompilationUnitSyntax& compilationUnit(SyntaxList<MemberSyntax> members, Token endOfFile);
    ConcatenationExpressionSyntax& concatenationExpression(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace);
    ConcurrentAssertionMemberSyntax& concurrentAssertionMember(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement);
    ConcurrentAssertionStatementSyntax& concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action);
    ConditionalBranchDirectiveSyntax& conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, Token endOfDirective, TokenList disabledTokens);
    ConditionalConstraintSyntax& conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause);
    ConditionalExpressionSyntax& conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right);
    ConditionalPatternSyntax& conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause);
    ConditionalPredicateSyntax& conditionalPredicate(SeparatedSyntaxList<ConditionalPatternSyntax> conditions);
    ConditionalStatementSyntax& conditionalStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause);
    ConstraintBlockSyntax& constraintBlock(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace);
    ConstraintDeclarationSyntax& constraintDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block);
    ConstraintPrototypeSyntax& constraintPrototype(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi);
    ContinuousAssignSyntax& continuousAssign(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi);
    CoverageBinsSyntax& coverageBins(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi);
    CoverageOptionSyntax& coverageOption(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi);
    CovergroupDeclarationSyntax& covergroupDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName);
    CoverpointSyntax& coverpoint(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi);
    DPIImportExportSyntax& dPIImportExport(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method, Token semi);
    DataDeclarationSyntax& dataDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    DefParamAssignmentSyntax& defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax* setter);
    DefParamSyntax& defParam(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi);
    DefaultCaseItemSyntax& defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause);
    DefaultCoverageBinInitializerSyntax& defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword);
    DefaultNetTypeDirectiveSyntax& defaultNetTypeDirective(Token directive, Token netType, Token endOfDirective);
    DeferredAssertionSyntax& deferredAssertion(Token hash, Token zero, Token finalKeyword);
    DefineDirectiveSyntax& defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body, Token endOfDirective);
    DelaySyntax& delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue);
    DisableConstraintSyntax& disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi);
    DisableForkStatementSyntax& disableForkStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi);
    DisableIffSyntax& disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
    DisableStatementSyntax& disableStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi);
    DistConstraintListSyntax& distConstraintList(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace);
    DistItemSyntax& distItem(ExpressionSyntax& range, DistWeightSyntax* weight);
    DistWeightSyntax& distWeight(Token op, ExpressionSyntax& expr);
    DividerClauseSyntax& dividerClause(Token divide, Token value);
    DoWhileStatementSyntax& doWhileStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi);
    DotMemberClauseSyntax& dotMemberClause(Token dot, Token member);
    DriveStrengthSyntax& driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen);
    ElementSelectExpressionSyntax& elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select);
    ElementSelectSyntax& elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket);
    ElseClauseSyntax& elseClause(Token elseKeyword, SyntaxNode& clause);
    ElseConstraintClauseSyntax& elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints);
    EmptyArgumentSyntax& emptyArgument();
    EmptyIdentifierNameSyntax& emptyIdentifierName();
    EmptyMemberSyntax& emptyMember(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi);
    EmptyQueueExpressionSyntax& emptyQueueExpression(Token openBrace, Token closeBrace);
    EmptyStatementSyntax& emptyStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon);
    EnumTypeSyntax& enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions);
    EqualsValueClauseSyntax& equalsValueClause(Token equals, ExpressionSyntax& expr);
    EventControlSyntax& eventControl(Token at, NameSyntax& eventName);
    EventControlWithExpressionSyntax& eventControlWithExpression(Token at, EventExpressionSyntax& expr);
    EventTriggerStatementSyntax& eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name);
    ExplicitAnsiPortSyntax& explicitAnsiPort(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ExplicitNonAnsiPortSyntax& explicitNonAnsiPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ExpressionConstraintSyntax& expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi);
    ExpressionCoverageBinInitializerSyntax& expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause);
    ExpressionOrDistSyntax& expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution);
    ExpressionPatternSyntax& expressionPattern(ExpressionSyntax& expr);
    ExpressionStatementSyntax& expressionStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi);
    ExtendsClauseSyntax& extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments);
    ExternModuleSyntax& externModule(Token externKeyword, ModuleHeaderSyntax& header);
    ForLoopStatementSyntax& forLoopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement);
    ForVariableDeclarationSyntax& forVariableDeclaration(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator);
    ForeachLoopListSyntax& foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen);
    ForeachLoopStatementSyntax& foreachLoopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement);
    ForeverStatementSyntax& foreverStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement);
    ForwardInterfaceClassTypedefDeclarationSyntax& forwardInterfaceClassTypedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi);
    ForwardTypedefDeclarationSyntax& forwardTypedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi);
    FunctionDeclarationSyntax& functionDeclaration(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, Token semi, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName);
    FunctionPortListSyntax& functionPortList(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen);
    FunctionPortSyntax& functionPort(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator);
    FunctionPrototypeSyntax& functionPrototype(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList);
    GenerateBlockSyntax& generateBlock(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName);
    GenerateRegionSyntax& generateRegion(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate);
    GenvarDeclarationSyntax& genvarDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi);
    HierarchicalInstanceSyntax& hierarchicalInstance(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen);
    HierarchyInstantiationSyntax& hierarchyInstantiation(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi);
    IdentifierListSyntax& identifierList(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen);
    IdentifierNameSyntax& identifierName(Token identifier);
    IdentifierSelectNameSyntax& identifierSelectName(Token identifier, SyntaxList<ElementSelectSyntax> selectors);
    IfGenerateSyntax& ifGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause);
    IffClauseSyntax& iffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen);
    ImmediateAssertionMemberSyntax& immediateAssertionMember(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement);
    ImmediateAssertionStatementSyntax& immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action);
    ImplementsClauseSyntax& implementsClause(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces);
    ImplicationConstraintSyntax& implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints);
    ImplicitAnsiPortSyntax& implicitAnsiPort(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator);
    ImplicitEventControlSyntax& implicitEventControl(Token atStar);
    ImplicitNonAnsiPortSyntax& implicitNonAnsiPort(ExpressionSyntax& expr);
    ImplicitTypeSyntax& implicitType(Token signing, SyntaxList<VariableDimensionSyntax> dimensions);
    IncludeDirectiveSyntax& includeDirective(Token directive, Token fileName, Token endOfDirective);
    InsideExpressionSyntax& insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges);
    IntegerTypeSyntax& integerType(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions);
    IntegerVectorExpressionSyntax& integerVectorExpression(Token size, Token base, Token value);
    InterconnectPortHeaderSyntax& interconnectPortHeader(Token direction, Token interconnect, DataTypeSyntax* type);
    InterfacePortHeaderSyntax& interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport);
    InvocationExpressionSyntax& invocationExpression(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments);
    JumpStatementSyntax& jumpStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi);
    KeywordNameSyntax& keywordName(SyntaxKind kind, Token keyword);
    KeywordTypeSyntax& keywordType(SyntaxKind kind, Token keyword);
    LetDeclarationSyntax& letDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi);
    LineDirectiveSyntax& lineDirective(Token directive, Token lineNumber, Token fileName, Token level, Token endOfDirective);
    LiteralExpressionSyntax& literalExpression(SyntaxKind kind, Token literal);
    LoopConstraintSyntax& loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints);
    LoopGenerateSyntax& loopGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block);
    LoopStatementSyntax& loopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
    MacroActualArgumentListSyntax& macroActualArgumentList(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen);
    MacroActualArgumentSyntax& macroActualArgument(TokenList tokens);
    MacroArgumentDefaultSyntax& macroArgumentDefault(Token equals, TokenList tokens);
    MacroFormalArgumentListSyntax& macroFormalArgumentList(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen);
    MacroFormalArgumentSyntax& macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue);
    MacroUsageSyntax& macroUsage(Token directive, MacroActualArgumentListSyntax* args);
    MatchesClauseSyntax& matchesClause(Token matchesKeyword, PatternSyntax& pattern);
    MemberAccessExpressionSyntax& memberAccessExpression(ExpressionSyntax& left, Token dot, Token name);
    MinTypMaxExpressionSyntax& minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max);
    ModportClockingPortSyntax& modportClockingPort(SyntaxList<AttributeInstanceSyntax> attributes, Token clocking, Token name);
    ModportDeclarationSyntax& modportDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi);
    ModportExplicitPortSyntax& modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    ModportItemSyntax& modportItem(Token name, AnsiPortListSyntax& ports);
    ModportNamedPortSyntax& modportNamedPort(Token name);
    ModportSimplePortListSyntax& modportSimplePortList(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, SeparatedSyntaxList<ModportPortSyntax> ports);
    ModportSubroutinePortListSyntax& modportSubroutinePortList(SyntaxList<AttributeInstanceSyntax> attributes, Token importExport, SeparatedSyntaxList<ModportPortSyntax> ports);
    ModportSubroutinePortSyntax& modportSubroutinePort(FunctionPrototypeSyntax& prototype);
    ModuleDeclarationSyntax& moduleDeclaration(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName);
    ModuleHeaderSyntax& moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi);
    MultipleConcatenationExpressionSyntax& multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace);
    NamedArgumentSyntax& namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    NamedBlockClauseSyntax& namedBlockClause(Token colon, Token name);
    NamedLabelSyntax& namedLabel(Token name, Token colon);
    NamedPortConnectionSyntax& namedPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen);
    NamedStructurePatternMemberSyntax& namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern);
    NamedTypeSyntax& namedType(NameSyntax& name);
    NetDeclarationSyntax& netDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    NetPortHeaderSyntax& netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType);
    NewArrayExpressionSyntax& newArrayExpression(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer);
    NewClassExpressionSyntax& newClassExpression(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments);
    NewExpressionSyntax& newExpression(Token newKeyword, ExpressionSyntax& expr);
    NonAnsiPortListSyntax& nonAnsiPortList(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen);
    OpenRangeListSyntax& openRangeList(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace);
    OrderedArgumentSyntax& orderedArgument(ExpressionSyntax& expr);
    OrderedPortConnectionSyntax& orderedPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr);
    OrderedStructurePatternMemberSyntax& orderedStructurePatternMember(PatternSyntax& pattern);
    PackageImportDeclarationSyntax& packageImportDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi);
    PackageImportItemSyntax& packageImportItem(Token package, Token doubleColon, Token item);
    ParameterDeclarationStatementSyntax& parameterDeclarationStatement(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi);
    ParameterDeclarationSyntax& parameterDeclaration(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators);
    ParameterPortListSyntax& parameterPortList(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen);
    ParameterValueAssignmentSyntax& parameterValueAssignment(Token hash, ArgumentListSyntax& parameters);
    ParenImplicitEventControlSyntax& parenImplicitEventControl(Token at, Token openParenStarCloseParen);
    ParenthesizedEventExpressionSyntax& parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen);
    ParenthesizedExpressionSyntax& parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen);
    PatternCaseItemSyntax& patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement);
    PortDeclarationSyntax& portDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    PostfixUnaryExpressionSyntax& postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken);
    PrefixUnaryExpressionSyntax& prefixUnaryExpression(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand);
    PrimaryBlockEventExpressionSyntax& primaryBlockEventExpression(Token keyword, NameSyntax& name);
    ProceduralAssignStatementSyntax& proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi);
    ProceduralBlockSyntax& proceduralBlock(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement);
    ProceduralDeassignStatementSyntax& proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi);
    PropertyDeclarationSyntax& propertyDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
    PropertySpecSyntax& propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr);
    QueueDimensionSpecifierSyntax& queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause);
    RandCaseItemSyntax& randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement);
    RandCaseStatementSyntax& randCaseStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase);
    RandomizeMethodWithClauseSyntax& randomizeMethodWithClause(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints);
    RangeCoverageBinInitializerSyntax& rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause);
    RangeDimensionSpecifierSyntax& rangeDimensionSpecifier(SelectorSyntax& selector);
    RangeSelectSyntax& rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right);
    RepeatedEventControlSyntax& repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl);
    ReplicatedAssignmentPatternSyntax& replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace);
    ReturnStatementSyntax& returnStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi);
    ScopedNameSyntax& scopedName(NameSyntax& left, Token separator, NameSyntax& right);
    SequenceDeclarationSyntax& sequenceDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName);
    ShortcutCycleDelayRangeSyntax& shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket);
    SignalEventExpressionSyntax& signalEventExpression(Token edge, ExpressionSyntax& expr);
    SignedCastExpressionSyntax& signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner);
    SimpleAssignmentPatternSyntax& simpleAssignmentPattern(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace);
    SimpleDirectiveSyntax& simpleDirective(SyntaxKind kind, Token directive, Token endOfDirective);
    SolveBeforeConstraintSyntax& solveBeforeConstraint(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi);
    StandardCaseItemSyntax& standardCaseItem(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause);
    StreamExpressionSyntax& streamExpression(ExpressionSyntax& expression, StreamExpressionWithRange* withRange);
    StreamExpressionWithRange& streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range);
    StreamingConcatenationExpressionSyntax& streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace);
    StructUnionMemberSyntax& structUnionMember(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi);
    StructUnionTypeSyntax& structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions);
    StructurePatternSyntax& structurePattern(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace);
    StructuredAssignmentPatternSyntax& structuredAssignmentPattern(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace);
    TaggedPatternSyntax& taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern);
    TaggedUnionExpressionSyntax& taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr);
    TimeUnitsDeclarationSyntax& timeUnitsDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi);
    TimescaleDirectiveSyntax& timescaleDirective(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit, Token endOfDirective);
    TimingControlExpressionConcatenationSyntax& timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right);
    TimingControlExpressionSyntax& timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr);
    TimingControlStatementSyntax& timingControlStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement);
    TransListCoverageBinInitializerSyntax& transListCoverageBinInitializer(SeparatedSyntaxList<TransSetSyntax> sets, WithClauseSyntax* withClause);
    TransRangeSyntax& transRange(SeparatedSyntaxList<ExpressionSyntax> items, TransRepeatRangeSyntax* repeat);
    TransRepeatRangeSyntax& transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket);
    TransSetSyntax& transSet(Token openParen, SeparatedSyntaxList<TransRangeSyntax> ranges, Token closeParen);
    TypeReferenceSyntax& typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen);
    TypedefDeclarationSyntax& typedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi);
    UnconditionalBranchDirectiveSyntax& unconditionalBranchDirective(SyntaxKind kind, Token directive, Token endOfDirective, TokenList disabledTokens);
    UndefDirectiveSyntax& undefDirective(Token directive, Token name, Token endOfDirective);
    UniquenessConstraintSyntax& uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi);
    VarDataTypeSyntax& varDataType(Token var, DataTypeSyntax& type);
    VariableDeclaratorSyntax& variableDeclarator(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer);
    VariableDimensionSyntax& variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket);
    VariablePatternSyntax& variablePattern(Token dot, Token variableName);
    VariablePortHeaderSyntax& variablePortHeader(Token direction, Token varKeyword, DataTypeSyntax& dataType);
    VirtualInterfaceTypeSyntax& virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport);
    WaitForkStatementSyntax& waitForkStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi);
    WaitOrderStatementSyntax& waitOrderStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action);
    WaitStatementSyntax& waitStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement);
    WildcardDimensionSpecifierSyntax& wildcardDimensionSpecifier(Token star);
    WildcardPatternSyntax& wildcardPattern(Token dotStar);
    WildcardPortConnectionSyntax& wildcardPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar);
    WildcardPortListSyntax& wildcardPortList(Token openParen, Token dotStar, Token closeParen);
    WithClauseSyntax& withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen);
    WithFunctionSampleSyntax& withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList);

private:
    BumpAllocator& alloc;
};

namespace detail {

template<typename TNode, typename TVisitor, typename... Args>
decltype(auto) visitSyntaxNode(TNode* node, TVisitor& visitor, Args&&... args) {
    static constexpr bool isConst = std::is_const_v<TNode>;    switch (node->kind) {
        case SyntaxKind::Unknown: return visitor.visitInvalid(*node);
        case SyntaxKind::List: return visitor.visitList(*node);
        case SyntaxKind::AcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ActionBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ActionBlockSyntax*, ActionBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AddAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AddExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysCombBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysFFBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysLatchBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AndSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AnsiPortListSyntax*, AnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ArgumentListSyntax*, ArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArithmeticShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayAndMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayOrMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayUniqueMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ArrayXorMethod: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AscendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertionItemPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortSyntax*, AssertionItemPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssertionItemPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssertionItemPortListSyntax*, AssertionItemPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentPatternExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternExpressionSyntax*, AssignmentPatternExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssignmentPatternItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const AssignmentPatternItemSyntax*, AssignmentPatternItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AssumePropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AttributeInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeInstanceSyntax*, AttributeInstanceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::AttributeSpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const AttributeSpecSyntax*, AttributeSpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BadExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BadExpressionSyntax*, BadExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BeginKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const BeginKeywordsDirectiveSyntax*, BeginKeywordsDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryBlockEventExpressionSyntax*, BinaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryEventExpressionSyntax*, BinaryEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BinaryXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BitSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const BitSelectSyntax*, BitSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BlockCoverageEvent: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockCoverageEventSyntax*, BlockCoverageEventSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::BlockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ByteType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CHandleType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseGenerateSyntax*, CaseGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const CaseStatementSyntax*, CaseStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const CastExpressionSyntax*, CastExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ChargeStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const ChargeStrengthSyntax*, ChargeStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassDeclarationSyntax*, ClassDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassMethodDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodDeclarationSyntax*, ClassMethodDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassMethodPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassMethodPrototypeSyntax*, ClassMethodPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassNameSyntax*, ClassNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassPropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassPropertyDeclarationSyntax*, ClassPropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClassScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClassScopeSyntax*, ClassScopeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDeclarationSyntax*, ClockingDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingDirection: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingDirectionSyntax*, ClockingDirectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingItemSyntax*, ClockingItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ClockingSkew: return visitor.visit(*static_cast<std::conditional_t<isConst, const ClockingSkewSyntax*, ClockingSkewSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ColonExpressionClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ColonExpressionClauseSyntax*, ColonExpressionClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CompilationUnit: return visitor.visit(*static_cast<std::conditional_t<isConst, const CompilationUnitSyntax*, CompilationUnitSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcatenationExpressionSyntax*, ConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConcurrentAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionMemberSyntax*, ConcurrentAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalConstraintSyntax*, ConditionalConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalExpressionSyntax*, ConditionalExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPatternSyntax*, ConditionalPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalPredicate: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalPredicateSyntax*, ConditionalPredicateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConditionalStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalStatementSyntax*, ConditionalStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintBlockSyntax*, ConstraintBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintDeclarationSyntax*, ConstraintDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstraintPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConstraintPrototypeSyntax*, ConstraintPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ConstructorName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ContinuousAssign: return visitor.visit(*static_cast<std::conditional_t<isConst, const ContinuousAssignSyntax*, ContinuousAssignSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverSequenceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageBins: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageBinsSyntax*, CoverageBinsSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CoverageOption: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverageOptionSyntax*, CoverageOptionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CovergroupDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const CovergroupDeclarationSyntax*, CovergroupDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Coverpoint: return visitor.visit(*static_cast<std::conditional_t<isConst, const CoverpointSyntax*, CoverpointSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::CycleDelay: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DPIImportExport: return visitor.visit(*static_cast<std::conditional_t<isConst, const DPIImportExportSyntax*, DPIImportExportSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DataDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const DataDeclarationSyntax*, DataDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefParam: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamSyntax*, DefParamSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefParamAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefParamAssignmentSyntax*, DefParamAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCaseItemSyntax*, DefaultCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultCoverageBinInitializerSyntax*, DefaultCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultNetTypeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefaultNetTypeDirectiveSyntax*, DefaultNetTypeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefaultPatternKeyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DeferredAssertion: return visitor.visit(*static_cast<std::conditional_t<isConst, const DeferredAssertionSyntax*, DeferredAssertionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const DefineDirectiveSyntax*, DefineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DelayControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const DelaySyntax*, DelaySyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DescendingRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableConstraintSyntax*, DisableConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableForkStatementSyntax*, DisableForkStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableIff: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableIffSyntax*, DisableIffSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DisableStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DisableStatementSyntax*, DisableStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistConstraintList: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistConstraintListSyntax*, DistConstraintListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistItemSyntax*, DistItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DistWeight: return visitor.visit(*static_cast<std::conditional_t<isConst, const DistWeightSyntax*, DistWeightSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DivideAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DivideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DividerClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DividerClauseSyntax*, DividerClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DoWhileStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const DoWhileStatementSyntax*, DoWhileStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DotMemberClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const DotMemberClauseSyntax*, DotMemberClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::DriveStrength: return visitor.visit(*static_cast<std::conditional_t<isConst, const DriveStrengthSyntax*, DriveStrengthSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElementSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectSyntax*, ElementSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElementSelectExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElementSelectExpressionSyntax*, ElementSelectExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElsIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseClauseSyntax*, ElseClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseConstraintClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ElseConstraintClauseSyntax*, ElseConstraintClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ElseDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyArgumentSyntax*, EmptyArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyIdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyIdentifierNameSyntax*, EmptyIdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyMemberSyntax*, EmptyMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyQueueExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyQueueExpressionSyntax*, EmptyQueueExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EmptyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EmptyStatementSyntax*, EmptyStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndCellDefineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndIfDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UnconditionalBranchDirectiveSyntax*, UnconditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EndKeywordsDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EnumType: return visitor.visit(*static_cast<std::conditional_t<isConst, const EnumTypeSyntax*, EnumTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EqualsValueClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const EqualsValueClauseSyntax*, EqualsValueClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlSyntax*, EventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventControlWithExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventControlWithExpressionSyntax*, EventControlWithExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::EventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpectPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitAnsiPortSyntax*, ExplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExplicitNonAnsiPortSyntax*, ExplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionConstraintSyntax*, ExpressionConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionCoverageBinInitializerSyntax*, ExpressionCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionOrDist: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionOrDistSyntax*, ExpressionOrDistSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionPatternSyntax*, ExpressionPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExpressionStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExpressionStatementSyntax*, ExpressionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExtendsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExtendsClauseSyntax*, ExtendsClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ExternModule: return visitor.visit(*static_cast<std::conditional_t<isConst, const ExternModuleSyntax*, ExternModuleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FinalBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForLoopStatementSyntax*, ForLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForVariableDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForVariableDeclarationSyntax*, ForVariableDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeachLoopList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopListSyntax*, ForeachLoopListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeachLoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeachLoopStatementSyntax*, ForeachLoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForeverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForeverStatementSyntax*, ForeverStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardInterfaceClassTypedefDeclarationSyntax*, ForwardInterfaceClassTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ForwardTypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ForwardTypedefDeclarationSyntax*, ForwardTypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortSyntax*, FunctionPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPortListSyntax*, FunctionPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::FunctionPrototype: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionPrototypeSyntax*, FunctionPrototypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenerateBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateBlockSyntax*, GenerateBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenerateRegion: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenerateRegionSyntax*, GenerateRegionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GenvarDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const GenvarDeclarationSyntax*, GenvarDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GreaterThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::GreaterThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::HierarchicalInstance: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchicalInstanceSyntax*, HierarchicalInstanceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::HierarchyInstantiation: return visitor.visit(*static_cast<std::conditional_t<isConst, const HierarchyInstantiationSyntax*, HierarchyInstantiationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierList: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierListSyntax*, IdentifierListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierNameSyntax*, IdentifierNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IdentifierSelectName: return visitor.visit(*static_cast<std::conditional_t<isConst, const IdentifierSelectNameSyntax*, IdentifierSelectNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const IfGenerateSyntax*, IfGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IfNDefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConditionalBranchDirectiveSyntax*, ConditionalBranchDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IffClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const IffClauseSyntax*, IffClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IffPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssertStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssertionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionMemberSyntax*, ImmediateAssertionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateAssumeStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImmediateCoverStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImmediateAssertionStatementSyntax*, ImmediateAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplementsClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplementsClauseSyntax*, ImplementsClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicationConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicationConstraintSyntax*, ImplicationConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitAnsiPortSyntax*, ImplicitAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitEventControlSyntax*, ImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitNonAnsiPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitNonAnsiPortSyntax*, ImplicitNonAnsiPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImplicitType: return visitor.visit(*static_cast<std::conditional_t<isConst, const ImplicitTypeSyntax*, ImplicitTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ImpliesPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IncludeDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const IncludeDirectiveSyntax*, IncludeDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InitialBlock: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralBlockSyntax*, ProceduralBlockSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InsideExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InsideExpressionSyntax*, InsideExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntegerVectorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerVectorExpressionSyntax*, IntegerVectorExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterconnectPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterconnectPortHeaderSyntax*, InterconnectPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfaceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfaceHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InterfacePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const InterfacePortHeaderSyntax*, InterfacePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::IntersectSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::InvocationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const InvocationExpressionSyntax*, InvocationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::JumpStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const JumpStatementSyntax*, JumpStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LessThanEqualExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LessThanExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const LetDeclarationSyntax*, LetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LineDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const LineDirectiveSyntax*, LineDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LocalScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalEquivalenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalImplicationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalRightShiftAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalShiftLeftExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LogicalShiftRightExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LongIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopConstraintSyntax*, LoopConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopGenerate: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopGenerateSyntax*, LoopGenerateSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::LoopStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const LoopStatementSyntax*, LoopStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroActualArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentSyntax*, MacroActualArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroActualArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroActualArgumentListSyntax*, MacroActualArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroArgumentDefault: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroArgumentDefaultSyntax*, MacroArgumentDefaultSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroFormalArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentSyntax*, MacroFormalArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroFormalArgumentList: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroFormalArgumentListSyntax*, MacroFormalArgumentListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MacroUsage: return visitor.visit(*static_cast<std::conditional_t<isConst, const MacroUsageSyntax*, MacroUsageSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MatchesClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const MatchesClauseSyntax*, MatchesClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MemberAccessExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MemberAccessExpressionSyntax*, MemberAccessExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MinTypMaxExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MinTypMaxExpressionSyntax*, MinTypMaxExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportClockingPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportClockingPortSyntax*, ModportClockingPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportDeclarationSyntax*, ModportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportExplicitPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportExplicitPortSyntax*, ModportExplicitPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportItemSyntax*, ModportItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportNamedPort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportNamedPortSyntax*, ModportNamedPortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSimplePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSimplePortListSyntax*, ModportSimplePortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSubroutinePort: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortSyntax*, ModportSubroutinePortSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModportSubroutinePortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModportSubroutinePortListSyntax*, ModportSubroutinePortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModuleDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ModuleHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultipleConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const MultipleConcatenationExpressionSyntax*, MultipleConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultiplyAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::MultiplyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedArgumentSyntax*, NamedArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedBlockClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedBlockClauseSyntax*, NamedBlockClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedLabel: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedLabelSyntax*, NamedLabelSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedPortConnectionSyntax*, NamedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedStructurePatternMemberSyntax*, NamedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NamedType: return visitor.visit(*static_cast<std::conditional_t<isConst, const NamedTypeSyntax*, NamedTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetDeclarationSyntax*, NetDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NetPortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const NetPortHeaderSyntax*, NetPortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewArrayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewArrayExpressionSyntax*, NewArrayExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewClassExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewClassExpressionSyntax*, NewClassExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NewExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const NewExpressionSyntax*, NewExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NoUnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonAnsiPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const NonAnsiPortListSyntax*, NonAnsiPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonblockingAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NonblockingEventTriggerStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const EventTriggerStatementSyntax*, EventTriggerStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::NullLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OneStepLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OpenRangeList: return visitor.visit(*static_cast<std::conditional_t<isConst, const OpenRangeListSyntax*, OpenRangeListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedArgument: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedArgumentSyntax*, OrderedArgumentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedPortConnectionSyntax*, OrderedPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OrderedStructurePatternMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const OrderedStructurePatternMemberSyntax*, OrderedStructurePatternMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OverlappedFollowedByPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::OverlappedImplicationPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageImportDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportDeclarationSyntax*, PackageImportDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PackageImportItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PackageImportItemSyntax*, PackageImportItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParallelBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationSyntax*, ParameterDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterDeclarationStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterDeclarationStatementSyntax*, ParameterDeclarationStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterPortListSyntax*, ParameterPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParameterValueAssignment: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParameterValueAssignmentSyntax*, ParameterValueAssignmentSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenImplicitEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenImplicitEventControlSyntax*, ParenImplicitEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedEventExpressionSyntax*, ParenthesizedEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ParenthesizedExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const ParenthesizedExpressionSyntax*, ParenthesizedExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PatternCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const PatternCaseItemSyntax*, PatternCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PortDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PortDeclarationSyntax*, PortDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PostdecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PostincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PostfixUnaryExpressionSyntax*, PostfixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PowerExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PragmaDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PrimaryBlockEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrimaryBlockEventExpressionSyntax*, PrimaryBlockEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralAssignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralDeassignStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralForceStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralAssignStatementSyntax*, ProceduralAssignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProceduralReleaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ProceduralDeassignStatementSyntax*, ProceduralDeassignStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProgramDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleDeclarationSyntax*, ModuleDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ProgramHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const ModuleHeaderSyntax*, ModuleHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertyDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertyDeclarationSyntax*, PropertyDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertySpec: return visitor.visit(*static_cast<std::conditional_t<isConst, const PropertySpecSyntax*, PropertySpecSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::PropertyType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::QueueDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const QueueDimensionSpecifierSyntax*, QueueDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseItemSyntax*, RandCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandCaseStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandCaseStatementSyntax*, RandCaseStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RandomizeMethodWithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const RandomizeMethodWithClauseSyntax*, RandomizeMethodWithClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeCoverageBinInitializerSyntax*, RangeCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RangeDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeDimensionSpecifierSyntax*, RangeDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealTimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RegType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RepeatedEventControl: return visitor.visit(*static_cast<std::conditional_t<isConst, const RepeatedEventControlSyntax*, RepeatedEventControlSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ReplicatedAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReplicatedAssignmentPatternSyntax*, ReplicatedAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ResetAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RestrictPropertyStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ConcurrentAssertionStatementSyntax*, ConcurrentAssertionStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ReturnStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const ReturnStatementSyntax*, ReturnStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::RootScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SAlwaysPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SEventuallyPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SNextTimePropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SUntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SUntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ScopedName: return visitor.visit(*static_cast<std::conditional_t<isConst, const ScopedNameSyntax*, ScopedNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const SequenceDeclarationSyntax*, SequenceDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequenceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SequentialBlockStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const BlockStatementSyntax*, BlockStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortIntType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortRealType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ShortcutCycleDelayRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const ShortcutCycleDelayRangeSyntax*, ShortcutCycleDelayRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SignalEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignalEventExpressionSyntax*, SignalEventExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SignedCastExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const SignedCastExpressionSyntax*, SignedCastExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleAssignmentPatternSyntax*, SimpleAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SimpleRangeSelect: return visitor.visit(*static_cast<std::conditional_t<isConst, const RangeSelectSyntax*, RangeSelectSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SolveBeforeConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const SolveBeforeConstraintSyntax*, SolveBeforeConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StandardCaseItem: return visitor.visit(*static_cast<std::conditional_t<isConst, const StandardCaseItemSyntax*, StandardCaseItemSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionSyntax*, StreamExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamExpressionWithRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamExpressionWithRange*, StreamExpressionWithRange*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StreamingConcatenationExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const StreamingConcatenationExpressionSyntax*, StreamingConcatenationExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StringLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StringType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructUnionMember: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionMemberSyntax*, StructUnionMemberSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructurePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructurePatternSyntax*, StructurePatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::StructuredAssignmentPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructuredAssignmentPatternSyntax*, StructuredAssignmentPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SubtractAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SubtractExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SuperHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SyncAcceptOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SyncRejectOnPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::SystemName: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaggedPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedPatternSyntax*, TaggedPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaggedUnionExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TaggedUnionExpressionSyntax*, TaggedUnionExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TaskDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const FunctionDeclarationSyntax*, FunctionDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ThisHandle: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::ThroughoutSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const IntegerTypeSyntax*, IntegerTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimeUnitsDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimeUnitsDeclarationSyntax*, TimeUnitsDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimescaleDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimescaleDirectiveSyntax*, TimescaleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionSyntax*, TimingControlExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlExpressionConcatenation: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlExpressionConcatenationSyntax*, TimingControlExpressionConcatenationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TimingControlStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const TimingControlStatementSyntax*, TimingControlStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransListCoverageBinInitializer: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransListCoverageBinInitializerSyntax*, TransListCoverageBinInitializerSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRangeSyntax*, TransRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransRepeatRange: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransRepeatRangeSyntax*, TransRepeatRangeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TransSet: return visitor.visit(*static_cast<std::conditional_t<isConst, const TransSetSyntax*, TransSetSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeReference: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypeReferenceSyntax*, TypeReferenceSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypeType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::TypedefDeclaration: return visitor.visit(*static_cast<std::conditional_t<isConst, const TypedefDeclarationSyntax*, TypedefDeclarationSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseAndExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNandExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseOrExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseXnorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryBitwiseXorExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryLogicalNotExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryMinusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryNotPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPlusExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPredecrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnaryPreincrementExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnarySequenceDelayExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnarySequenceEventExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const PrefixUnaryExpressionSyntax*, PrefixUnaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnbasedUnsizedLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnconnectedDriveDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UndefDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const UndefDirectiveSyntax*, UndefDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UndefineAllDirective: return visitor.visit(*static_cast<std::conditional_t<isConst, const SimpleDirectiveSyntax*, SimpleDirectiveSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnionType: return visitor.visit(*static_cast<std::conditional_t<isConst, const StructUnionTypeSyntax*, StructUnionTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UniquenessConstraint: return visitor.visit(*static_cast<std::conditional_t<isConst, const UniquenessConstraintSyntax*, UniquenessConstraintSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UnitScope: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordNameSyntax*, KeywordNameSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UntilPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::UntilWithPropertyExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::Untyped: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VarDataType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VarDataTypeSyntax*, VarDataTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariableDeclarator: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDeclaratorSyntax*, VariableDeclaratorSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariableDimension: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariableDimensionSyntax*, VariableDimensionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariablePattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePatternSyntax*, VariablePatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VariablePortHeader: return visitor.visit(*static_cast<std::conditional_t<isConst, const VariablePortHeaderSyntax*, VariablePortHeaderSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VirtualInterfaceType: return visitor.visit(*static_cast<std::conditional_t<isConst, const VirtualInterfaceTypeSyntax*, VirtualInterfaceTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::VoidType: return visitor.visit(*static_cast<std::conditional_t<isConst, const KeywordTypeSyntax*, KeywordTypeSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitForkStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitForkStatementSyntax*, WaitForkStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitOrderStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitOrderStatementSyntax*, WaitOrderStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WaitStatement: return visitor.visit(*static_cast<std::conditional_t<isConst, const WaitStatementSyntax*, WaitStatementSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardDimensionSpecifier: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardDimensionSpecifierSyntax*, WildcardDimensionSpecifierSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardEqualityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardInequalityExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardLiteralExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const LiteralExpressionSyntax*, LiteralExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPattern: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPatternSyntax*, WildcardPatternSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPortConnection: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortConnectionSyntax*, WildcardPortConnectionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WildcardPortList: return visitor.visit(*static_cast<std::conditional_t<isConst, const WildcardPortListSyntax*, WildcardPortListSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithClause: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithClauseSyntax*, WithClauseSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithFunctionSample: return visitor.visit(*static_cast<std::conditional_t<isConst, const WithFunctionSampleSyntax*, WithFunctionSampleSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::WithinSequenceExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
        case SyntaxKind::XorAssignmentExpression: return visitor.visit(*static_cast<std::conditional_t<isConst, const BinaryExpressionSyntax*, BinaryExpressionSyntax*>>(node), std::forward<Args>(args)...);
    }
    THROW_UNREACHABLE;
}

}

}
