//------------------------------------------------------------------------------
// AllSyntax.cpp
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#include "AllSyntax.h"

// This file contains all parse tree syntax node generated definitions.
// It is auto-generated by the syntax_gen.py script under the scripts/ directory.

namespace slang {

uint32_t SyntaxNode::getChildCount() const {
    switch (kind) {
        case SyntaxKind::Unknown: return 0;
        case SyntaxKind::SyntaxList:
        case SyntaxKind::TokenList:
        case SyntaxKind::SeparatedList:
            return ((const SyntaxListBase*)this)->getChildCount();
        case SyntaxKind::AcceptOnPropertyExpression: return 3;
        case SyntaxKind::ActionBlock: return 2;
        case SyntaxKind::AddAssignmentExpression: return 4;
        case SyntaxKind::AddExpression: return 4;
        case SyntaxKind::AlwaysBlock: return 3;
        case SyntaxKind::AlwaysCombBlock: return 3;
        case SyntaxKind::AlwaysFFBlock: return 3;
        case SyntaxKind::AlwaysLatchBlock: return 3;
        case SyntaxKind::AlwaysPropertyExpression: return 3;
        case SyntaxKind::AndAssignmentExpression: return 4;
        case SyntaxKind::AndSequenceExpression: return 4;
        case SyntaxKind::AnsiPortList: return 3;
        case SyntaxKind::ArgumentList: return 3;
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression: return 4;
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression: return 4;
        case SyntaxKind::ArithmeticShiftLeftExpression: return 4;
        case SyntaxKind::ArithmeticShiftRightExpression: return 4;
        case SyntaxKind::ArrayAndMethod: return 1;
        case SyntaxKind::ArrayOrMethod: return 1;
        case SyntaxKind::ArrayUniqueMethod: return 1;
        case SyntaxKind::ArrayXorMethod: return 1;
        case SyntaxKind::AscendingRangeSelect: return 3;
        case SyntaxKind::AssertPropertyStatement: return 8;
        case SyntaxKind::AssertionItemPort: return 5;
        case SyntaxKind::AssertionItemPortList: return 3;
        case SyntaxKind::AssignmentExpression: return 4;
        case SyntaxKind::AssignmentPatternExpression: return 2;
        case SyntaxKind::AssignmentPatternItem: return 3;
        case SyntaxKind::AssumePropertyStatement: return 8;
        case SyntaxKind::AttributeInstance: return 3;
        case SyntaxKind::AttributeSpec: return 2;
        case SyntaxKind::BadExpression: return 1;
        case SyntaxKind::BeginKeywordsDirective: return 3;
        case SyntaxKind::BinaryAndExpression: return 4;
        case SyntaxKind::BinaryBlockEventExpression: return 3;
        case SyntaxKind::BinaryEventExpression: return 3;
        case SyntaxKind::BinaryOrExpression: return 4;
        case SyntaxKind::BinarySequenceDelayExpression: return 4;
        case SyntaxKind::BinaryXnorExpression: return 4;
        case SyntaxKind::BinaryXorExpression: return 4;
        case SyntaxKind::BitSelect: return 1;
        case SyntaxKind::BitType: return 3;
        case SyntaxKind::BlockCoverageEvent: return 4;
        case SyntaxKind::BlockingEventTriggerStatement: return 5;
        case SyntaxKind::ByteType: return 3;
        case SyntaxKind::CHandleType: return 1;
        case SyntaxKind::CaseEqualityExpression: return 4;
        case SyntaxKind::CaseGenerate: return 7;
        case SyntaxKind::CaseInequalityExpression: return 4;
        case SyntaxKind::CaseStatement: return 10;
        case SyntaxKind::CastExpression: return 3;
        case SyntaxKind::CellDefineDirective: return 2;
        case SyntaxKind::ChargeStrength: return 3;
        case SyntaxKind::ClassDeclaration: return 12;
        case SyntaxKind::ClassMethodDeclaration: return 3;
        case SyntaxKind::ClassMethodPrototype: return 4;
        case SyntaxKind::ClassName: return 2;
        case SyntaxKind::ClassPropertyDeclaration: return 3;
        case SyntaxKind::ClassScope: return 2;
        case SyntaxKind::ClockingDeclaration: return 11;
        case SyntaxKind::ClockingDirection: return 5;
        case SyntaxKind::ClockingItem: return 5;
        case SyntaxKind::ClockingSkew: return 3;
        case SyntaxKind::ColonExpressionClause: return 2;
        case SyntaxKind::CompilationUnit: return 2;
        case SyntaxKind::ConcatenationExpression: return 3;
        case SyntaxKind::ConcurrentAssertionMember: return 2;
        case SyntaxKind::ConditionalConstraint: return 6;
        case SyntaxKind::ConditionalExpression: return 6;
        case SyntaxKind::ConditionalPattern: return 2;
        case SyntaxKind::ConditionalPredicate: return 1;
        case SyntaxKind::ConditionalStatement: return 9;
        case SyntaxKind::ConstraintBlock: return 3;
        case SyntaxKind::ConstraintDeclaration: return 5;
        case SyntaxKind::ConstraintPrototype: return 5;
        case SyntaxKind::ConstructorName: return 1;
        case SyntaxKind::ContinuousAssign: return 4;
        case SyntaxKind::CoverPropertyStatement: return 8;
        case SyntaxKind::CoverSequenceStatement: return 8;
        case SyntaxKind::CoverageBins: return 9;
        case SyntaxKind::CoverageOption: return 7;
        case SyntaxKind::CovergroupDeclaration: return 9;
        case SyntaxKind::Coverpoint: return 9;
        case SyntaxKind::CycleDelay: return 2;
        case SyntaxKind::DPIImportExport: return 8;
        case SyntaxKind::DataDeclaration: return 5;
        case SyntaxKind::DefParam: return 4;
        case SyntaxKind::DefParamAssignment: return 2;
        case SyntaxKind::DefaultCaseItem: return 3;
        case SyntaxKind::DefaultCoverageBinInitializer: return 2;
        case SyntaxKind::DefaultNetTypeDirective: return 3;
        case SyntaxKind::DefaultPatternKeyExpression: return 1;
        case SyntaxKind::DeferredAssertion: return 3;
        case SyntaxKind::DefineDirective: return 5;
        case SyntaxKind::DelayControl: return 2;
        case SyntaxKind::DescendingRangeSelect: return 3;
        case SyntaxKind::DisableConstraint: return 4;
        case SyntaxKind::DisableForkStatement: return 5;
        case SyntaxKind::DisableIff: return 5;
        case SyntaxKind::DisableStatement: return 5;
        case SyntaxKind::DistConstraintList: return 4;
        case SyntaxKind::DistItem: return 2;
        case SyntaxKind::DistWeight: return 2;
        case SyntaxKind::DivideAssignmentExpression: return 4;
        case SyntaxKind::DivideExpression: return 4;
        case SyntaxKind::DividerClause: return 2;
        case SyntaxKind::DoWhileStatement: return 9;
        case SyntaxKind::DotMemberClause: return 2;
        case SyntaxKind::DriveStrength: return 5;
        case SyntaxKind::ElementSelect: return 3;
        case SyntaxKind::ElementSelectExpression: return 2;
        case SyntaxKind::ElsIfDirective: return 4;
        case SyntaxKind::ElseClause: return 2;
        case SyntaxKind::ElseConstraintClause: return 2;
        case SyntaxKind::ElseDirective: return 3;
        case SyntaxKind::EmptyArgument: return 0;
        case SyntaxKind::EmptyIdentifierName: return 0;
        case SyntaxKind::EmptyMember: return 3;
        case SyntaxKind::EmptyQueueExpression: return 2;
        case SyntaxKind::EmptyStatement: return 3;
        case SyntaxKind::EndCellDefineDirective: return 2;
        case SyntaxKind::EndIfDirective: return 3;
        case SyntaxKind::EndKeywordsDirective: return 2;
        case SyntaxKind::EnumType: return 6;
        case SyntaxKind::EqualityExpression: return 4;
        case SyntaxKind::EqualsValueClause: return 2;
        case SyntaxKind::EventControl: return 2;
        case SyntaxKind::EventControlWithExpression: return 2;
        case SyntaxKind::EventType: return 1;
        case SyntaxKind::EventuallyPropertyExpression: return 3;
        case SyntaxKind::ExpectPropertyStatement: return 8;
        case SyntaxKind::ExplicitAnsiPort: return 7;
        case SyntaxKind::ExplicitNonAnsiPort: return 5;
        case SyntaxKind::ExpressionConstraint: return 3;
        case SyntaxKind::ExpressionCoverageBinInitializer: return 2;
        case SyntaxKind::ExpressionOrDist: return 2;
        case SyntaxKind::ExpressionPattern: return 1;
        case SyntaxKind::ExpressionStatement: return 4;
        case SyntaxKind::ExtendsClause: return 3;
        case SyntaxKind::ExternModule: return 2;
        case SyntaxKind::FinalBlock: return 3;
        case SyntaxKind::ForLoopStatement: return 11;
        case SyntaxKind::ForVariableDeclaration: return 3;
        case SyntaxKind::ForeachLoopList: return 6;
        case SyntaxKind::ForeachLoopStatement: return 5;
        case SyntaxKind::ForeverStatement: return 4;
        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration: return 6;
        case SyntaxKind::ForwardTypedefDeclaration: return 5;
        case SyntaxKind::FunctionDeclaration: return 6;
        case SyntaxKind::FunctionPort: return 6;
        case SyntaxKind::FunctionPortList: return 3;
        case SyntaxKind::FunctionPrototype: return 5;
        case SyntaxKind::GenerateBlock: return 7;
        case SyntaxKind::GenerateRegion: return 4;
        case SyntaxKind::GenvarDeclaration: return 4;
        case SyntaxKind::GreaterThanEqualExpression: return 4;
        case SyntaxKind::GreaterThanExpression: return 4;
        case SyntaxKind::HierarchicalInstance: return 5;
        case SyntaxKind::HierarchyInstantiation: return 5;
        case SyntaxKind::IdentifierList: return 3;
        case SyntaxKind::IdentifierName: return 1;
        case SyntaxKind::IdentifierSelectName: return 2;
        case SyntaxKind::IfDefDirective: return 4;
        case SyntaxKind::IfGenerate: return 7;
        case SyntaxKind::IfNDefDirective: return 4;
        case SyntaxKind::IffClause: return 4;
        case SyntaxKind::IffPropertyExpression: return 4;
        case SyntaxKind::ImmediateAssertStatement: return 6;
        case SyntaxKind::ImmediateAssertionMember: return 2;
        case SyntaxKind::ImmediateAssumeStatement: return 6;
        case SyntaxKind::ImmediateCoverStatement: return 6;
        case SyntaxKind::ImplementsClause: return 2;
        case SyntaxKind::ImplicationConstraint: return 3;
        case SyntaxKind::ImplicitAnsiPort: return 3;
        case SyntaxKind::ImplicitEventControl: return 1;
        case SyntaxKind::ImplicitNonAnsiPort: return 1;
        case SyntaxKind::ImplicitType: return 2;
        case SyntaxKind::ImpliesPropertyExpression: return 4;
        case SyntaxKind::IncludeDirective: return 3;
        case SyntaxKind::InequalityExpression: return 4;
        case SyntaxKind::InitialBlock: return 3;
        case SyntaxKind::InsideExpression: return 3;
        case SyntaxKind::IntType: return 3;
        case SyntaxKind::IntegerLiteralExpression: return 1;
        case SyntaxKind::IntegerType: return 3;
        case SyntaxKind::IntegerVectorExpression: return 3;
        case SyntaxKind::InterconnectPortHeader: return 3;
        case SyntaxKind::InterfaceDeclaration: return 5;
        case SyntaxKind::InterfaceHeader: return 7;
        case SyntaxKind::InterfacePortHeader: return 2;
        case SyntaxKind::IntersectSequenceExpression: return 4;
        case SyntaxKind::InvocationExpression: return 3;
        case SyntaxKind::JumpStatement: return 4;
        case SyntaxKind::LessThanEqualExpression: return 4;
        case SyntaxKind::LessThanExpression: return 4;
        case SyntaxKind::LetDeclaration: return 6;
        case SyntaxKind::LineDirective: return 5;
        case SyntaxKind::LocalScope: return 1;
        case SyntaxKind::LogicType: return 3;
        case SyntaxKind::LogicalAndExpression: return 4;
        case SyntaxKind::LogicalEquivalenceExpression: return 4;
        case SyntaxKind::LogicalImplicationExpression: return 4;
        case SyntaxKind::LogicalLeftShiftAssignmentExpression: return 4;
        case SyntaxKind::LogicalOrExpression: return 4;
        case SyntaxKind::LogicalRightShiftAssignmentExpression: return 4;
        case SyntaxKind::LogicalShiftLeftExpression: return 4;
        case SyntaxKind::LogicalShiftRightExpression: return 4;
        case SyntaxKind::LongIntType: return 3;
        case SyntaxKind::LoopConstraint: return 3;
        case SyntaxKind::LoopGenerate: return 13;
        case SyntaxKind::LoopStatement: return 7;
        case SyntaxKind::MacroActualArgument: return 1;
        case SyntaxKind::MacroActualArgumentList: return 3;
        case SyntaxKind::MacroArgumentDefault: return 2;
        case SyntaxKind::MacroFormalArgument: return 2;
        case SyntaxKind::MacroFormalArgumentList: return 3;
        case SyntaxKind::MacroUsage: return 2;
        case SyntaxKind::MatchesClause: return 2;
        case SyntaxKind::MemberAccessExpression: return 3;
        case SyntaxKind::MinTypMaxExpression: return 5;
        case SyntaxKind::ModAssignmentExpression: return 4;
        case SyntaxKind::ModExpression: return 4;
        case SyntaxKind::ModportClockingPort: return 3;
        case SyntaxKind::ModportDeclaration: return 4;
        case SyntaxKind::ModportExplicitPort: return 5;
        case SyntaxKind::ModportItem: return 2;
        case SyntaxKind::ModportNamedPort: return 1;
        case SyntaxKind::ModportSimplePortList: return 3;
        case SyntaxKind::ModportSubroutinePort: return 1;
        case SyntaxKind::ModportSubroutinePortList: return 3;
        case SyntaxKind::ModuleDeclaration: return 5;
        case SyntaxKind::ModuleHeader: return 7;
        case SyntaxKind::MultipleConcatenationExpression: return 4;
        case SyntaxKind::MultiplyAssignmentExpression: return 4;
        case SyntaxKind::MultiplyExpression: return 4;
        case SyntaxKind::NamedArgument: return 5;
        case SyntaxKind::NamedBlockClause: return 2;
        case SyntaxKind::NamedLabel: return 2;
        case SyntaxKind::NamedPortConnection: return 6;
        case SyntaxKind::NamedStructurePatternMember: return 3;
        case SyntaxKind::NamedType: return 1;
        case SyntaxKind::NetDeclaration: return 7;
        case SyntaxKind::NetPortHeader: return 3;
        case SyntaxKind::NewArrayExpression: return 5;
        case SyntaxKind::NewClassExpression: return 3;
        case SyntaxKind::NewExpression: return 2;
        case SyntaxKind::NextTimePropertyExpression: return 3;
        case SyntaxKind::NoUnconnectedDriveDirective: return 2;
        case SyntaxKind::NonAnsiPortList: return 3;
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression: return 4;
        case SyntaxKind::NonOverlappedImplicationPropertyExpression: return 4;
        case SyntaxKind::NonblockingAssignmentExpression: return 4;
        case SyntaxKind::NonblockingEventTriggerStatement: return 5;
        case SyntaxKind::NullLiteralExpression: return 1;
        case SyntaxKind::OneStepLiteralExpression: return 1;
        case SyntaxKind::OpenRangeList: return 3;
        case SyntaxKind::OrAssignmentExpression: return 4;
        case SyntaxKind::OrSequenceExpression: return 4;
        case SyntaxKind::OrderedArgument: return 1;
        case SyntaxKind::OrderedPortConnection: return 2;
        case SyntaxKind::OrderedStructurePatternMember: return 1;
        case SyntaxKind::OverlappedFollowedByPropertyExpression: return 4;
        case SyntaxKind::OverlappedImplicationPropertyExpression: return 4;
        case SyntaxKind::PackageDeclaration: return 5;
        case SyntaxKind::PackageHeader: return 7;
        case SyntaxKind::PackageImportDeclaration: return 4;
        case SyntaxKind::PackageImportItem: return 3;
        case SyntaxKind::ParallelBlockStatement: return 7;
        case SyntaxKind::ParameterDeclaration: return 3;
        case SyntaxKind::ParameterDeclarationStatement: return 3;
        case SyntaxKind::ParameterPortList: return 4;
        case SyntaxKind::ParameterValueAssignment: return 2;
        case SyntaxKind::ParenImplicitEventControl: return 2;
        case SyntaxKind::ParenthesizedEventExpression: return 3;
        case SyntaxKind::ParenthesizedExpression: return 3;
        case SyntaxKind::PatternCaseItem: return 5;
        case SyntaxKind::PortDeclaration: return 4;
        case SyntaxKind::PostdecrementExpression: return 3;
        case SyntaxKind::PostincrementExpression: return 3;
        case SyntaxKind::PowerExpression: return 4;
        case SyntaxKind::PragmaDirective: return 2;
        case SyntaxKind::PrimaryBlockEventExpression: return 2;
        case SyntaxKind::ProceduralAssignStatement: return 7;
        case SyntaxKind::ProceduralDeassignStatement: return 5;
        case SyntaxKind::ProceduralForceStatement: return 7;
        case SyntaxKind::ProceduralReleaseStatement: return 5;
        case SyntaxKind::ProgramDeclaration: return 5;
        case SyntaxKind::ProgramHeader: return 7;
        case SyntaxKind::PropertyDeclaration: return 10;
        case SyntaxKind::PropertySpec: return 3;
        case SyntaxKind::PropertyType: return 1;
        case SyntaxKind::QueueDimensionSpecifier: return 2;
        case SyntaxKind::RandCaseItem: return 3;
        case SyntaxKind::RandCaseStatement: return 5;
        case SyntaxKind::RandomizeMethodWithClause: return 3;
        case SyntaxKind::RangeCoverageBinInitializer: return 2;
        case SyntaxKind::RangeDimensionSpecifier: return 1;
        case SyntaxKind::RealLiteralExpression: return 1;
        case SyntaxKind::RealTimeType: return 1;
        case SyntaxKind::RealType: return 1;
        case SyntaxKind::RegType: return 3;
        case SyntaxKind::RejectOnPropertyExpression: return 3;
        case SyntaxKind::RepeatedEventControl: return 5;
        case SyntaxKind::ReplicatedAssignmentPattern: return 6;
        case SyntaxKind::ResetAllDirective: return 2;
        case SyntaxKind::RestrictPropertyStatement: return 8;
        case SyntaxKind::ReturnStatement: return 5;
        case SyntaxKind::RootScope: return 1;
        case SyntaxKind::SAlwaysPropertyExpression: return 3;
        case SyntaxKind::SEventuallyPropertyExpression: return 3;
        case SyntaxKind::SNextTimePropertyExpression: return 3;
        case SyntaxKind::SUntilPropertyExpression: return 4;
        case SyntaxKind::SUntilWithPropertyExpression: return 4;
        case SyntaxKind::ScopedName: return 3;
        case SyntaxKind::SequenceDeclaration: return 10;
        case SyntaxKind::SequenceType: return 1;
        case SyntaxKind::SequentialBlockStatement: return 7;
        case SyntaxKind::ShortIntType: return 3;
        case SyntaxKind::ShortRealType: return 1;
        case SyntaxKind::ShortcutCycleDelayRange: return 4;
        case SyntaxKind::SignalEventExpression: return 2;
        case SyntaxKind::SignedCastExpression: return 3;
        case SyntaxKind::SimpleAssignmentPattern: return 3;
        case SyntaxKind::SimpleRangeSelect: return 3;
        case SyntaxKind::SolveBeforeConstraint: return 5;
        case SyntaxKind::StandardCaseItem: return 3;
        case SyntaxKind::StreamExpression: return 2;
        case SyntaxKind::StreamExpressionWithRange: return 2;
        case SyntaxKind::StreamingConcatenationExpression: return 7;
        case SyntaxKind::StringLiteralExpression: return 1;
        case SyntaxKind::StringType: return 1;
        case SyntaxKind::StructType: return 8;
        case SyntaxKind::StructUnionMember: return 5;
        case SyntaxKind::StructurePattern: return 3;
        case SyntaxKind::StructuredAssignmentPattern: return 3;
        case SyntaxKind::SubtractAssignmentExpression: return 4;
        case SyntaxKind::SubtractExpression: return 4;
        case SyntaxKind::SuperHandle: return 1;
        case SyntaxKind::SyncAcceptOnPropertyExpression: return 3;
        case SyntaxKind::SyncRejectOnPropertyExpression: return 3;
        case SyntaxKind::SystemName: return 1;
        case SyntaxKind::TaggedPattern: return 3;
        case SyntaxKind::TaggedUnionExpression: return 3;
        case SyntaxKind::TaskDeclaration: return 6;
        case SyntaxKind::ThisHandle: return 1;
        case SyntaxKind::ThroughoutSequenceExpression: return 4;
        case SyntaxKind::TimeLiteralExpression: return 1;
        case SyntaxKind::TimeType: return 3;
        case SyntaxKind::TimeUnitsDeclaration: return 5;
        case SyntaxKind::TimescaleDirective: return 7;
        case SyntaxKind::TimingControlExpression: return 2;
        case SyntaxKind::TimingControlExpressionConcatenation: return 3;
        case SyntaxKind::TimingControlStatement: return 4;
        case SyntaxKind::TransListCoverageBinInitializer: return 2;
        case SyntaxKind::TransRange: return 2;
        case SyntaxKind::TransRepeatRange: return 4;
        case SyntaxKind::TransSet: return 3;
        case SyntaxKind::TypeReference: return 4;
        case SyntaxKind::TypeType: return 1;
        case SyntaxKind::TypedefDeclaration: return 6;
        case SyntaxKind::UnaryBitwiseAndExpression: return 3;
        case SyntaxKind::UnaryBitwiseNandExpression: return 3;
        case SyntaxKind::UnaryBitwiseNorExpression: return 3;
        case SyntaxKind::UnaryBitwiseNotExpression: return 3;
        case SyntaxKind::UnaryBitwiseOrExpression: return 3;
        case SyntaxKind::UnaryBitwiseXnorExpression: return 3;
        case SyntaxKind::UnaryBitwiseXorExpression: return 3;
        case SyntaxKind::UnaryLogicalNotExpression: return 3;
        case SyntaxKind::UnaryMinusExpression: return 3;
        case SyntaxKind::UnaryNotPropertyExpression: return 3;
        case SyntaxKind::UnaryPlusExpression: return 3;
        case SyntaxKind::UnaryPredecrementExpression: return 3;
        case SyntaxKind::UnaryPreincrementExpression: return 3;
        case SyntaxKind::UnarySequenceDelayExpression: return 3;
        case SyntaxKind::UnarySequenceEventExpression: return 3;
        case SyntaxKind::UnbasedUnsizedLiteralExpression: return 1;
        case SyntaxKind::UnconnectedDriveDirective: return 2;
        case SyntaxKind::UndefDirective: return 3;
        case SyntaxKind::UndefineAllDirective: return 2;
        case SyntaxKind::UnionType: return 8;
        case SyntaxKind::UniquenessConstraint: return 3;
        case SyntaxKind::UnitScope: return 1;
        case SyntaxKind::UntilPropertyExpression: return 4;
        case SyntaxKind::UntilWithPropertyExpression: return 4;
        case SyntaxKind::Untyped: return 1;
        case SyntaxKind::VarDataType: return 2;
        case SyntaxKind::VariableDeclarator: return 3;
        case SyntaxKind::VariableDimension: return 3;
        case SyntaxKind::VariablePattern: return 2;
        case SyntaxKind::VariablePortHeader: return 3;
        case SyntaxKind::VirtualInterfaceType: return 5;
        case SyntaxKind::VoidType: return 1;
        case SyntaxKind::WaitForkStatement: return 5;
        case SyntaxKind::WaitOrderStatement: return 7;
        case SyntaxKind::WaitStatement: return 7;
        case SyntaxKind::WildcardDimensionSpecifier: return 1;
        case SyntaxKind::WildcardEqualityExpression: return 4;
        case SyntaxKind::WildcardInequalityExpression: return 4;
        case SyntaxKind::WildcardLiteralExpression: return 1;
        case SyntaxKind::WildcardPattern: return 1;
        case SyntaxKind::WildcardPortConnection: return 2;
        case SyntaxKind::WildcardPortList: return 3;
        case SyntaxKind::WithClause: return 4;
        case SyntaxKind::WithFunctionSample: return 4;
        case SyntaxKind::WithinSequenceExpression: return 4;
        case SyntaxKind::XorAssignmentExpression: return 4;
    }
    THROW_UNREACHABLE;
}

bool ActionBlockSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ActionBlock;
}

TokenOrSyntax ActionBlockSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return statement;
        case 1: return elseClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ActionBlockSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return statement;
        case 1: return elseClause;
        default: return nullptr;
    }
}

void ActionBlockSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: statement = &child.node()->as<StatementSyntax>(); return;
        case 1: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ActionBlockSyntax* ActionBlockSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ActionBlockSyntax));
    return new (mem) ActionBlockSyntax(*this);
}

bool AnsiPortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AnsiPortList;
}

TokenOrSyntax AnsiPortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax AnsiPortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void AnsiPortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: ports = child.node()->as<SeparatedSyntaxList<MemberSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

AnsiPortListSyntax* AnsiPortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AnsiPortListSyntax));
    return new (mem) AnsiPortListSyntax(*this);
}

bool ArgumentListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ArgumentList;
}

TokenOrSyntax ArgumentListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &parameters;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ArgumentListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &parameters;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void ArgumentListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: parameters = child.node()->as<SeparatedSyntaxList<ArgumentSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ArgumentListSyntax* ArgumentListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ArgumentListSyntax));
    return new (mem) ArgumentListSyntax(*this);
}

bool ArgumentSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::EmptyArgument:
        case SyntaxKind::NamedArgument:
        case SyntaxKind::OrderedArgument:
            return true;
        default:
            return false;
    }
}

bool AssertionItemPortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AssertionItemPortList;
}

TokenOrSyntax AssertionItemPortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax AssertionItemPortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void AssertionItemPortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: ports = child.node()->as<SeparatedSyntaxList<AssertionItemPortSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

AssertionItemPortListSyntax* AssertionItemPortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AssertionItemPortListSyntax));
    return new (mem) AssertionItemPortListSyntax(*this);
}

bool AssertionItemPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AssertionItemPort;
}

TokenOrSyntax AssertionItemPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return local;
        case 2: return direction;
        case 3: return type.get();
        case 4: return declarator.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax AssertionItemPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return local;
        case 2: return direction;
        case 3: return type.get();
        case 4: return declarator.get();
        default: return nullptr;
    }
}

void AssertionItemPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: local = child.token(); return;
        case 2: direction = child.token(); return;
        case 3: type = &child.node()->as<DataTypeSyntax>(); return;
        case 4: declarator = &child.node()->as<VariableDeclaratorSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

AssertionItemPortSyntax* AssertionItemPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AssertionItemPortSyntax));
    return new (mem) AssertionItemPortSyntax(*this);
}

bool AssignmentPatternExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AssignmentPatternExpression;
}

TokenOrSyntax AssignmentPatternExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return type;
        case 1: return pattern.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax AssignmentPatternExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return type;
        case 1: return pattern.get();
        default: return nullptr;
    }
}

void AssignmentPatternExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: type = &child.node()->as<DataTypeSyntax>(); return;
        case 1: pattern = &child.node()->as<AssignmentPatternSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

AssignmentPatternExpressionSyntax* AssignmentPatternExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AssignmentPatternExpressionSyntax));
    return new (mem) AssignmentPatternExpressionSyntax(*this);
}

bool AssignmentPatternItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AssignmentPatternItem;
}

TokenOrSyntax AssignmentPatternItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return key.get();
        case 1: return colon;
        case 2: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax AssignmentPatternItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return key.get();
        case 1: return colon;
        case 2: return expr.get();
        default: return nullptr;
    }
}

void AssignmentPatternItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: key = &child.node()->as<ExpressionSyntax>(); return;
        case 1: colon = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

AssignmentPatternItemSyntax* AssignmentPatternItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AssignmentPatternItemSyntax));
    return new (mem) AssignmentPatternItemSyntax(*this);
}

bool AssignmentPatternSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ReplicatedAssignmentPattern:
        case SyntaxKind::SimpleAssignmentPattern:
        case SyntaxKind::StructuredAssignmentPattern:
            return true;
        default:
            return false;
    }
}

bool AttributeInstanceSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AttributeInstance;
}

TokenOrSyntax AttributeInstanceSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &specs;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax AttributeInstanceSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &specs;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void AttributeInstanceSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: specs = child.node()->as<SeparatedSyntaxList<AttributeSpecSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

AttributeInstanceSyntax* AttributeInstanceSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AttributeInstanceSyntax));
    return new (mem) AttributeInstanceSyntax(*this);
}

bool AttributeSpecSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::AttributeSpec;
}

TokenOrSyntax AttributeSpecSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return value;
        default: return nullptr;
    }
}

ConstTokenOrSyntax AttributeSpecSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return value;
        default: return nullptr;
    }
}

void AttributeSpecSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: value = &child.node()->as<EqualsValueClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

AttributeSpecSyntax* AttributeSpecSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(AttributeSpecSyntax));
    return new (mem) AttributeSpecSyntax(*this);
}

bool BadExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::BadExpression;
}

TokenOrSyntax BadExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax BadExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

void BadExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

BadExpressionSyntax* BadExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BadExpressionSyntax));
    return new (mem) BadExpressionSyntax(*this);
}

bool BeginKeywordsDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::BeginKeywordsDirective;
}

TokenOrSyntax BeginKeywordsDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return versionSpecifier;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax BeginKeywordsDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return versionSpecifier;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

void BeginKeywordsDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: versionSpecifier = child.token(); return;
        case 2: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

BeginKeywordsDirectiveSyntax* BeginKeywordsDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BeginKeywordsDirectiveSyntax));
    return new (mem) BeginKeywordsDirectiveSyntax(*this);
}

bool BinaryBlockEventExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::BinaryBlockEventExpression;
}

TokenOrSyntax BinaryBlockEventExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return orKeyword;
        case 2: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax BinaryBlockEventExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return orKeyword;
        case 2: return right.get();
        default: return nullptr;
    }
}

void BinaryBlockEventExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<BlockEventExpressionSyntax>(); return;
        case 1: orKeyword = child.token(); return;
        case 2: right = &child.node()->as<BlockEventExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

BinaryBlockEventExpressionSyntax* BinaryBlockEventExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BinaryBlockEventExpressionSyntax));
    return new (mem) BinaryBlockEventExpressionSyntax(*this);
}

bool BinaryEventExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::BinaryEventExpression;
}

TokenOrSyntax BinaryEventExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return operatorToken;
        case 2: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax BinaryEventExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return operatorToken;
        case 2: return right.get();
        default: return nullptr;
    }
}

void BinaryEventExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<EventExpressionSyntax>(); return;
        case 1: operatorToken = child.token(); return;
        case 2: right = &child.node()->as<EventExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

BinaryEventExpressionSyntax* BinaryEventExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BinaryEventExpressionSyntax));
    return new (mem) BinaryEventExpressionSyntax(*this);
}

bool BinaryExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AddAssignmentExpression:
        case SyntaxKind::AddExpression:
        case SyntaxKind::AndAssignmentExpression:
        case SyntaxKind::AndSequenceExpression:
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression:
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression:
        case SyntaxKind::ArithmeticShiftLeftExpression:
        case SyntaxKind::ArithmeticShiftRightExpression:
        case SyntaxKind::AssignmentExpression:
        case SyntaxKind::BinaryAndExpression:
        case SyntaxKind::BinaryOrExpression:
        case SyntaxKind::BinarySequenceDelayExpression:
        case SyntaxKind::BinaryXnorExpression:
        case SyntaxKind::BinaryXorExpression:
        case SyntaxKind::CaseEqualityExpression:
        case SyntaxKind::CaseInequalityExpression:
        case SyntaxKind::DivideAssignmentExpression:
        case SyntaxKind::DivideExpression:
        case SyntaxKind::EqualityExpression:
        case SyntaxKind::GreaterThanEqualExpression:
        case SyntaxKind::GreaterThanExpression:
        case SyntaxKind::IffPropertyExpression:
        case SyntaxKind::ImpliesPropertyExpression:
        case SyntaxKind::InequalityExpression:
        case SyntaxKind::IntersectSequenceExpression:
        case SyntaxKind::LessThanEqualExpression:
        case SyntaxKind::LessThanExpression:
        case SyntaxKind::LogicalAndExpression:
        case SyntaxKind::LogicalEquivalenceExpression:
        case SyntaxKind::LogicalImplicationExpression:
        case SyntaxKind::LogicalLeftShiftAssignmentExpression:
        case SyntaxKind::LogicalOrExpression:
        case SyntaxKind::LogicalRightShiftAssignmentExpression:
        case SyntaxKind::LogicalShiftLeftExpression:
        case SyntaxKind::LogicalShiftRightExpression:
        case SyntaxKind::ModAssignmentExpression:
        case SyntaxKind::ModExpression:
        case SyntaxKind::MultiplyAssignmentExpression:
        case SyntaxKind::MultiplyExpression:
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression:
        case SyntaxKind::NonOverlappedImplicationPropertyExpression:
        case SyntaxKind::NonblockingAssignmentExpression:
        case SyntaxKind::OrAssignmentExpression:
        case SyntaxKind::OrSequenceExpression:
        case SyntaxKind::OverlappedFollowedByPropertyExpression:
        case SyntaxKind::OverlappedImplicationPropertyExpression:
        case SyntaxKind::PowerExpression:
        case SyntaxKind::SUntilPropertyExpression:
        case SyntaxKind::SUntilWithPropertyExpression:
        case SyntaxKind::SubtractAssignmentExpression:
        case SyntaxKind::SubtractExpression:
        case SyntaxKind::ThroughoutSequenceExpression:
        case SyntaxKind::UntilPropertyExpression:
        case SyntaxKind::UntilWithPropertyExpression:
        case SyntaxKind::WildcardEqualityExpression:
        case SyntaxKind::WildcardInequalityExpression:
        case SyntaxKind::WithinSequenceExpression:
        case SyntaxKind::XorAssignmentExpression:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax BinaryExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return operatorToken;
        case 2: return &attributes;
        case 3: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax BinaryExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return operatorToken;
        case 2: return &attributes;
        case 3: return right.get();
        default: return nullptr;
    }
}

void BinaryExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: operatorToken = child.token(); return;
        case 2: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 3: right = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

BinaryExpressionSyntax* BinaryExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BinaryExpressionSyntax));
    return new (mem) BinaryExpressionSyntax(*this);
}

bool BitSelectSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::BitSelect;
}

TokenOrSyntax BitSelectSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax BitSelectSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

void BitSelectSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

BitSelectSyntax* BitSelectSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BitSelectSyntax));
    return new (mem) BitSelectSyntax(*this);
}

bool BlockCoverageEventSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::BlockCoverageEvent;
}

TokenOrSyntax BlockCoverageEventSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return atat;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax BlockCoverageEventSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return atat;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

void BlockCoverageEventSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: atat = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: expr = &child.node()->as<BlockEventExpressionSyntax>(); return;
        case 3: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

BlockCoverageEventSyntax* BlockCoverageEventSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BlockCoverageEventSyntax));
    return new (mem) BlockCoverageEventSyntax(*this);
}

bool BlockEventExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::BinaryBlockEventExpression:
        case SyntaxKind::PrimaryBlockEventExpression:
            return true;
        default:
            return false;
    }
}

bool BlockStatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ParallelBlockStatement:
        case SyntaxKind::SequentialBlockStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax BlockStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return begin;
        case 3: return blockName;
        case 4: return &items;
        case 5: return end;
        case 6: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax BlockStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return begin;
        case 3: return blockName;
        case 4: return &items;
        case 5: return end;
        case 6: return endBlockName;
        default: return nullptr;
    }
}

void BlockStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: begin = child.token(); return;
        case 3: blockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        case 4: items = child.node()->as<SyntaxList<SyntaxNode>>(); return;
        case 5: end = child.token(); return;
        case 6: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

BlockStatementSyntax* BlockStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(BlockStatementSyntax));
    return new (mem) BlockStatementSyntax(*this);
}

bool CaseGenerateSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CaseGenerate;
}

TokenOrSyntax CaseGenerateSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return openParen;
        case 3: return condition.get();
        case 4: return closeParen;
        case 5: return &items;
        case 6: return endCase;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CaseGenerateSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return openParen;
        case 3: return condition.get();
        case 4: return closeParen;
        case 5: return &items;
        case 6: return endCase;
        default: return nullptr;
    }
}

void CaseGenerateSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: condition = &child.node()->as<ExpressionSyntax>(); return;
        case 4: closeParen = child.token(); return;
        case 5: items = child.node()->as<SyntaxList<CaseItemSyntax>>(); return;
        case 6: endCase = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

CaseGenerateSyntax* CaseGenerateSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CaseGenerateSyntax));
    return new (mem) CaseGenerateSyntax(*this);
}

bool CaseItemSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::DefaultCaseItem:
        case SyntaxKind::PatternCaseItem:
        case SyntaxKind::StandardCaseItem:
            return true;
        default:
            return false;
    }
}

bool CaseStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CaseStatement;
}

TokenOrSyntax CaseStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return uniqueOrPriority;
        case 3: return caseKeyword;
        case 4: return openParen;
        case 5: return expr.get();
        case 6: return closeParen;
        case 7: return matchesOrInside;
        case 8: return &items;
        case 9: return endcase;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CaseStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return uniqueOrPriority;
        case 3: return caseKeyword;
        case 4: return openParen;
        case 5: return expr.get();
        case 6: return closeParen;
        case 7: return matchesOrInside;
        case 8: return &items;
        case 9: return endcase;
        default: return nullptr;
    }
}

void CaseStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: uniqueOrPriority = child.token(); return;
        case 3: caseKeyword = child.token(); return;
        case 4: openParen = child.token(); return;
        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 6: closeParen = child.token(); return;
        case 7: matchesOrInside = child.token(); return;
        case 8: items = child.node()->as<SyntaxList<CaseItemSyntax>>(); return;
        case 9: endcase = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

CaseStatementSyntax* CaseStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CaseStatementSyntax));
    return new (mem) CaseStatementSyntax(*this);
}

bool CastExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CastExpression;
}

TokenOrSyntax CastExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return apostrophe;
        case 2: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax CastExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return apostrophe;
        case 2: return right.get();
        default: return nullptr;
    }
}

void CastExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: apostrophe = child.token(); return;
        case 2: right = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

CastExpressionSyntax* CastExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CastExpressionSyntax));
    return new (mem) CastExpressionSyntax(*this);
}

bool ChargeStrengthSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ChargeStrength;
}

TokenOrSyntax ChargeStrengthSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return strength;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ChargeStrengthSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return strength;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void ChargeStrengthSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: strength = child.token(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ChargeStrengthSyntax* ChargeStrengthSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ChargeStrengthSyntax));
    return new (mem) ChargeStrengthSyntax(*this);
}

bool ClassDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClassDeclaration;
}

TokenOrSyntax ClassDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return virtualOrInterface;
        case 2: return classKeyword;
        case 3: return lifetime;
        case 4: return name;
        case 5: return parameters;
        case 6: return extendsClause;
        case 7: return implementsClause;
        case 8: return semi;
        case 9: return &items;
        case 10: return endClass;
        case 11: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClassDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return virtualOrInterface;
        case 2: return classKeyword;
        case 3: return lifetime;
        case 4: return name;
        case 5: return parameters;
        case 6: return extendsClause;
        case 7: return implementsClause;
        case 8: return semi;
        case 9: return &items;
        case 10: return endClass;
        case 11: return endBlockName;
        default: return nullptr;
    }
}

void ClassDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: virtualOrInterface = child.token(); return;
        case 2: classKeyword = child.token(); return;
        case 3: lifetime = child.token(); return;
        case 4: name = child.token(); return;
        case 5: parameters = &child.node()->as<ParameterPortListSyntax>(); return;
        case 6: extendsClause = &child.node()->as<ExtendsClauseSyntax>(); return;
        case 7: implementsClause = &child.node()->as<ImplementsClauseSyntax>(); return;
        case 8: semi = child.token(); return;
        case 9: items = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 10: endClass = child.token(); return;
        case 11: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClassDeclarationSyntax* ClassDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClassDeclarationSyntax));
    return new (mem) ClassDeclarationSyntax(*this);
}

bool ClassMethodDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClassMethodDeclaration;
}

TokenOrSyntax ClassMethodDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return declaration.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClassMethodDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return declaration.get();
        default: return nullptr;
    }
}

void ClassMethodDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: qualifiers = child.node()->as<TokenList>(); return;
        case 2: declaration = &child.node()->as<FunctionDeclarationSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClassMethodDeclarationSyntax* ClassMethodDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClassMethodDeclarationSyntax));
    return new (mem) ClassMethodDeclarationSyntax(*this);
}

bool ClassMethodPrototypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClassMethodPrototype;
}

TokenOrSyntax ClassMethodPrototypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return prototype.get();
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClassMethodPrototypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return prototype.get();
        case 3: return semi;
        default: return nullptr;
    }
}

void ClassMethodPrototypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: qualifiers = child.node()->as<TokenList>(); return;
        case 2: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ClassMethodPrototypeSyntax* ClassMethodPrototypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClassMethodPrototypeSyntax));
    return new (mem) ClassMethodPrototypeSyntax(*this);
}

bool ClassNameSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClassName;
}

TokenOrSyntax ClassNameSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return identifier;
        case 1: return parameters.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClassNameSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return identifier;
        case 1: return parameters.get();
        default: return nullptr;
    }
}

void ClassNameSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: identifier = child.token(); return;
        case 1: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClassNameSyntax* ClassNameSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClassNameSyntax));
    return new (mem) ClassNameSyntax(*this);
}

bool ClassPropertyDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClassPropertyDeclaration;
}

TokenOrSyntax ClassPropertyDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return declaration.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClassPropertyDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return declaration.get();
        default: return nullptr;
    }
}

void ClassPropertyDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: qualifiers = child.node()->as<TokenList>(); return;
        case 2: declaration = &child.node()->as<MemberSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClassPropertyDeclarationSyntax* ClassPropertyDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClassPropertyDeclarationSyntax));
    return new (mem) ClassPropertyDeclarationSyntax(*this);
}

bool ClassScopeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClassScope;
}

TokenOrSyntax ClassScopeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return separator;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClassScopeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return separator;
        default: return nullptr;
    }
}

void ClassScopeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<NameSyntax>(); return;
        case 1: separator = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ClassScopeSyntax* ClassScopeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClassScopeSyntax));
    return new (mem) ClassScopeSyntax(*this);
}

bool ClockingDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClockingDeclaration;
}

TokenOrSyntax ClockingDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return globalOrDefault;
        case 2: return clocking;
        case 3: return blockName;
        case 4: return at;
        case 5: return event;
        case 6: return eventIdentifier;
        case 7: return semi;
        case 8: return &items;
        case 9: return endClocking;
        case 10: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClockingDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return globalOrDefault;
        case 2: return clocking;
        case 3: return blockName;
        case 4: return at;
        case 5: return event;
        case 6: return eventIdentifier;
        case 7: return semi;
        case 8: return &items;
        case 9: return endClocking;
        case 10: return endBlockName;
        default: return nullptr;
    }
}

void ClockingDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: globalOrDefault = child.token(); return;
        case 2: clocking = child.token(); return;
        case 3: blockName = child.token(); return;
        case 4: at = child.token(); return;
        case 5: event = &child.node()->as<ParenthesizedEventExpressionSyntax>(); return;
        case 6: eventIdentifier = child.token(); return;
        case 7: semi = child.token(); return;
        case 8: items = child.node()->as<SyntaxList<ClockingItemSyntax>>(); return;
        case 9: endClocking = child.token(); return;
        case 10: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClockingDeclarationSyntax* ClockingDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClockingDeclarationSyntax));
    return new (mem) ClockingDeclarationSyntax(*this);
}

bool ClockingDirectionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClockingDirection;
}

TokenOrSyntax ClockingDirectionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return input;
        case 1: return inputSkew;
        case 2: return output;
        case 3: return ouputSkew;
        case 4: return inout;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClockingDirectionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return input;
        case 1: return inputSkew;
        case 2: return output;
        case 3: return ouputSkew;
        case 4: return inout;
        default: return nullptr;
    }
}

void ClockingDirectionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: input = child.token(); return;
        case 1: inputSkew = &child.node()->as<ClockingSkewSyntax>(); return;
        case 2: output = child.token(); return;
        case 3: ouputSkew = &child.node()->as<ClockingSkewSyntax>(); return;
        case 4: inout = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ClockingDirectionSyntax* ClockingDirectionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClockingDirectionSyntax));
    return new (mem) ClockingDirectionSyntax(*this);
}

bool ClockingItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClockingItem;
}

TokenOrSyntax ClockingItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return defaultKeyword;
        case 1: return direction;
        case 2: return &assignments;
        case 3: return semi;
        case 4: return declaration;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClockingItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return defaultKeyword;
        case 1: return direction;
        case 2: return &assignments;
        case 3: return semi;
        case 4: return declaration;
        default: return nullptr;
    }
}

void ClockingItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: defaultKeyword = child.token(); return;
        case 1: direction = &child.node()->as<ClockingDirectionSyntax>(); return;
        case 2: assignments = child.node()->as<SeparatedSyntaxList<AttributeSpecSyntax>>(); return;
        case 3: semi = child.token(); return;
        case 4: declaration = &child.node()->as<MemberSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClockingItemSyntax* ClockingItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClockingItemSyntax));
    return new (mem) ClockingItemSyntax(*this);
}

bool ClockingSkewSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ClockingSkew;
}

TokenOrSyntax ClockingSkewSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return edge;
        case 1: return hash;
        case 2: return value;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ClockingSkewSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return edge;
        case 1: return hash;
        case 2: return value;
        default: return nullptr;
    }
}

void ClockingSkewSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: edge = child.token(); return;
        case 1: hash = child.token(); return;
        case 2: value = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ClockingSkewSyntax* ClockingSkewSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ClockingSkewSyntax));
    return new (mem) ClockingSkewSyntax(*this);
}

bool ColonExpressionClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ColonExpressionClause;
}

TokenOrSyntax ColonExpressionClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return colon;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ColonExpressionClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return colon;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void ColonExpressionClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: colon = child.token(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ColonExpressionClauseSyntax* ColonExpressionClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ColonExpressionClauseSyntax));
    return new (mem) ColonExpressionClauseSyntax(*this);
}

bool CompilationUnitSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CompilationUnit;
}

TokenOrSyntax CompilationUnitSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &members;
        case 1: return endOfFile;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CompilationUnitSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &members;
        case 1: return endOfFile;
        default: return nullptr;
    }
}

void CompilationUnitSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 1: endOfFile = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

CompilationUnitSyntax* CompilationUnitSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CompilationUnitSyntax));
    return new (mem) CompilationUnitSyntax(*this);
}

bool ConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConcatenationExpression;
}

TokenOrSyntax ConcatenationExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return &expressions;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConcatenationExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return &expressions;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

void ConcatenationExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 2: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ConcatenationExpressionSyntax* ConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConcatenationExpressionSyntax));
    return new (mem) ConcatenationExpressionSyntax(*this);
}

bool ConcurrentAssertionMemberSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConcurrentAssertionMember;
}

TokenOrSyntax ConcurrentAssertionMemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConcurrentAssertionMemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return statement.get();
        default: return nullptr;
    }
}

void ConcurrentAssertionMemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: statement = &child.node()->as<ConcurrentAssertionStatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConcurrentAssertionMemberSyntax* ConcurrentAssertionMemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConcurrentAssertionMemberSyntax));
    return new (mem) ConcurrentAssertionMemberSyntax(*this);
}

bool ConcurrentAssertionStatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AssertPropertyStatement:
        case SyntaxKind::AssumePropertyStatement:
        case SyntaxKind::CoverPropertyStatement:
        case SyntaxKind::CoverSequenceStatement:
        case SyntaxKind::ExpectPropertyStatement:
        case SyntaxKind::RestrictPropertyStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ConcurrentAssertionStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return propertyOrSequence;
        case 4: return openParen;
        case 5: return propertySpec.get();
        case 6: return closeParen;
        case 7: return action.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConcurrentAssertionStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return propertyOrSequence;
        case 4: return openParen;
        case 5: return propertySpec.get();
        case 6: return closeParen;
        case 7: return action.get();
        default: return nullptr;
    }
}

void ConcurrentAssertionStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: keyword = child.token(); return;
        case 3: propertyOrSequence = child.token(); return;
        case 4: openParen = child.token(); return;
        case 5: propertySpec = &child.node()->as<PropertySpecSyntax>(); return;
        case 6: closeParen = child.token(); return;
        case 7: action = &child.node()->as<ActionBlockSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConcurrentAssertionStatementSyntax* ConcurrentAssertionStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConcurrentAssertionStatementSyntax));
    return new (mem) ConcurrentAssertionStatementSyntax(*this);
}

bool ConditionalBranchDirectiveSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ElsIfDirective:
        case SyntaxKind::IfDefDirective:
        case SyntaxKind::IfNDefDirective:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ConditionalBranchDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return name;
        case 2: return endOfDirective;
        case 3: return &disabledTokens;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConditionalBranchDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return name;
        case 2: return endOfDirective;
        case 3: return &disabledTokens;
        default: return nullptr;
    }
}

void ConditionalBranchDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: name = child.token(); return;
        case 2: endOfDirective = child.token(); return;
        case 3: disabledTokens = child.node()->as<TokenList>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConditionalBranchDirectiveSyntax* ConditionalBranchDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConditionalBranchDirectiveSyntax));
    return new (mem) ConditionalBranchDirectiveSyntax(*this);
}

bool ConditionalConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConditionalConstraint;
}

TokenOrSyntax ConditionalConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return ifKeyword;
        case 1: return openParen;
        case 2: return condition.get();
        case 3: return closeParen;
        case 4: return constraints.get();
        case 5: return elseClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConditionalConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return ifKeyword;
        case 1: return openParen;
        case 2: return condition.get();
        case 3: return closeParen;
        case 4: return constraints.get();
        case 5: return elseClause;
        default: return nullptr;
    }
}

void ConditionalConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: ifKeyword = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: condition = &child.node()->as<ExpressionSyntax>(); return;
        case 3: closeParen = child.token(); return;
        case 4: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
        case 5: elseClause = &child.node()->as<ElseConstraintClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConditionalConstraintSyntax* ConditionalConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConditionalConstraintSyntax));
    return new (mem) ConditionalConstraintSyntax(*this);
}

bool ConditionalExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConditionalExpression;
}

TokenOrSyntax ConditionalExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return predicate.get();
        case 1: return question;
        case 2: return &attributes;
        case 3: return left.get();
        case 4: return colon;
        case 5: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConditionalExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return predicate.get();
        case 1: return question;
        case 2: return &attributes;
        case 3: return left.get();
        case 4: return colon;
        case 5: return right.get();
        default: return nullptr;
    }
}

void ConditionalExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: predicate = &child.node()->as<ConditionalPredicateSyntax>(); return;
        case 1: question = child.token(); return;
        case 2: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 3: left = &child.node()->as<ExpressionSyntax>(); return;
        case 4: colon = child.token(); return;
        case 5: right = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConditionalExpressionSyntax* ConditionalExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConditionalExpressionSyntax));
    return new (mem) ConditionalExpressionSyntax(*this);
}

bool ConditionalPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConditionalPattern;
}

TokenOrSyntax ConditionalPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        case 1: return matchesClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConditionalPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        case 1: return matchesClause;
        default: return nullptr;
    }
}

void ConditionalPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 1: matchesClause = &child.node()->as<MatchesClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConditionalPatternSyntax* ConditionalPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConditionalPatternSyntax));
    return new (mem) ConditionalPatternSyntax(*this);
}

bool ConditionalPredicateSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConditionalPredicate;
}

TokenOrSyntax ConditionalPredicateSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &conditions;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConditionalPredicateSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &conditions;
        default: return nullptr;
    }
}

void ConditionalPredicateSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: conditions = child.node()->as<SeparatedSyntaxList<ConditionalPatternSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConditionalPredicateSyntax* ConditionalPredicateSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConditionalPredicateSyntax));
    return new (mem) ConditionalPredicateSyntax(*this);
}

bool ConditionalStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConditionalStatement;
}

TokenOrSyntax ConditionalStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return uniqueOrPriority;
        case 3: return ifKeyword;
        case 4: return openParen;
        case 5: return predicate.get();
        case 6: return closeParen;
        case 7: return statement.get();
        case 8: return elseClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConditionalStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return uniqueOrPriority;
        case 3: return ifKeyword;
        case 4: return openParen;
        case 5: return predicate.get();
        case 6: return closeParen;
        case 7: return statement.get();
        case 8: return elseClause;
        default: return nullptr;
    }
}

void ConditionalStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: uniqueOrPriority = child.token(); return;
        case 3: ifKeyword = child.token(); return;
        case 4: openParen = child.token(); return;
        case 5: predicate = &child.node()->as<ConditionalPredicateSyntax>(); return;
        case 6: closeParen = child.token(); return;
        case 7: statement = &child.node()->as<StatementSyntax>(); return;
        case 8: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConditionalStatementSyntax* ConditionalStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConditionalStatementSyntax));
    return new (mem) ConditionalStatementSyntax(*this);
}

bool ConstraintBlockSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConstraintBlock;
}

TokenOrSyntax ConstraintBlockSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return &items;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConstraintBlockSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return &items;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

void ConstraintBlockSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: items = child.node()->as<SyntaxList<ConstraintItemSyntax>>(); return;
        case 2: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ConstraintBlockSyntax* ConstraintBlockSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConstraintBlockSyntax));
    return new (mem) ConstraintBlockSyntax(*this);
}

bool ConstraintDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConstraintDeclaration;
}

TokenOrSyntax ConstraintDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return keyword;
        case 3: return name;
        case 4: return block.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConstraintDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return keyword;
        case 3: return name;
        case 4: return block.get();
        default: return nullptr;
    }
}

void ConstraintDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: qualifiers = child.node()->as<TokenList>(); return;
        case 2: keyword = child.token(); return;
        case 3: name = child.token(); return;
        case 4: block = &child.node()->as<ConstraintBlockSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ConstraintDeclarationSyntax* ConstraintDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConstraintDeclarationSyntax));
    return new (mem) ConstraintDeclarationSyntax(*this);
}

bool ConstraintItemSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ConditionalConstraint:
        case SyntaxKind::ConstraintBlock:
        case SyntaxKind::DisableConstraint:
        case SyntaxKind::ExpressionConstraint:
        case SyntaxKind::ImplicationConstraint:
        case SyntaxKind::LoopConstraint:
        case SyntaxKind::SolveBeforeConstraint:
        case SyntaxKind::UniquenessConstraint:
            return true;
        default:
            return false;
    }
}

bool ConstraintPrototypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ConstraintPrototype;
}

TokenOrSyntax ConstraintPrototypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return keyword;
        case 3: return name;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ConstraintPrototypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return keyword;
        case 3: return name;
        case 4: return semi;
        default: return nullptr;
    }
}

void ConstraintPrototypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: qualifiers = child.node()->as<TokenList>(); return;
        case 2: keyword = child.token(); return;
        case 3: name = child.token(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ConstraintPrototypeSyntax* ConstraintPrototypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ConstraintPrototypeSyntax));
    return new (mem) ConstraintPrototypeSyntax(*this);
}

bool ContinuousAssignSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ContinuousAssign;
}

TokenOrSyntax ContinuousAssignSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return assign;
        case 2: return &assignments;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ContinuousAssignSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return assign;
        case 2: return &assignments;
        case 3: return semi;
        default: return nullptr;
    }
}

void ContinuousAssignSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: assign = child.token(); return;
        case 2: assignments = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ContinuousAssignSyntax* ContinuousAssignSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ContinuousAssignSyntax));
    return new (mem) ContinuousAssignSyntax(*this);
}

bool CoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::DefaultCoverageBinInitializer:
        case SyntaxKind::ExpressionCoverageBinInitializer:
        case SyntaxKind::RangeCoverageBinInitializer:
        case SyntaxKind::TransListCoverageBinInitializer:
            return true;
        default:
            return false;
    }
}

bool CoverageBinsSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CoverageBins;
}

TokenOrSyntax CoverageBinsSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return wildcard;
        case 2: return keyword;
        case 3: return name;
        case 4: return selector;
        case 5: return equals;
        case 6: return initializer.get();
        case 7: return iff;
        case 8: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CoverageBinsSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return wildcard;
        case 2: return keyword;
        case 3: return name;
        case 4: return selector;
        case 5: return equals;
        case 6: return initializer.get();
        case 7: return iff;
        case 8: return semi;
        default: return nullptr;
    }
}

void CoverageBinsSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: wildcard = child.token(); return;
        case 2: keyword = child.token(); return;
        case 3: name = child.token(); return;
        case 4: selector = &child.node()->as<ElementSelectSyntax>(); return;
        case 5: equals = child.token(); return;
        case 6: initializer = &child.node()->as<CoverageBinInitializerSyntax>(); return;
        case 7: iff = &child.node()->as<IffClauseSyntax>(); return;
        case 8: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

CoverageBinsSyntax* CoverageBinsSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CoverageBinsSyntax));
    return new (mem) CoverageBinsSyntax(*this);
}

bool CoverageOptionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CoverageOption;
}

TokenOrSyntax CoverageOptionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return option;
        case 2: return dot;
        case 3: return name;
        case 4: return equals;
        case 5: return expr.get();
        case 6: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CoverageOptionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return option;
        case 2: return dot;
        case 3: return name;
        case 4: return equals;
        case 5: return expr.get();
        case 6: return semi;
        default: return nullptr;
    }
}

void CoverageOptionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: option = child.token(); return;
        case 2: dot = child.token(); return;
        case 3: name = child.token(); return;
        case 4: equals = child.token(); return;
        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 6: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

CoverageOptionSyntax* CoverageOptionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CoverageOptionSyntax));
    return new (mem) CoverageOptionSyntax(*this);
}

bool CovergroupDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::CovergroupDeclaration;
}

TokenOrSyntax CovergroupDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return covergroup;
        case 2: return name;
        case 3: return portList;
        case 4: return event;
        case 5: return semi;
        case 6: return &members;
        case 7: return endgroup;
        case 8: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CovergroupDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return covergroup;
        case 2: return name;
        case 3: return portList;
        case 4: return event;
        case 5: return semi;
        case 6: return &members;
        case 7: return endgroup;
        case 8: return endBlockName;
        default: return nullptr;
    }
}

void CovergroupDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: covergroup = child.token(); return;
        case 2: name = child.token(); return;
        case 3: portList = &child.node()->as<AnsiPortListSyntax>(); return;
        case 4: event = &child.node()->as<SyntaxNode>(); return;
        case 5: semi = child.token(); return;
        case 6: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 7: endgroup = child.token(); return;
        case 8: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

CovergroupDeclarationSyntax* CovergroupDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CovergroupDeclarationSyntax));
    return new (mem) CovergroupDeclarationSyntax(*this);
}

bool CoverpointSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::Coverpoint;
}

TokenOrSyntax CoverpointSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return type;
        case 2: return label;
        case 3: return coverpoint;
        case 4: return expr.get();
        case 5: return openBrace;
        case 6: return &members;
        case 7: return closeBrace;
        case 8: return emptySemi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax CoverpointSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return type;
        case 2: return label;
        case 3: return coverpoint;
        case 4: return expr.get();
        case 5: return openBrace;
        case 6: return &members;
        case 7: return closeBrace;
        case 8: return emptySemi;
        default: return nullptr;
    }
}

void CoverpointSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
        case 2: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 3: coverpoint = child.token(); return;
        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 5: openBrace = child.token(); return;
        case 6: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 7: closeBrace = child.token(); return;
        case 8: emptySemi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

CoverpointSyntax* CoverpointSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(CoverpointSyntax));
    return new (mem) CoverpointSyntax(*this);
}

bool DPIImportExportSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DPIImportExport;
}

TokenOrSyntax DPIImportExportSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return stringLiteral;
        case 3: return property;
        case 4: return name;
        case 5: return equals;
        case 6: return method.get();
        case 7: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DPIImportExportSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return stringLiteral;
        case 3: return property;
        case 4: return name;
        case 5: return equals;
        case 6: return method.get();
        case 7: return semi;
        default: return nullptr;
    }
}

void DPIImportExportSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: stringLiteral = child.token(); return;
        case 3: property = child.token(); return;
        case 4: name = child.token(); return;
        case 5: equals = child.token(); return;
        case 6: method = &child.node()->as<FunctionPrototypeSyntax>(); return;
        case 7: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DPIImportExportSyntax* DPIImportExportSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DPIImportExportSyntax));
    return new (mem) DPIImportExportSyntax(*this);
}

bool DataDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DataDeclaration;
}

TokenOrSyntax DataDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &modifiers;
        case 2: return type.get();
        case 3: return &declarators;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DataDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &modifiers;
        case 2: return type.get();
        case 3: return &declarators;
        case 4: return semi;
        default: return nullptr;
    }
}

void DataDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: modifiers = child.node()->as<TokenList>(); return;
        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
        case 3: declarators = child.node()->as<SeparatedSyntaxList<VariableDeclaratorSyntax>>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DataDeclarationSyntax* DataDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DataDeclarationSyntax));
    return new (mem) DataDeclarationSyntax(*this);
}

bool DataTypeSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::BitType:
        case SyntaxKind::ByteType:
        case SyntaxKind::CHandleType:
        case SyntaxKind::EnumType:
        case SyntaxKind::EventType:
        case SyntaxKind::ImplicitType:
        case SyntaxKind::IntType:
        case SyntaxKind::IntegerType:
        case SyntaxKind::LogicType:
        case SyntaxKind::LongIntType:
        case SyntaxKind::NamedType:
        case SyntaxKind::PropertyType:
        case SyntaxKind::RealTimeType:
        case SyntaxKind::RealType:
        case SyntaxKind::RegType:
        case SyntaxKind::SequenceType:
        case SyntaxKind::ShortIntType:
        case SyntaxKind::ShortRealType:
        case SyntaxKind::StringType:
        case SyntaxKind::StructType:
        case SyntaxKind::TimeType:
        case SyntaxKind::TypeReference:
        case SyntaxKind::TypeType:
        case SyntaxKind::UnionType:
        case SyntaxKind::Untyped:
        case SyntaxKind::VarDataType:
        case SyntaxKind::VirtualInterfaceType:
        case SyntaxKind::VoidType:
            return true;
        default:
            return false;
    }
}

bool DefParamAssignmentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DefParamAssignment;
}

TokenOrSyntax DefParamAssignmentSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name.get();
        case 1: return setter;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DefParamAssignmentSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name.get();
        case 1: return setter;
        default: return nullptr;
    }
}

void DefParamAssignmentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = &child.node()->as<NameSyntax>(); return;
        case 1: setter = &child.node()->as<EqualsValueClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

DefParamAssignmentSyntax* DefParamAssignmentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DefParamAssignmentSyntax));
    return new (mem) DefParamAssignmentSyntax(*this);
}

bool DefParamSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DefParam;
}

TokenOrSyntax DefParamSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return defparam;
        case 2: return &assignments;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DefParamSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return defparam;
        case 2: return &assignments;
        case 3: return semi;
        default: return nullptr;
    }
}

void DefParamSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: defparam = child.token(); return;
        case 2: assignments = child.node()->as<SeparatedSyntaxList<DefParamAssignmentSyntax>>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DefParamSyntax* DefParamSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DefParamSyntax));
    return new (mem) DefParamSyntax(*this);
}

bool DefaultCaseItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DefaultCaseItem;
}

TokenOrSyntax DefaultCaseItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return defaultKeyword;
        case 1: return colon;
        case 2: return clause.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax DefaultCaseItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return defaultKeyword;
        case 1: return colon;
        case 2: return clause.get();
        default: return nullptr;
    }
}

void DefaultCaseItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: defaultKeyword = child.token(); return;
        case 1: colon = child.token(); return;
        case 2: clause = &child.node()->as<SyntaxNode>(); return;
        default: THROW_UNREACHABLE;
    }
}

DefaultCaseItemSyntax* DefaultCaseItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DefaultCaseItemSyntax));
    return new (mem) DefaultCaseItemSyntax(*this);
}

bool DefaultCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DefaultCoverageBinInitializer;
}

TokenOrSyntax DefaultCoverageBinInitializerSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return defaultKeyword;
        case 1: return sequenceKeyword;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DefaultCoverageBinInitializerSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return defaultKeyword;
        case 1: return sequenceKeyword;
        default: return nullptr;
    }
}

void DefaultCoverageBinInitializerSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: defaultKeyword = child.token(); return;
        case 1: sequenceKeyword = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DefaultCoverageBinInitializerSyntax* DefaultCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DefaultCoverageBinInitializerSyntax));
    return new (mem) DefaultCoverageBinInitializerSyntax(*this);
}

bool DefaultNetTypeDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DefaultNetTypeDirective;
}

TokenOrSyntax DefaultNetTypeDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return netType;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DefaultNetTypeDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return netType;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

void DefaultNetTypeDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: netType = child.token(); return;
        case 2: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DefaultNetTypeDirectiveSyntax* DefaultNetTypeDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DefaultNetTypeDirectiveSyntax));
    return new (mem) DefaultNetTypeDirectiveSyntax(*this);
}

bool DeferredAssertionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DeferredAssertion;
}

TokenOrSyntax DeferredAssertionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return hash;
        case 1: return zero;
        case 2: return finalKeyword;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DeferredAssertionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return hash;
        case 1: return zero;
        case 2: return finalKeyword;
        default: return nullptr;
    }
}

void DeferredAssertionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: hash = child.token(); return;
        case 1: zero = child.token(); return;
        case 2: finalKeyword = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DeferredAssertionSyntax* DeferredAssertionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DeferredAssertionSyntax));
    return new (mem) DeferredAssertionSyntax(*this);
}

bool DefineDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DefineDirective;
}

TokenOrSyntax DefineDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return name;
        case 2: return formalArguments;
        case 3: return &body;
        case 4: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DefineDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return name;
        case 2: return formalArguments;
        case 3: return &body;
        case 4: return endOfDirective;
        default: return nullptr;
    }
}

void DefineDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: name = child.token(); return;
        case 2: formalArguments = &child.node()->as<MacroFormalArgumentListSyntax>(); return;
        case 3: body = child.node()->as<TokenList>(); return;
        case 4: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DefineDirectiveSyntax* DefineDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DefineDirectiveSyntax));
    return new (mem) DefineDirectiveSyntax(*this);
}

bool DelaySyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::CycleDelay:
        case SyntaxKind::DelayControl:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax DelaySyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return hash;
        case 1: return delayValue.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax DelaySyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return hash;
        case 1: return delayValue.get();
        default: return nullptr;
    }
}

void DelaySyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: hash = child.token(); return;
        case 1: delayValue = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

DelaySyntax* DelaySyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DelaySyntax));
    return new (mem) DelaySyntax(*this);
}

bool DimensionSpecifierSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::QueueDimensionSpecifier:
        case SyntaxKind::RangeDimensionSpecifier:
        case SyntaxKind::WildcardDimensionSpecifier:
            return true;
        default:
            return false;
    }
}

bool DirectiveSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::BeginKeywordsDirective:
        case SyntaxKind::CellDefineDirective:
        case SyntaxKind::DefaultNetTypeDirective:
        case SyntaxKind::DefineDirective:
        case SyntaxKind::ElsIfDirective:
        case SyntaxKind::ElseDirective:
        case SyntaxKind::EndCellDefineDirective:
        case SyntaxKind::EndIfDirective:
        case SyntaxKind::EndKeywordsDirective:
        case SyntaxKind::IfDefDirective:
        case SyntaxKind::IfNDefDirective:
        case SyntaxKind::IncludeDirective:
        case SyntaxKind::LineDirective:
        case SyntaxKind::MacroUsage:
        case SyntaxKind::NoUnconnectedDriveDirective:
        case SyntaxKind::PragmaDirective:
        case SyntaxKind::ResetAllDirective:
        case SyntaxKind::TimescaleDirective:
        case SyntaxKind::UnconnectedDriveDirective:
        case SyntaxKind::UndefDirective:
        case SyntaxKind::UndefineAllDirective:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax DirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        default: return nullptr;
    }
}

void DirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DirectiveSyntax* DirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DirectiveSyntax));
    return new (mem) DirectiveSyntax(*this);
}

bool DisableConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DisableConstraint;
}

TokenOrSyntax DisableConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return disable;
        case 1: return soft;
        case 2: return name.get();
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DisableConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return disable;
        case 1: return soft;
        case 2: return name.get();
        case 3: return semi;
        default: return nullptr;
    }
}

void DisableConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: disable = child.token(); return;
        case 1: soft = child.token(); return;
        case 2: name = &child.node()->as<NameSyntax>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DisableConstraintSyntax* DisableConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DisableConstraintSyntax));
    return new (mem) DisableConstraintSyntax(*this);
}

bool DisableForkStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DisableForkStatement;
}

TokenOrSyntax DisableForkStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return disable;
        case 3: return fork;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DisableForkStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return disable;
        case 3: return fork;
        case 4: return semi;
        default: return nullptr;
    }
}

void DisableForkStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: disable = child.token(); return;
        case 3: fork = child.token(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DisableForkStatementSyntax* DisableForkStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DisableForkStatementSyntax));
    return new (mem) DisableForkStatementSyntax(*this);
}

bool DisableIffSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DisableIff;
}

TokenOrSyntax DisableIffSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return disable;
        case 1: return iff;
        case 2: return openParen;
        case 3: return expr.get();
        case 4: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DisableIffSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return disable;
        case 1: return iff;
        case 2: return openParen;
        case 3: return expr.get();
        case 4: return closeParen;
        default: return nullptr;
    }
}

void DisableIffSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: disable = child.token(); return;
        case 1: iff = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 4: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DisableIffSyntax* DisableIffSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DisableIffSyntax));
    return new (mem) DisableIffSyntax(*this);
}

bool DisableStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DisableStatement;
}

TokenOrSyntax DisableStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return disable;
        case 3: return name.get();
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DisableStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return disable;
        case 3: return name.get();
        case 4: return semi;
        default: return nullptr;
    }
}

void DisableStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: disable = child.token(); return;
        case 3: name = &child.node()->as<NameSyntax>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DisableStatementSyntax* DisableStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DisableStatementSyntax));
    return new (mem) DisableStatementSyntax(*this);
}

bool DistConstraintListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DistConstraintList;
}

TokenOrSyntax DistConstraintListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dist;
        case 1: return openBrace;
        case 2: return &items;
        case 3: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DistConstraintListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dist;
        case 1: return openBrace;
        case 2: return &items;
        case 3: return closeBrace;
        default: return nullptr;
    }
}

void DistConstraintListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dist = child.token(); return;
        case 1: openBrace = child.token(); return;
        case 2: items = child.node()->as<SeparatedSyntaxList<DistItemSyntax>>(); return;
        case 3: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DistConstraintListSyntax* DistConstraintListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DistConstraintListSyntax));
    return new (mem) DistConstraintListSyntax(*this);
}

bool DistItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DistItem;
}

TokenOrSyntax DistItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return range.get();
        case 1: return weight;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DistItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return range.get();
        case 1: return weight;
        default: return nullptr;
    }
}

void DistItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: range = &child.node()->as<ExpressionSyntax>(); return;
        case 1: weight = &child.node()->as<DistWeightSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

DistItemSyntax* DistItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DistItemSyntax));
    return new (mem) DistItemSyntax(*this);
}

bool DistWeightSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DistWeight;
}

TokenOrSyntax DistWeightSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return op;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax DistWeightSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return op;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void DistWeightSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: op = child.token(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

DistWeightSyntax* DistWeightSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DistWeightSyntax));
    return new (mem) DistWeightSyntax(*this);
}

bool DividerClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DividerClause;
}

TokenOrSyntax DividerClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return divide;
        case 1: return value;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DividerClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return divide;
        case 1: return value;
        default: return nullptr;
    }
}

void DividerClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: divide = child.token(); return;
        case 1: value = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DividerClauseSyntax* DividerClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DividerClauseSyntax));
    return new (mem) DividerClauseSyntax(*this);
}

bool DoWhileStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DoWhileStatement;
}

TokenOrSyntax DoWhileStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return doKeyword;
        case 3: return statement.get();
        case 4: return whileKeyword;
        case 5: return openParen;
        case 6: return expr.get();
        case 7: return closeParen;
        case 8: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DoWhileStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return doKeyword;
        case 3: return statement.get();
        case 4: return whileKeyword;
        case 5: return openParen;
        case 6: return expr.get();
        case 7: return closeParen;
        case 8: return semi;
        default: return nullptr;
    }
}

void DoWhileStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: doKeyword = child.token(); return;
        case 3: statement = &child.node()->as<StatementSyntax>(); return;
        case 4: whileKeyword = child.token(); return;
        case 5: openParen = child.token(); return;
        case 6: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 7: closeParen = child.token(); return;
        case 8: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DoWhileStatementSyntax* DoWhileStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DoWhileStatementSyntax));
    return new (mem) DoWhileStatementSyntax(*this);
}

bool DotMemberClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DotMemberClause;
}

TokenOrSyntax DotMemberClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dot;
        case 1: return member;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DotMemberClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dot;
        case 1: return member;
        default: return nullptr;
    }
}

void DotMemberClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dot = child.token(); return;
        case 1: member = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DotMemberClauseSyntax* DotMemberClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DotMemberClauseSyntax));
    return new (mem) DotMemberClauseSyntax(*this);
}

bool DriveStrengthSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::DriveStrength;
}

TokenOrSyntax DriveStrengthSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return strength0;
        case 2: return comma;
        case 3: return strength1;
        case 4: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax DriveStrengthSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return strength0;
        case 2: return comma;
        case 3: return strength1;
        case 4: return closeParen;
        default: return nullptr;
    }
}

void DriveStrengthSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: strength0 = child.token(); return;
        case 2: comma = child.token(); return;
        case 3: strength1 = child.token(); return;
        case 4: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

DriveStrengthSyntax* DriveStrengthSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(DriveStrengthSyntax));
    return new (mem) DriveStrengthSyntax(*this);
}

bool ElementSelectExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ElementSelectExpression;
}

TokenOrSyntax ElementSelectExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return select.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ElementSelectExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return select.get();
        default: return nullptr;
    }
}

void ElementSelectExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: select = &child.node()->as<ElementSelectSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ElementSelectExpressionSyntax* ElementSelectExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ElementSelectExpressionSyntax));
    return new (mem) ElementSelectExpressionSyntax(*this);
}

bool ElementSelectSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ElementSelect;
}

TokenOrSyntax ElementSelectSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBracket;
        case 1: return selector;
        case 2: return closeBracket;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ElementSelectSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBracket;
        case 1: return selector;
        case 2: return closeBracket;
        default: return nullptr;
    }
}

void ElementSelectSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBracket = child.token(); return;
        case 1: selector = &child.node()->as<SelectorSyntax>(); return;
        case 2: closeBracket = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ElementSelectSyntax* ElementSelectSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ElementSelectSyntax));
    return new (mem) ElementSelectSyntax(*this);
}

bool ElseClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ElseClause;
}

TokenOrSyntax ElseClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return elseKeyword;
        case 1: return clause.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ElseClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return elseKeyword;
        case 1: return clause.get();
        default: return nullptr;
    }
}

void ElseClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: elseKeyword = child.token(); return;
        case 1: clause = &child.node()->as<SyntaxNode>(); return;
        default: THROW_UNREACHABLE;
    }
}

ElseClauseSyntax* ElseClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ElseClauseSyntax));
    return new (mem) ElseClauseSyntax(*this);
}

bool ElseConstraintClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ElseConstraintClause;
}

TokenOrSyntax ElseConstraintClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return elseKeyword;
        case 1: return constraints.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ElseConstraintClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return elseKeyword;
        case 1: return constraints.get();
        default: return nullptr;
    }
}

void ElseConstraintClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: elseKeyword = child.token(); return;
        case 1: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ElseConstraintClauseSyntax* ElseConstraintClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ElseConstraintClauseSyntax));
    return new (mem) ElseConstraintClauseSyntax(*this);
}

bool EmptyArgumentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EmptyArgument;
}

TokenOrSyntax EmptyArgumentSyntax::getChild(uint32_t index) {
    (void)index;
    return nullptr;
}

ConstTokenOrSyntax EmptyArgumentSyntax::getChild(uint32_t index) const {
    (void)index;
    return nullptr;
}

void EmptyArgumentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    (void)index;
    (void)child;
}

EmptyArgumentSyntax* EmptyArgumentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EmptyArgumentSyntax));
    return new (mem) EmptyArgumentSyntax(*this);
}

bool EmptyIdentifierNameSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EmptyIdentifierName;
}

TokenOrSyntax EmptyIdentifierNameSyntax::getChild(uint32_t index) {
    (void)index;
    return nullptr;
}

ConstTokenOrSyntax EmptyIdentifierNameSyntax::getChild(uint32_t index) const {
    (void)index;
    return nullptr;
}

void EmptyIdentifierNameSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    (void)index;
    (void)child;
}

EmptyIdentifierNameSyntax* EmptyIdentifierNameSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EmptyIdentifierNameSyntax));
    return new (mem) EmptyIdentifierNameSyntax(*this);
}

bool EmptyMemberSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EmptyMember;
}

TokenOrSyntax EmptyMemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax EmptyMemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return &qualifiers;
        case 2: return semi;
        default: return nullptr;
    }
}

void EmptyMemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: qualifiers = child.node()->as<TokenList>(); return;
        case 2: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

EmptyMemberSyntax* EmptyMemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EmptyMemberSyntax));
    return new (mem) EmptyMemberSyntax(*this);
}

bool EmptyQueueExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EmptyQueueExpression;
}

TokenOrSyntax EmptyQueueExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax EmptyQueueExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return closeBrace;
        default: return nullptr;
    }
}

void EmptyQueueExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

EmptyQueueExpressionSyntax* EmptyQueueExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EmptyQueueExpressionSyntax));
    return new (mem) EmptyQueueExpressionSyntax(*this);
}

bool EmptyStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EmptyStatement;
}

TokenOrSyntax EmptyStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return semicolon;
        default: return nullptr;
    }
}

ConstTokenOrSyntax EmptyStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return semicolon;
        default: return nullptr;
    }
}

void EmptyStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: semicolon = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

EmptyStatementSyntax* EmptyStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EmptyStatementSyntax));
    return new (mem) EmptyStatementSyntax(*this);
}

bool EnumTypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EnumType;
}

TokenOrSyntax EnumTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return baseType;
        case 2: return openBrace;
        case 3: return &members;
        case 4: return closeBrace;
        case 5: return &dimensions;
        default: return nullptr;
    }
}

ConstTokenOrSyntax EnumTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return baseType;
        case 2: return openBrace;
        case 3: return &members;
        case 4: return closeBrace;
        case 5: return &dimensions;
        default: return nullptr;
    }
}

void EnumTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: baseType = &child.node()->as<DataTypeSyntax>(); return;
        case 2: openBrace = child.token(); return;
        case 3: members = child.node()->as<SeparatedSyntaxList<VariableDeclaratorSyntax>>(); return;
        case 4: closeBrace = child.token(); return;
        case 5: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

EnumTypeSyntax* EnumTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EnumTypeSyntax));
    return new (mem) EnumTypeSyntax(*this);
}

bool EqualsValueClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EqualsValueClause;
}

TokenOrSyntax EqualsValueClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return equals;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax EqualsValueClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return equals;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void EqualsValueClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: equals = child.token(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

EqualsValueClauseSyntax* EqualsValueClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EqualsValueClauseSyntax));
    return new (mem) EqualsValueClauseSyntax(*this);
}

bool EventControlSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EventControl;
}

TokenOrSyntax EventControlSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return at;
        case 1: return eventName.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax EventControlSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return at;
        case 1: return eventName.get();
        default: return nullptr;
    }
}

void EventControlSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: at = child.token(); return;
        case 1: eventName = &child.node()->as<NameSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

EventControlSyntax* EventControlSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EventControlSyntax));
    return new (mem) EventControlSyntax(*this);
}

bool EventControlWithExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::EventControlWithExpression;
}

TokenOrSyntax EventControlWithExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return at;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax EventControlWithExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return at;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void EventControlWithExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: at = child.token(); return;
        case 1: expr = &child.node()->as<EventExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

EventControlWithExpressionSyntax* EventControlWithExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EventControlWithExpressionSyntax));
    return new (mem) EventControlWithExpressionSyntax(*this);
}

bool EventExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::BinaryEventExpression:
        case SyntaxKind::ParenthesizedEventExpression:
        case SyntaxKind::SignalEventExpression:
            return true;
        default:
            return false;
    }
}

bool EventTriggerStatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::BlockingEventTriggerStatement:
        case SyntaxKind::NonblockingEventTriggerStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax EventTriggerStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return trigger;
        case 3: return timing;
        case 4: return name.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax EventTriggerStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return trigger;
        case 3: return timing;
        case 4: return name.get();
        default: return nullptr;
    }
}

void EventTriggerStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: trigger = child.token(); return;
        case 3: timing = &child.node()->as<TimingControlSyntax>(); return;
        case 4: name = &child.node()->as<NameSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

EventTriggerStatementSyntax* EventTriggerStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(EventTriggerStatementSyntax));
    return new (mem) EventTriggerStatementSyntax(*this);
}

bool ExplicitAnsiPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExplicitAnsiPort;
}

TokenOrSyntax ExplicitAnsiPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return direction;
        case 2: return dot;
        case 3: return name;
        case 4: return openParen;
        case 5: return expr;
        case 6: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExplicitAnsiPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return direction;
        case 2: return dot;
        case 3: return name;
        case 4: return openParen;
        case 5: return expr;
        case 6: return closeParen;
        default: return nullptr;
    }
}

void ExplicitAnsiPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: direction = child.token(); return;
        case 2: dot = child.token(); return;
        case 3: name = child.token(); return;
        case 4: openParen = child.token(); return;
        case 5: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 6: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ExplicitAnsiPortSyntax* ExplicitAnsiPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExplicitAnsiPortSyntax));
    return new (mem) ExplicitAnsiPortSyntax(*this);
}

bool ExplicitNonAnsiPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExplicitNonAnsiPort;
}

TokenOrSyntax ExplicitNonAnsiPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dot;
        case 1: return name;
        case 2: return openParen;
        case 3: return expr;
        case 4: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExplicitNonAnsiPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dot;
        case 1: return name;
        case 2: return openParen;
        case 3: return expr;
        case 4: return closeParen;
        default: return nullptr;
    }
}

void ExplicitNonAnsiPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dot = child.token(); return;
        case 1: name = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 4: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ExplicitNonAnsiPortSyntax* ExplicitNonAnsiPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExplicitNonAnsiPortSyntax));
    return new (mem) ExplicitNonAnsiPortSyntax(*this);
}

bool ExpressionConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExpressionConstraint;
}

TokenOrSyntax ExpressionConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return soft;
        case 1: return expr.get();
        case 2: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExpressionConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return soft;
        case 1: return expr.get();
        case 2: return semi;
        default: return nullptr;
    }
}

void ExpressionConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: soft = child.token(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 2: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ExpressionConstraintSyntax* ExpressionConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExpressionConstraintSyntax));
    return new (mem) ExpressionConstraintSyntax(*this);
}

bool ExpressionCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExpressionCoverageBinInitializer;
}

TokenOrSyntax ExpressionCoverageBinInitializerSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        case 1: return withClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExpressionCoverageBinInitializerSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        case 1: return withClause;
        default: return nullptr;
    }
}

void ExpressionCoverageBinInitializerSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ExpressionCoverageBinInitializerSyntax* ExpressionCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExpressionCoverageBinInitializerSyntax));
    return new (mem) ExpressionCoverageBinInitializerSyntax(*this);
}

bool ExpressionOrDistSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExpressionOrDist;
}

TokenOrSyntax ExpressionOrDistSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        case 1: return distribution.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExpressionOrDistSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        case 1: return distribution.get();
        default: return nullptr;
    }
}

void ExpressionOrDistSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 1: distribution = &child.node()->as<DistConstraintListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ExpressionOrDistSyntax* ExpressionOrDistSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExpressionOrDistSyntax));
    return new (mem) ExpressionOrDistSyntax(*this);
}

bool ExpressionPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExpressionPattern;
}

TokenOrSyntax ExpressionPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExpressionPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

void ExpressionPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ExpressionPatternSyntax* ExpressionPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExpressionPatternSyntax));
    return new (mem) ExpressionPatternSyntax(*this);
}

bool ExpressionStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExpressionStatement;
}

TokenOrSyntax ExpressionStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return expr.get();
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExpressionStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return expr.get();
        case 3: return semi;
        default: return nullptr;
    }
}

void ExpressionStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ExpressionStatementSyntax* ExpressionStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExpressionStatementSyntax));
    return new (mem) ExpressionStatementSyntax(*this);
}

bool ExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AcceptOnPropertyExpression:
        case SyntaxKind::AddAssignmentExpression:
        case SyntaxKind::AddExpression:
        case SyntaxKind::AlwaysPropertyExpression:
        case SyntaxKind::AndAssignmentExpression:
        case SyntaxKind::AndSequenceExpression:
        case SyntaxKind::ArithmeticLeftShiftAssignmentExpression:
        case SyntaxKind::ArithmeticRightShiftAssignmentExpression:
        case SyntaxKind::ArithmeticShiftLeftExpression:
        case SyntaxKind::ArithmeticShiftRightExpression:
        case SyntaxKind::ArrayAndMethod:
        case SyntaxKind::ArrayOrMethod:
        case SyntaxKind::ArrayUniqueMethod:
        case SyntaxKind::ArrayXorMethod:
        case SyntaxKind::AssignmentExpression:
        case SyntaxKind::AssignmentPatternExpression:
        case SyntaxKind::BadExpression:
        case SyntaxKind::BinaryAndExpression:
        case SyntaxKind::BinaryOrExpression:
        case SyntaxKind::BinarySequenceDelayExpression:
        case SyntaxKind::BinaryXnorExpression:
        case SyntaxKind::BinaryXorExpression:
        case SyntaxKind::BitType:
        case SyntaxKind::ByteType:
        case SyntaxKind::CHandleType:
        case SyntaxKind::CaseEqualityExpression:
        case SyntaxKind::CaseInequalityExpression:
        case SyntaxKind::CastExpression:
        case SyntaxKind::ClassName:
        case SyntaxKind::ClassScope:
        case SyntaxKind::ConcatenationExpression:
        case SyntaxKind::ConditionalExpression:
        case SyntaxKind::ConstructorName:
        case SyntaxKind::DefaultPatternKeyExpression:
        case SyntaxKind::DivideAssignmentExpression:
        case SyntaxKind::DivideExpression:
        case SyntaxKind::ElementSelect:
        case SyntaxKind::ElementSelectExpression:
        case SyntaxKind::EmptyIdentifierName:
        case SyntaxKind::EmptyQueueExpression:
        case SyntaxKind::EnumType:
        case SyntaxKind::EqualityExpression:
        case SyntaxKind::EventType:
        case SyntaxKind::EventuallyPropertyExpression:
        case SyntaxKind::ExpressionOrDist:
        case SyntaxKind::GreaterThanEqualExpression:
        case SyntaxKind::GreaterThanExpression:
        case SyntaxKind::IdentifierName:
        case SyntaxKind::IdentifierSelectName:
        case SyntaxKind::IffPropertyExpression:
        case SyntaxKind::ImplicitType:
        case SyntaxKind::ImpliesPropertyExpression:
        case SyntaxKind::InequalityExpression:
        case SyntaxKind::InsideExpression:
        case SyntaxKind::IntType:
        case SyntaxKind::IntegerLiteralExpression:
        case SyntaxKind::IntegerType:
        case SyntaxKind::IntegerVectorExpression:
        case SyntaxKind::IntersectSequenceExpression:
        case SyntaxKind::InvocationExpression:
        case SyntaxKind::LessThanEqualExpression:
        case SyntaxKind::LessThanExpression:
        case SyntaxKind::LocalScope:
        case SyntaxKind::LogicType:
        case SyntaxKind::LogicalAndExpression:
        case SyntaxKind::LogicalEquivalenceExpression:
        case SyntaxKind::LogicalImplicationExpression:
        case SyntaxKind::LogicalLeftShiftAssignmentExpression:
        case SyntaxKind::LogicalOrExpression:
        case SyntaxKind::LogicalRightShiftAssignmentExpression:
        case SyntaxKind::LogicalShiftLeftExpression:
        case SyntaxKind::LogicalShiftRightExpression:
        case SyntaxKind::LongIntType:
        case SyntaxKind::MemberAccessExpression:
        case SyntaxKind::MinTypMaxExpression:
        case SyntaxKind::ModAssignmentExpression:
        case SyntaxKind::ModExpression:
        case SyntaxKind::MultipleConcatenationExpression:
        case SyntaxKind::MultiplyAssignmentExpression:
        case SyntaxKind::MultiplyExpression:
        case SyntaxKind::NamedType:
        case SyntaxKind::NewArrayExpression:
        case SyntaxKind::NewClassExpression:
        case SyntaxKind::NewExpression:
        case SyntaxKind::NextTimePropertyExpression:
        case SyntaxKind::NonOverlappedFollowedByPropertyExpression:
        case SyntaxKind::NonOverlappedImplicationPropertyExpression:
        case SyntaxKind::NonblockingAssignmentExpression:
        case SyntaxKind::NullLiteralExpression:
        case SyntaxKind::OneStepLiteralExpression:
        case SyntaxKind::OrAssignmentExpression:
        case SyntaxKind::OrSequenceExpression:
        case SyntaxKind::OverlappedFollowedByPropertyExpression:
        case SyntaxKind::OverlappedImplicationPropertyExpression:
        case SyntaxKind::ParenthesizedExpression:
        case SyntaxKind::PostdecrementExpression:
        case SyntaxKind::PostincrementExpression:
        case SyntaxKind::PowerExpression:
        case SyntaxKind::PropertyType:
        case SyntaxKind::RandomizeMethodWithClause:
        case SyntaxKind::RealLiteralExpression:
        case SyntaxKind::RealTimeType:
        case SyntaxKind::RealType:
        case SyntaxKind::RegType:
        case SyntaxKind::RejectOnPropertyExpression:
        case SyntaxKind::RootScope:
        case SyntaxKind::SAlwaysPropertyExpression:
        case SyntaxKind::SEventuallyPropertyExpression:
        case SyntaxKind::SNextTimePropertyExpression:
        case SyntaxKind::SUntilPropertyExpression:
        case SyntaxKind::SUntilWithPropertyExpression:
        case SyntaxKind::ScopedName:
        case SyntaxKind::SequenceType:
        case SyntaxKind::ShortIntType:
        case SyntaxKind::ShortRealType:
        case SyntaxKind::SignedCastExpression:
        case SyntaxKind::StreamingConcatenationExpression:
        case SyntaxKind::StringLiteralExpression:
        case SyntaxKind::StringType:
        case SyntaxKind::StructType:
        case SyntaxKind::SubtractAssignmentExpression:
        case SyntaxKind::SubtractExpression:
        case SyntaxKind::SuperHandle:
        case SyntaxKind::SyncAcceptOnPropertyExpression:
        case SyntaxKind::SyncRejectOnPropertyExpression:
        case SyntaxKind::SystemName:
        case SyntaxKind::TaggedUnionExpression:
        case SyntaxKind::ThisHandle:
        case SyntaxKind::ThroughoutSequenceExpression:
        case SyntaxKind::TimeLiteralExpression:
        case SyntaxKind::TimeType:
        case SyntaxKind::TimingControlExpression:
        case SyntaxKind::TimingControlExpressionConcatenation:
        case SyntaxKind::TypeReference:
        case SyntaxKind::TypeType:
        case SyntaxKind::UnaryBitwiseAndExpression:
        case SyntaxKind::UnaryBitwiseNandExpression:
        case SyntaxKind::UnaryBitwiseNorExpression:
        case SyntaxKind::UnaryBitwiseNotExpression:
        case SyntaxKind::UnaryBitwiseOrExpression:
        case SyntaxKind::UnaryBitwiseXnorExpression:
        case SyntaxKind::UnaryBitwiseXorExpression:
        case SyntaxKind::UnaryLogicalNotExpression:
        case SyntaxKind::UnaryMinusExpression:
        case SyntaxKind::UnaryNotPropertyExpression:
        case SyntaxKind::UnaryPlusExpression:
        case SyntaxKind::UnaryPredecrementExpression:
        case SyntaxKind::UnaryPreincrementExpression:
        case SyntaxKind::UnarySequenceDelayExpression:
        case SyntaxKind::UnarySequenceEventExpression:
        case SyntaxKind::UnbasedUnsizedLiteralExpression:
        case SyntaxKind::UnionType:
        case SyntaxKind::UnitScope:
        case SyntaxKind::UntilPropertyExpression:
        case SyntaxKind::UntilWithPropertyExpression:
        case SyntaxKind::Untyped:
        case SyntaxKind::VarDataType:
        case SyntaxKind::VirtualInterfaceType:
        case SyntaxKind::VoidType:
        case SyntaxKind::WildcardEqualityExpression:
        case SyntaxKind::WildcardInequalityExpression:
        case SyntaxKind::WildcardLiteralExpression:
        case SyntaxKind::WithClause:
        case SyntaxKind::WithinSequenceExpression:
        case SyntaxKind::XorAssignmentExpression:
            return true;
        default:
            return false;
    }
}

bool ExtendsClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExtendsClause;
}

TokenOrSyntax ExtendsClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return baseName.get();
        case 2: return arguments;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExtendsClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return baseName.get();
        case 2: return arguments;
        default: return nullptr;
    }
}

void ExtendsClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: baseName = &child.node()->as<NameSyntax>(); return;
        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ExtendsClauseSyntax* ExtendsClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExtendsClauseSyntax));
    return new (mem) ExtendsClauseSyntax(*this);
}

bool ExternModuleSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ExternModule;
}

TokenOrSyntax ExternModuleSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return externKeyword;
        case 1: return header.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ExternModuleSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return externKeyword;
        case 1: return header.get();
        default: return nullptr;
    }
}

void ExternModuleSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: externKeyword = child.token(); return;
        case 1: header = &child.node()->as<ModuleHeaderSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ExternModuleSyntax* ExternModuleSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ExternModuleSyntax));
    return new (mem) ExternModuleSyntax(*this);
}

bool ForLoopStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForLoopStatement;
}

TokenOrSyntax ForLoopStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return forKeyword;
        case 3: return openParen;
        case 4: return &initializers;
        case 5: return semi1;
        case 6: return stopExpr.get();
        case 7: return semi2;
        case 8: return &steps;
        case 9: return closeParen;
        case 10: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForLoopStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return forKeyword;
        case 3: return openParen;
        case 4: return &initializers;
        case 5: return semi1;
        case 6: return stopExpr.get();
        case 7: return semi2;
        case 8: return &steps;
        case 9: return closeParen;
        case 10: return statement.get();
        default: return nullptr;
    }
}

void ForLoopStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: forKeyword = child.token(); return;
        case 3: openParen = child.token(); return;
        case 4: initializers = child.node()->as<SeparatedSyntaxList<SyntaxNode>>(); return;
        case 5: semi1 = child.token(); return;
        case 6: stopExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 7: semi2 = child.token(); return;
        case 8: steps = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 9: closeParen = child.token(); return;
        case 10: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ForLoopStatementSyntax* ForLoopStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForLoopStatementSyntax));
    return new (mem) ForLoopStatementSyntax(*this);
}

bool ForVariableDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForVariableDeclaration;
}

TokenOrSyntax ForVariableDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return varKeyword;
        case 1: return type.get();
        case 2: return declarator.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForVariableDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return varKeyword;
        case 1: return type.get();
        case 2: return declarator.get();
        default: return nullptr;
    }
}

void ForVariableDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: varKeyword = child.token(); return;
        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
        case 2: declarator = &child.node()->as<VariableDeclaratorSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ForVariableDeclarationSyntax* ForVariableDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForVariableDeclarationSyntax));
    return new (mem) ForVariableDeclarationSyntax(*this);
}

bool ForeachLoopListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForeachLoopList;
}

TokenOrSyntax ForeachLoopListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return arrayName.get();
        case 2: return openBracket;
        case 3: return &loopVariables;
        case 4: return closeBracket;
        case 5: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForeachLoopListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return arrayName.get();
        case 2: return openBracket;
        case 3: return &loopVariables;
        case 4: return closeBracket;
        case 5: return closeParen;
        default: return nullptr;
    }
}

void ForeachLoopListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: arrayName = &child.node()->as<NameSyntax>(); return;
        case 2: openBracket = child.token(); return;
        case 3: loopVariables = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
        case 4: closeBracket = child.token(); return;
        case 5: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ForeachLoopListSyntax* ForeachLoopListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForeachLoopListSyntax));
    return new (mem) ForeachLoopListSyntax(*this);
}

bool ForeachLoopStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForeachLoopStatement;
}

TokenOrSyntax ForeachLoopStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return loopList.get();
        case 4: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForeachLoopStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return loopList.get();
        case 4: return statement.get();
        default: return nullptr;
    }
}

void ForeachLoopStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: keyword = child.token(); return;
        case 3: loopList = &child.node()->as<ForeachLoopListSyntax>(); return;
        case 4: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ForeachLoopStatementSyntax* ForeachLoopStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForeachLoopStatementSyntax));
    return new (mem) ForeachLoopStatementSyntax(*this);
}

bool ForeverStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForeverStatement;
}

TokenOrSyntax ForeverStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return foreverKeyword;
        case 3: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForeverStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return foreverKeyword;
        case 3: return statement.get();
        default: return nullptr;
    }
}

void ForeverStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: foreverKeyword = child.token(); return;
        case 3: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ForeverStatementSyntax* ForeverStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForeverStatementSyntax));
    return new (mem) ForeverStatementSyntax(*this);
}

bool ForwardInterfaceClassTypedefDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForwardInterfaceClassTypedefDeclaration;
}

TokenOrSyntax ForwardInterfaceClassTypedefDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return typedefKeyword;
        case 2: return interfaceKeyword;
        case 3: return classKeyword;
        case 4: return name;
        case 5: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForwardInterfaceClassTypedefDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return typedefKeyword;
        case 2: return interfaceKeyword;
        case 3: return classKeyword;
        case 4: return name;
        case 5: return semi;
        default: return nullptr;
    }
}

void ForwardInterfaceClassTypedefDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: typedefKeyword = child.token(); return;
        case 2: interfaceKeyword = child.token(); return;
        case 3: classKeyword = child.token(); return;
        case 4: name = child.token(); return;
        case 5: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ForwardInterfaceClassTypedefDeclarationSyntax* ForwardInterfaceClassTypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForwardInterfaceClassTypedefDeclarationSyntax));
    return new (mem) ForwardInterfaceClassTypedefDeclarationSyntax(*this);
}

bool ForwardTypedefDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ForwardTypedefDeclaration;
}

TokenOrSyntax ForwardTypedefDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return typedefKeyword;
        case 2: return keyword;
        case 3: return name;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ForwardTypedefDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return typedefKeyword;
        case 2: return keyword;
        case 3: return name;
        case 4: return semi;
        default: return nullptr;
    }
}

void ForwardTypedefDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: typedefKeyword = child.token(); return;
        case 2: keyword = child.token(); return;
        case 3: name = child.token(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ForwardTypedefDeclarationSyntax* ForwardTypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ForwardTypedefDeclarationSyntax));
    return new (mem) ForwardTypedefDeclarationSyntax(*this);
}

bool FunctionDeclarationSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::FunctionDeclaration:
        case SyntaxKind::TaskDeclaration:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax FunctionDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return prototype.get();
        case 2: return semi;
        case 3: return &items;
        case 4: return end;
        case 5: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax FunctionDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return prototype.get();
        case 2: return semi;
        case 3: return &items;
        case 4: return end;
        case 5: return endBlockName;
        default: return nullptr;
    }
}

void FunctionDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
        case 2: semi = child.token(); return;
        case 3: items = child.node()->as<SyntaxList<SyntaxNode>>(); return;
        case 4: end = child.token(); return;
        case 5: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

FunctionDeclarationSyntax* FunctionDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(FunctionDeclarationSyntax));
    return new (mem) FunctionDeclarationSyntax(*this);
}

bool FunctionPortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::FunctionPortList;
}

TokenOrSyntax FunctionPortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax FunctionPortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void FunctionPortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: ports = child.node()->as<SeparatedSyntaxList<FunctionPortSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

FunctionPortListSyntax* FunctionPortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(FunctionPortListSyntax));
    return new (mem) FunctionPortListSyntax(*this);
}

bool FunctionPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::FunctionPort;
}

TokenOrSyntax FunctionPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return constKeyword;
        case 2: return direction;
        case 3: return varKeyword;
        case 4: return dataType;
        case 5: return declarator.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax FunctionPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return constKeyword;
        case 2: return direction;
        case 3: return varKeyword;
        case 4: return dataType;
        case 5: return declarator.get();
        default: return nullptr;
    }
}

void FunctionPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: constKeyword = child.token(); return;
        case 2: direction = child.token(); return;
        case 3: varKeyword = child.token(); return;
        case 4: dataType = &child.node()->as<DataTypeSyntax>(); return;
        case 5: declarator = &child.node()->as<VariableDeclaratorSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

FunctionPortSyntax* FunctionPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(FunctionPortSyntax));
    return new (mem) FunctionPortSyntax(*this);
}

bool FunctionPrototypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::FunctionPrototype;
}

TokenOrSyntax FunctionPrototypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return lifetime;
        case 2: return returnType;
        case 3: return name.get();
        case 4: return portList;
        default: return nullptr;
    }
}

ConstTokenOrSyntax FunctionPrototypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return lifetime;
        case 2: return returnType;
        case 3: return name.get();
        case 4: return portList;
        default: return nullptr;
    }
}

void FunctionPrototypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: lifetime = child.token(); return;
        case 2: returnType = &child.node()->as<DataTypeSyntax>(); return;
        case 3: name = &child.node()->as<NameSyntax>(); return;
        case 4: portList = &child.node()->as<FunctionPortListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

FunctionPrototypeSyntax* FunctionPrototypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(FunctionPrototypeSyntax));
    return new (mem) FunctionPrototypeSyntax(*this);
}

bool GenerateBlockSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::GenerateBlock;
}

TokenOrSyntax GenerateBlockSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return label;
        case 2: return begin;
        case 3: return beginName;
        case 4: return &members;
        case 5: return end;
        case 6: return endName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax GenerateBlockSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return label;
        case 2: return begin;
        case 3: return beginName;
        case 4: return &members;
        case 5: return end;
        case 6: return endName;
        default: return nullptr;
    }
}

void GenerateBlockSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 2: begin = child.token(); return;
        case 3: beginName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        case 4: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 5: end = child.token(); return;
        case 6: endName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

GenerateBlockSyntax* GenerateBlockSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(GenerateBlockSyntax));
    return new (mem) GenerateBlockSyntax(*this);
}

bool GenerateRegionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::GenerateRegion;
}

TokenOrSyntax GenerateRegionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &members;
        case 3: return endgenerate;
        default: return nullptr;
    }
}

ConstTokenOrSyntax GenerateRegionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &members;
        case 3: return endgenerate;
        default: return nullptr;
    }
}

void GenerateRegionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 3: endgenerate = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

GenerateRegionSyntax* GenerateRegionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(GenerateRegionSyntax));
    return new (mem) GenerateRegionSyntax(*this);
}

bool GenvarDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::GenvarDeclaration;
}

TokenOrSyntax GenvarDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &identifiers;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax GenvarDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &identifiers;
        case 3: return semi;
        default: return nullptr;
    }
}

void GenvarDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: identifiers = child.node()->as<SeparatedSyntaxList<IdentifierNameSyntax>>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

GenvarDeclarationSyntax* GenvarDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(GenvarDeclarationSyntax));
    return new (mem) GenvarDeclarationSyntax(*this);
}

bool HierarchicalInstanceSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::HierarchicalInstance;
}

TokenOrSyntax HierarchicalInstanceSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return &dimensions;
        case 2: return openParen;
        case 3: return &connections;
        case 4: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax HierarchicalInstanceSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return &dimensions;
        case 2: return openParen;
        case 3: return &connections;
        case 4: return closeParen;
        default: return nullptr;
    }
}

void HierarchicalInstanceSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        case 2: openParen = child.token(); return;
        case 3: connections = child.node()->as<SeparatedSyntaxList<PortConnectionSyntax>>(); return;
        case 4: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

HierarchicalInstanceSyntax* HierarchicalInstanceSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(HierarchicalInstanceSyntax));
    return new (mem) HierarchicalInstanceSyntax(*this);
}

bool HierarchyInstantiationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::HierarchyInstantiation;
}

TokenOrSyntax HierarchyInstantiationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return type;
        case 2: return parameters;
        case 3: return &instances;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax HierarchyInstantiationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return type;
        case 2: return parameters;
        case 3: return &instances;
        case 4: return semi;
        default: return nullptr;
    }
}

void HierarchyInstantiationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: type = child.token(); return;
        case 2: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
        case 3: instances = child.node()->as<SeparatedSyntaxList<HierarchicalInstanceSyntax>>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

HierarchyInstantiationSyntax* HierarchyInstantiationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(HierarchyInstantiationSyntax));
    return new (mem) HierarchyInstantiationSyntax(*this);
}

bool IdentifierListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IdentifierList;
}

TokenOrSyntax IdentifierListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &identifiers;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IdentifierListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &identifiers;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void IdentifierListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: identifiers = child.node()->as<SeparatedSyntaxList<IdentifierNameSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

IdentifierListSyntax* IdentifierListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IdentifierListSyntax));
    return new (mem) IdentifierListSyntax(*this);
}

bool IdentifierNameSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IdentifierName;
}

TokenOrSyntax IdentifierNameSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return identifier;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IdentifierNameSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return identifier;
        default: return nullptr;
    }
}

void IdentifierNameSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: identifier = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

IdentifierNameSyntax* IdentifierNameSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IdentifierNameSyntax));
    return new (mem) IdentifierNameSyntax(*this);
}

bool IdentifierSelectNameSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IdentifierSelectName;
}

TokenOrSyntax IdentifierSelectNameSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return identifier;
        case 1: return &selectors;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IdentifierSelectNameSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return identifier;
        case 1: return &selectors;
        default: return nullptr;
    }
}

void IdentifierSelectNameSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: identifier = child.token(); return;
        case 1: selectors = child.node()->as<SyntaxList<ElementSelectSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

IdentifierSelectNameSyntax* IdentifierSelectNameSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IdentifierSelectNameSyntax));
    return new (mem) IdentifierSelectNameSyntax(*this);
}

bool IfGenerateSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IfGenerate;
}

TokenOrSyntax IfGenerateSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return openParen;
        case 3: return condition.get();
        case 4: return closeParen;
        case 5: return block.get();
        case 6: return elseClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IfGenerateSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return openParen;
        case 3: return condition.get();
        case 4: return closeParen;
        case 5: return block.get();
        case 6: return elseClause;
        default: return nullptr;
    }
}

void IfGenerateSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: condition = &child.node()->as<ExpressionSyntax>(); return;
        case 4: closeParen = child.token(); return;
        case 5: block = &child.node()->as<MemberSyntax>(); return;
        case 6: elseClause = &child.node()->as<ElseClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

IfGenerateSyntax* IfGenerateSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IfGenerateSyntax));
    return new (mem) IfGenerateSyntax(*this);
}

bool IffClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IffClause;
}

TokenOrSyntax IffClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return iff;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IffClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return iff;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

void IffClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: iff = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

IffClauseSyntax* IffClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IffClauseSyntax));
    return new (mem) IffClauseSyntax(*this);
}

bool ImmediateAssertionMemberSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImmediateAssertionMember;
}

TokenOrSyntax ImmediateAssertionMemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImmediateAssertionMemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return statement.get();
        default: return nullptr;
    }
}

void ImmediateAssertionMemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: statement = &child.node()->as<ImmediateAssertionStatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImmediateAssertionMemberSyntax* ImmediateAssertionMemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImmediateAssertionMemberSyntax));
    return new (mem) ImmediateAssertionMemberSyntax(*this);
}

bool ImmediateAssertionStatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ImmediateAssertStatement:
        case SyntaxKind::ImmediateAssumeStatement:
        case SyntaxKind::ImmediateCoverStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ImmediateAssertionStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return delay;
        case 4: return expr.get();
        case 5: return action.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImmediateAssertionStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return delay;
        case 4: return expr.get();
        case 5: return action.get();
        default: return nullptr;
    }
}

void ImmediateAssertionStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: keyword = child.token(); return;
        case 3: delay = &child.node()->as<DeferredAssertionSyntax>(); return;
        case 4: expr = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
        case 5: action = &child.node()->as<ActionBlockSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImmediateAssertionStatementSyntax* ImmediateAssertionStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImmediateAssertionStatementSyntax));
    return new (mem) ImmediateAssertionStatementSyntax(*this);
}

bool ImplementsClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImplementsClause;
}

TokenOrSyntax ImplementsClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return &interfaces;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImplementsClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return &interfaces;
        default: return nullptr;
    }
}

void ImplementsClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: interfaces = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImplementsClauseSyntax* ImplementsClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImplementsClauseSyntax));
    return new (mem) ImplementsClauseSyntax(*this);
}

bool ImplicationConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImplicationConstraint;
}

TokenOrSyntax ImplicationConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return arrow;
        case 2: return constraints.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImplicationConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return arrow;
        case 2: return constraints.get();
        default: return nullptr;
    }
}

void ImplicationConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: arrow = child.token(); return;
        case 2: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImplicationConstraintSyntax* ImplicationConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImplicationConstraintSyntax));
    return new (mem) ImplicationConstraintSyntax(*this);
}

bool ImplicitAnsiPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImplicitAnsiPort;
}

TokenOrSyntax ImplicitAnsiPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return header.get();
        case 2: return declarator.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImplicitAnsiPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return header.get();
        case 2: return declarator.get();
        default: return nullptr;
    }
}

void ImplicitAnsiPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: header = &child.node()->as<PortHeaderSyntax>(); return;
        case 2: declarator = &child.node()->as<VariableDeclaratorSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImplicitAnsiPortSyntax* ImplicitAnsiPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImplicitAnsiPortSyntax));
    return new (mem) ImplicitAnsiPortSyntax(*this);
}

bool ImplicitEventControlSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImplicitEventControl;
}

TokenOrSyntax ImplicitEventControlSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return atStar;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImplicitEventControlSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return atStar;
        default: return nullptr;
    }
}

void ImplicitEventControlSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: atStar = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ImplicitEventControlSyntax* ImplicitEventControlSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImplicitEventControlSyntax));
    return new (mem) ImplicitEventControlSyntax(*this);
}

bool ImplicitNonAnsiPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImplicitNonAnsiPort;
}

TokenOrSyntax ImplicitNonAnsiPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImplicitNonAnsiPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

void ImplicitNonAnsiPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImplicitNonAnsiPortSyntax* ImplicitNonAnsiPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImplicitNonAnsiPortSyntax));
    return new (mem) ImplicitNonAnsiPortSyntax(*this);
}

bool ImplicitTypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ImplicitType;
}

TokenOrSyntax ImplicitTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return signing;
        case 1: return &dimensions;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ImplicitTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return signing;
        case 1: return &dimensions;
        default: return nullptr;
    }
}

void ImplicitTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: signing = child.token(); return;
        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

ImplicitTypeSyntax* ImplicitTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ImplicitTypeSyntax));
    return new (mem) ImplicitTypeSyntax(*this);
}

bool IncludeDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IncludeDirective;
}

TokenOrSyntax IncludeDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return fileName;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IncludeDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return fileName;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

void IncludeDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: fileName = child.token(); return;
        case 2: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

IncludeDirectiveSyntax* IncludeDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IncludeDirectiveSyntax));
    return new (mem) IncludeDirectiveSyntax(*this);
}

bool InsideExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::InsideExpression;
}

TokenOrSyntax InsideExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        case 1: return inside;
        case 2: return ranges.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax InsideExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        case 1: return inside;
        case 2: return ranges.get();
        default: return nullptr;
    }
}

void InsideExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 1: inside = child.token(); return;
        case 2: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

InsideExpressionSyntax* InsideExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(InsideExpressionSyntax));
    return new (mem) InsideExpressionSyntax(*this);
}

bool IntegerTypeSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::BitType:
        case SyntaxKind::ByteType:
        case SyntaxKind::IntType:
        case SyntaxKind::IntegerType:
        case SyntaxKind::LogicType:
        case SyntaxKind::LongIntType:
        case SyntaxKind::RegType:
        case SyntaxKind::ShortIntType:
        case SyntaxKind::TimeType:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax IntegerTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return signing;
        case 2: return &dimensions;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IntegerTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return signing;
        case 2: return &dimensions;
        default: return nullptr;
    }
}

void IntegerTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: signing = child.token(); return;
        case 2: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

IntegerTypeSyntax* IntegerTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IntegerTypeSyntax));
    return new (mem) IntegerTypeSyntax(*this);
}

bool IntegerVectorExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::IntegerVectorExpression;
}

TokenOrSyntax IntegerVectorExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return size;
        case 1: return base;
        case 2: return value;
        default: return nullptr;
    }
}

ConstTokenOrSyntax IntegerVectorExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return size;
        case 1: return base;
        case 2: return value;
        default: return nullptr;
    }
}

void IntegerVectorExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: size = child.token(); return;
        case 1: base = child.token(); return;
        case 2: value = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

IntegerVectorExpressionSyntax* IntegerVectorExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(IntegerVectorExpressionSyntax));
    return new (mem) IntegerVectorExpressionSyntax(*this);
}

bool InterconnectPortHeaderSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::InterconnectPortHeader;
}

TokenOrSyntax InterconnectPortHeaderSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return direction;
        case 1: return interconnect;
        case 2: return type;
        default: return nullptr;
    }
}

ConstTokenOrSyntax InterconnectPortHeaderSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return direction;
        case 1: return interconnect;
        case 2: return type;
        default: return nullptr;
    }
}

void InterconnectPortHeaderSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: direction = child.token(); return;
        case 1: interconnect = child.token(); return;
        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

InterconnectPortHeaderSyntax* InterconnectPortHeaderSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(InterconnectPortHeaderSyntax));
    return new (mem) InterconnectPortHeaderSyntax(*this);
}

bool InterfacePortHeaderSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::InterfacePortHeader;
}

TokenOrSyntax InterfacePortHeaderSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return nameOrKeyword;
        case 1: return modport;
        default: return nullptr;
    }
}

ConstTokenOrSyntax InterfacePortHeaderSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return nameOrKeyword;
        case 1: return modport;
        default: return nullptr;
    }
}

void InterfacePortHeaderSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: nameOrKeyword = child.token(); return;
        case 1: modport = &child.node()->as<DotMemberClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

InterfacePortHeaderSyntax* InterfacePortHeaderSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(InterfacePortHeaderSyntax));
    return new (mem) InterfacePortHeaderSyntax(*this);
}

bool InvocationExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::InvocationExpression;
}

TokenOrSyntax InvocationExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return &attributes;
        case 2: return arguments;
        default: return nullptr;
    }
}

ConstTokenOrSyntax InvocationExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return &attributes;
        case 2: return arguments;
        default: return nullptr;
    }
}

void InvocationExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

InvocationExpressionSyntax* InvocationExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(InvocationExpressionSyntax));
    return new (mem) InvocationExpressionSyntax(*this);
}

bool JumpStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::JumpStatement;
}

TokenOrSyntax JumpStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return breakOrContinue;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax JumpStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return breakOrContinue;
        case 3: return semi;
        default: return nullptr;
    }
}

void JumpStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: breakOrContinue = child.token(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

JumpStatementSyntax* JumpStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(JumpStatementSyntax));
    return new (mem) JumpStatementSyntax(*this);
}

bool KeywordNameSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ArrayAndMethod:
        case SyntaxKind::ArrayOrMethod:
        case SyntaxKind::ArrayUniqueMethod:
        case SyntaxKind::ArrayXorMethod:
        case SyntaxKind::ConstructorName:
        case SyntaxKind::LocalScope:
        case SyntaxKind::RootScope:
        case SyntaxKind::SuperHandle:
        case SyntaxKind::SystemName:
        case SyntaxKind::ThisHandle:
        case SyntaxKind::UnitScope:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax KeywordNameSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        default: return nullptr;
    }
}

ConstTokenOrSyntax KeywordNameSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        default: return nullptr;
    }
}

void KeywordNameSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

KeywordNameSyntax* KeywordNameSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(KeywordNameSyntax));
    return new (mem) KeywordNameSyntax(*this);
}

bool KeywordTypeSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::CHandleType:
        case SyntaxKind::EventType:
        case SyntaxKind::PropertyType:
        case SyntaxKind::RealTimeType:
        case SyntaxKind::RealType:
        case SyntaxKind::SequenceType:
        case SyntaxKind::ShortRealType:
        case SyntaxKind::StringType:
        case SyntaxKind::TypeType:
        case SyntaxKind::Untyped:
        case SyntaxKind::VoidType:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax KeywordTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        default: return nullptr;
    }
}

ConstTokenOrSyntax KeywordTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        default: return nullptr;
    }
}

void KeywordTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

KeywordTypeSyntax* KeywordTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(KeywordTypeSyntax));
    return new (mem) KeywordTypeSyntax(*this);
}

bool LetDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::LetDeclaration;
}

TokenOrSyntax LetDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return let;
        case 2: return identifier;
        case 3: return portList;
        case 4: return initializer.get();
        case 5: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax LetDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return let;
        case 2: return identifier;
        case 3: return portList;
        case 4: return initializer.get();
        case 5: return semi;
        default: return nullptr;
    }
}

void LetDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: let = child.token(); return;
        case 2: identifier = child.token(); return;
        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
        case 4: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
        case 5: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

LetDeclarationSyntax* LetDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(LetDeclarationSyntax));
    return new (mem) LetDeclarationSyntax(*this);
}

bool LineDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::LineDirective;
}

TokenOrSyntax LineDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return lineNumber;
        case 2: return fileName;
        case 3: return level;
        case 4: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax LineDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return lineNumber;
        case 2: return fileName;
        case 3: return level;
        case 4: return endOfDirective;
        default: return nullptr;
    }
}

void LineDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: lineNumber = child.token(); return;
        case 2: fileName = child.token(); return;
        case 3: level = child.token(); return;
        case 4: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

LineDirectiveSyntax* LineDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(LineDirectiveSyntax));
    return new (mem) LineDirectiveSyntax(*this);
}

bool LiteralExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::DefaultPatternKeyExpression:
        case SyntaxKind::IntegerLiteralExpression:
        case SyntaxKind::NullLiteralExpression:
        case SyntaxKind::OneStepLiteralExpression:
        case SyntaxKind::RealLiteralExpression:
        case SyntaxKind::StringLiteralExpression:
        case SyntaxKind::TimeLiteralExpression:
        case SyntaxKind::UnbasedUnsizedLiteralExpression:
        case SyntaxKind::WildcardLiteralExpression:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax LiteralExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return literal;
        default: return nullptr;
    }
}

ConstTokenOrSyntax LiteralExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return literal;
        default: return nullptr;
    }
}

void LiteralExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: literal = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

LiteralExpressionSyntax* LiteralExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(LiteralExpressionSyntax));
    return new (mem) LiteralExpressionSyntax(*this);
}

bool LoopConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::LoopConstraint;
}

TokenOrSyntax LoopConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return foreachKeyword;
        case 1: return loopList.get();
        case 2: return constraints.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax LoopConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return foreachKeyword;
        case 1: return loopList.get();
        case 2: return constraints.get();
        default: return nullptr;
    }
}

void LoopConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: foreachKeyword = child.token(); return;
        case 1: loopList = &child.node()->as<ForeachLoopListSyntax>(); return;
        case 2: constraints = &child.node()->as<ConstraintItemSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

LoopConstraintSyntax* LoopConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(LoopConstraintSyntax));
    return new (mem) LoopConstraintSyntax(*this);
}

bool LoopGenerateSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::LoopGenerate;
}

TokenOrSyntax LoopGenerateSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return openParen;
        case 3: return genvar;
        case 4: return identifier;
        case 5: return equals;
        case 6: return initialExpr.get();
        case 7: return semi1;
        case 8: return stopExpr.get();
        case 9: return semi2;
        case 10: return iterationExpr.get();
        case 11: return closeParen;
        case 12: return block.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax LoopGenerateSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return openParen;
        case 3: return genvar;
        case 4: return identifier;
        case 5: return equals;
        case 6: return initialExpr.get();
        case 7: return semi1;
        case 8: return stopExpr.get();
        case 9: return semi2;
        case 10: return iterationExpr.get();
        case 11: return closeParen;
        case 12: return block.get();
        default: return nullptr;
    }
}

void LoopGenerateSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: genvar = child.token(); return;
        case 4: identifier = child.token(); return;
        case 5: equals = child.token(); return;
        case 6: initialExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 7: semi1 = child.token(); return;
        case 8: stopExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 9: semi2 = child.token(); return;
        case 10: iterationExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 11: closeParen = child.token(); return;
        case 12: block = &child.node()->as<MemberSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

LoopGenerateSyntax* LoopGenerateSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(LoopGenerateSyntax));
    return new (mem) LoopGenerateSyntax(*this);
}

bool LoopStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::LoopStatement;
}

TokenOrSyntax LoopStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return repeatOrWhile;
        case 3: return openParen;
        case 4: return expr.get();
        case 5: return closeParen;
        case 6: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax LoopStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return repeatOrWhile;
        case 3: return openParen;
        case 4: return expr.get();
        case 5: return closeParen;
        case 6: return statement.get();
        default: return nullptr;
    }
}

void LoopStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: repeatOrWhile = child.token(); return;
        case 3: openParen = child.token(); return;
        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 5: closeParen = child.token(); return;
        case 6: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

LoopStatementSyntax* LoopStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(LoopStatementSyntax));
    return new (mem) LoopStatementSyntax(*this);
}

bool MacroActualArgumentListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MacroActualArgumentList;
}

TokenOrSyntax MacroActualArgumentListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &args;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MacroActualArgumentListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &args;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void MacroActualArgumentListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: args = child.node()->as<SeparatedSyntaxList<MacroActualArgumentSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

MacroActualArgumentListSyntax* MacroActualArgumentListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MacroActualArgumentListSyntax));
    return new (mem) MacroActualArgumentListSyntax(*this);
}

bool MacroActualArgumentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MacroActualArgument;
}

TokenOrSyntax MacroActualArgumentSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &tokens;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MacroActualArgumentSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &tokens;
        default: return nullptr;
    }
}

void MacroActualArgumentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: tokens = child.node()->as<TokenList>(); return;
        default: THROW_UNREACHABLE;
    }
}

MacroActualArgumentSyntax* MacroActualArgumentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MacroActualArgumentSyntax));
    return new (mem) MacroActualArgumentSyntax(*this);
}

bool MacroArgumentDefaultSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MacroArgumentDefault;
}

TokenOrSyntax MacroArgumentDefaultSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return equals;
        case 1: return &tokens;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MacroArgumentDefaultSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return equals;
        case 1: return &tokens;
        default: return nullptr;
    }
}

void MacroArgumentDefaultSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: equals = child.token(); return;
        case 1: tokens = child.node()->as<TokenList>(); return;
        default: THROW_UNREACHABLE;
    }
}

MacroArgumentDefaultSyntax* MacroArgumentDefaultSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MacroArgumentDefaultSyntax));
    return new (mem) MacroArgumentDefaultSyntax(*this);
}

bool MacroFormalArgumentListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MacroFormalArgumentList;
}

TokenOrSyntax MacroFormalArgumentListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &args;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MacroFormalArgumentListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &args;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void MacroFormalArgumentListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: args = child.node()->as<SeparatedSyntaxList<MacroFormalArgumentSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

MacroFormalArgumentListSyntax* MacroFormalArgumentListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MacroFormalArgumentListSyntax));
    return new (mem) MacroFormalArgumentListSyntax(*this);
}

bool MacroFormalArgumentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MacroFormalArgument;
}

TokenOrSyntax MacroFormalArgumentSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return defaultValue;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MacroFormalArgumentSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return defaultValue;
        default: return nullptr;
    }
}

void MacroFormalArgumentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: defaultValue = &child.node()->as<MacroArgumentDefaultSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

MacroFormalArgumentSyntax* MacroFormalArgumentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MacroFormalArgumentSyntax));
    return new (mem) MacroFormalArgumentSyntax(*this);
}

bool MacroUsageSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MacroUsage;
}

TokenOrSyntax MacroUsageSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return args;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MacroUsageSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return args;
        default: return nullptr;
    }
}

void MacroUsageSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: args = &child.node()->as<MacroActualArgumentListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

MacroUsageSyntax* MacroUsageSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MacroUsageSyntax));
    return new (mem) MacroUsageSyntax(*this);
}

bool MatchesClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MatchesClause;
}

TokenOrSyntax MatchesClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return matchesKeyword;
        case 1: return pattern.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax MatchesClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return matchesKeyword;
        case 1: return pattern.get();
        default: return nullptr;
    }
}

void MatchesClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: matchesKeyword = child.token(); return;
        case 1: pattern = &child.node()->as<PatternSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

MatchesClauseSyntax* MatchesClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MatchesClauseSyntax));
    return new (mem) MatchesClauseSyntax(*this);
}

bool MemberAccessExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MemberAccessExpression;
}

TokenOrSyntax MemberAccessExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return dot;
        case 2: return name;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MemberAccessExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return dot;
        case 2: return name;
        default: return nullptr;
    }
}

void MemberAccessExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: dot = child.token(); return;
        case 2: name = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

MemberAccessExpressionSyntax* MemberAccessExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MemberAccessExpressionSyntax));
    return new (mem) MemberAccessExpressionSyntax(*this);
}

bool MemberSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AlwaysBlock:
        case SyntaxKind::AlwaysCombBlock:
        case SyntaxKind::AlwaysFFBlock:
        case SyntaxKind::AlwaysLatchBlock:
        case SyntaxKind::CaseGenerate:
        case SyntaxKind::ClassDeclaration:
        case SyntaxKind::ClassMethodDeclaration:
        case SyntaxKind::ClassMethodPrototype:
        case SyntaxKind::ClassPropertyDeclaration:
        case SyntaxKind::ClockingDeclaration:
        case SyntaxKind::ConcurrentAssertionMember:
        case SyntaxKind::ConstraintDeclaration:
        case SyntaxKind::ConstraintPrototype:
        case SyntaxKind::ContinuousAssign:
        case SyntaxKind::CoverageBins:
        case SyntaxKind::CoverageOption:
        case SyntaxKind::CovergroupDeclaration:
        case SyntaxKind::Coverpoint:
        case SyntaxKind::DPIImportExport:
        case SyntaxKind::DataDeclaration:
        case SyntaxKind::DefParam:
        case SyntaxKind::EmptyMember:
        case SyntaxKind::ExplicitAnsiPort:
        case SyntaxKind::FinalBlock:
        case SyntaxKind::ForwardInterfaceClassTypedefDeclaration:
        case SyntaxKind::ForwardTypedefDeclaration:
        case SyntaxKind::FunctionDeclaration:
        case SyntaxKind::GenerateBlock:
        case SyntaxKind::GenerateRegion:
        case SyntaxKind::GenvarDeclaration:
        case SyntaxKind::HierarchyInstantiation:
        case SyntaxKind::IfGenerate:
        case SyntaxKind::ImmediateAssertionMember:
        case SyntaxKind::ImplicitAnsiPort:
        case SyntaxKind::InitialBlock:
        case SyntaxKind::InterfaceDeclaration:
        case SyntaxKind::LetDeclaration:
        case SyntaxKind::LoopGenerate:
        case SyntaxKind::ModportClockingPort:
        case SyntaxKind::ModportDeclaration:
        case SyntaxKind::ModportSimplePortList:
        case SyntaxKind::ModportSubroutinePortList:
        case SyntaxKind::ModuleDeclaration:
        case SyntaxKind::NetDeclaration:
        case SyntaxKind::PackageDeclaration:
        case SyntaxKind::PackageImportDeclaration:
        case SyntaxKind::ParameterDeclarationStatement:
        case SyntaxKind::PortDeclaration:
        case SyntaxKind::ProgramDeclaration:
        case SyntaxKind::PropertyDeclaration:
        case SyntaxKind::SequenceDeclaration:
        case SyntaxKind::TaskDeclaration:
        case SyntaxKind::TimeUnitsDeclaration:
        case SyntaxKind::TypedefDeclaration:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax MemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        default: return nullptr;
    }
}

void MemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

MemberSyntax* MemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MemberSyntax));
    return new (mem) MemberSyntax(*this);
}

bool MinTypMaxExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MinTypMaxExpression;
}

TokenOrSyntax MinTypMaxExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return min.get();
        case 1: return colon1;
        case 2: return typ.get();
        case 3: return colon2;
        case 4: return max.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax MinTypMaxExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return min.get();
        case 1: return colon1;
        case 2: return typ.get();
        case 3: return colon2;
        case 4: return max.get();
        default: return nullptr;
    }
}

void MinTypMaxExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: min = &child.node()->as<ExpressionSyntax>(); return;
        case 1: colon1 = child.token(); return;
        case 2: typ = &child.node()->as<ExpressionSyntax>(); return;
        case 3: colon2 = child.token(); return;
        case 4: max = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

MinTypMaxExpressionSyntax* MinTypMaxExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MinTypMaxExpressionSyntax));
    return new (mem) MinTypMaxExpressionSyntax(*this);
}

bool ModportClockingPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportClockingPort;
}

TokenOrSyntax ModportClockingPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return clocking;
        case 2: return name;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportClockingPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return clocking;
        case 2: return name;
        default: return nullptr;
    }
}

void ModportClockingPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: clocking = child.token(); return;
        case 2: name = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportClockingPortSyntax* ModportClockingPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportClockingPortSyntax));
    return new (mem) ModportClockingPortSyntax(*this);
}

bool ModportDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportDeclaration;
}

TokenOrSyntax ModportDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &items;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &items;
        case 3: return semi;
        default: return nullptr;
    }
}

void ModportDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: items = child.node()->as<SeparatedSyntaxList<ModportItemSyntax>>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportDeclarationSyntax* ModportDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportDeclarationSyntax));
    return new (mem) ModportDeclarationSyntax(*this);
}

bool ModportExplicitPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportExplicitPort;
}

TokenOrSyntax ModportExplicitPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dot;
        case 1: return name;
        case 2: return openParen;
        case 3: return expr;
        case 4: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportExplicitPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dot;
        case 1: return name;
        case 2: return openParen;
        case 3: return expr;
        case 4: return closeParen;
        default: return nullptr;
    }
}

void ModportExplicitPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dot = child.token(); return;
        case 1: name = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 4: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportExplicitPortSyntax* ModportExplicitPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportExplicitPortSyntax));
    return new (mem) ModportExplicitPortSyntax(*this);
}

bool ModportItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportItem;
}

TokenOrSyntax ModportItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return ports.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return ports.get();
        default: return nullptr;
    }
}

void ModportItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: ports = &child.node()->as<AnsiPortListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportItemSyntax* ModportItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportItemSyntax));
    return new (mem) ModportItemSyntax(*this);
}

bool ModportNamedPortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportNamedPort;
}

TokenOrSyntax ModportNamedPortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportNamedPortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        default: return nullptr;
    }
}

void ModportNamedPortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportNamedPortSyntax* ModportNamedPortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportNamedPortSyntax));
    return new (mem) ModportNamedPortSyntax(*this);
}

bool ModportPortSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ModportExplicitPort:
        case SyntaxKind::ModportNamedPort:
        case SyntaxKind::ModportSubroutinePort:
            return true;
        default:
            return false;
    }
}

bool ModportSimplePortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportSimplePortList;
}

TokenOrSyntax ModportSimplePortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return direction;
        case 2: return &ports;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportSimplePortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return direction;
        case 2: return &ports;
        default: return nullptr;
    }
}

void ModportSimplePortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: direction = child.token(); return;
        case 2: ports = child.node()->as<SeparatedSyntaxList<ModportPortSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportSimplePortListSyntax* ModportSimplePortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportSimplePortListSyntax));
    return new (mem) ModportSimplePortListSyntax(*this);
}

bool ModportSubroutinePortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportSubroutinePortList;
}

TokenOrSyntax ModportSubroutinePortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return importExport;
        case 2: return &ports;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportSubroutinePortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return importExport;
        case 2: return &ports;
        default: return nullptr;
    }
}

void ModportSubroutinePortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: importExport = child.token(); return;
        case 2: ports = child.node()->as<SeparatedSyntaxList<ModportPortSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportSubroutinePortListSyntax* ModportSubroutinePortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportSubroutinePortListSyntax));
    return new (mem) ModportSubroutinePortListSyntax(*this);
}

bool ModportSubroutinePortSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ModportSubroutinePort;
}

TokenOrSyntax ModportSubroutinePortSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return prototype.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModportSubroutinePortSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return prototype.get();
        default: return nullptr;
    }
}

void ModportSubroutinePortSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: prototype = &child.node()->as<FunctionPrototypeSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ModportSubroutinePortSyntax* ModportSubroutinePortSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModportSubroutinePortSyntax));
    return new (mem) ModportSubroutinePortSyntax(*this);
}

bool ModuleDeclarationSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::InterfaceDeclaration:
        case SyntaxKind::ModuleDeclaration:
        case SyntaxKind::PackageDeclaration:
        case SyntaxKind::ProgramDeclaration:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ModuleDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return header.get();
        case 2: return &members;
        case 3: return endmodule;
        case 4: return blockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModuleDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return header.get();
        case 2: return &members;
        case 3: return endmodule;
        case 4: return blockName;
        default: return nullptr;
    }
}

void ModuleDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: header = &child.node()->as<ModuleHeaderSyntax>(); return;
        case 2: members = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 3: endmodule = child.token(); return;
        case 4: blockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ModuleDeclarationSyntax* ModuleDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModuleDeclarationSyntax));
    return new (mem) ModuleDeclarationSyntax(*this);
}

bool ModuleHeaderSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::InterfaceHeader:
        case SyntaxKind::ModuleHeader:
        case SyntaxKind::PackageHeader:
        case SyntaxKind::ProgramHeader:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ModuleHeaderSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return moduleKeyword;
        case 1: return lifetime;
        case 2: return name;
        case 3: return &imports;
        case 4: return parameters;
        case 5: return ports;
        case 6: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ModuleHeaderSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return moduleKeyword;
        case 1: return lifetime;
        case 2: return name;
        case 3: return &imports;
        case 4: return parameters;
        case 5: return ports;
        case 6: return semi;
        default: return nullptr;
    }
}

void ModuleHeaderSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: moduleKeyword = child.token(); return;
        case 1: lifetime = child.token(); return;
        case 2: name = child.token(); return;
        case 3: imports = child.node()->as<SyntaxList<PackageImportDeclarationSyntax>>(); return;
        case 4: parameters = &child.node()->as<ParameterPortListSyntax>(); return;
        case 5: ports = &child.node()->as<PortListSyntax>(); return;
        case 6: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ModuleHeaderSyntax* ModuleHeaderSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ModuleHeaderSyntax));
    return new (mem) ModuleHeaderSyntax(*this);
}

bool MultipleConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::MultipleConcatenationExpression;
}

TokenOrSyntax MultipleConcatenationExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return expression.get();
        case 2: return concatenation.get();
        case 3: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax MultipleConcatenationExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return expression.get();
        case 2: return concatenation.get();
        case 3: return closeBrace;
        default: return nullptr;
    }
}

void MultipleConcatenationExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: expression = &child.node()->as<ExpressionSyntax>(); return;
        case 2: concatenation = &child.node()->as<ConcatenationExpressionSyntax>(); return;
        case 3: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

MultipleConcatenationExpressionSyntax* MultipleConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(MultipleConcatenationExpressionSyntax));
    return new (mem) MultipleConcatenationExpressionSyntax(*this);
}

bool NameSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ArrayAndMethod:
        case SyntaxKind::ArrayOrMethod:
        case SyntaxKind::ArrayUniqueMethod:
        case SyntaxKind::ArrayXorMethod:
        case SyntaxKind::ClassName:
        case SyntaxKind::ClassScope:
        case SyntaxKind::ConstructorName:
        case SyntaxKind::EmptyIdentifierName:
        case SyntaxKind::IdentifierName:
        case SyntaxKind::IdentifierSelectName:
        case SyntaxKind::LocalScope:
        case SyntaxKind::RootScope:
        case SyntaxKind::ScopedName:
        case SyntaxKind::SuperHandle:
        case SyntaxKind::SystemName:
        case SyntaxKind::ThisHandle:
        case SyntaxKind::UnitScope:
            return true;
        default:
            return false;
    }
}

bool NamedArgumentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NamedArgument;
}

TokenOrSyntax NamedArgumentSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dot;
        case 1: return name;
        case 2: return openParen;
        case 3: return expr;
        case 4: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NamedArgumentSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dot;
        case 1: return name;
        case 2: return openParen;
        case 3: return expr;
        case 4: return closeParen;
        default: return nullptr;
    }
}

void NamedArgumentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dot = child.token(); return;
        case 1: name = child.token(); return;
        case 2: openParen = child.token(); return;
        case 3: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 4: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

NamedArgumentSyntax* NamedArgumentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NamedArgumentSyntax));
    return new (mem) NamedArgumentSyntax(*this);
}

bool NamedBlockClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NamedBlockClause;
}

TokenOrSyntax NamedBlockClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return colon;
        case 1: return name;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NamedBlockClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return colon;
        case 1: return name;
        default: return nullptr;
    }
}

void NamedBlockClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: colon = child.token(); return;
        case 1: name = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

NamedBlockClauseSyntax* NamedBlockClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NamedBlockClauseSyntax));
    return new (mem) NamedBlockClauseSyntax(*this);
}

bool NamedLabelSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NamedLabel;
}

TokenOrSyntax NamedLabelSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return colon;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NamedLabelSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return colon;
        default: return nullptr;
    }
}

void NamedLabelSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: colon = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

NamedLabelSyntax* NamedLabelSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NamedLabelSyntax));
    return new (mem) NamedLabelSyntax(*this);
}

bool NamedPortConnectionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NamedPortConnection;
}

TokenOrSyntax NamedPortConnectionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return dot;
        case 2: return name;
        case 3: return openParen;
        case 4: return expr;
        case 5: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NamedPortConnectionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return dot;
        case 2: return name;
        case 3: return openParen;
        case 4: return expr;
        case 5: return closeParen;
        default: return nullptr;
    }
}

void NamedPortConnectionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: dot = child.token(); return;
        case 2: name = child.token(); return;
        case 3: openParen = child.token(); return;
        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 5: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

NamedPortConnectionSyntax* NamedPortConnectionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NamedPortConnectionSyntax));
    return new (mem) NamedPortConnectionSyntax(*this);
}

bool NamedStructurePatternMemberSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NamedStructurePatternMember;
}

TokenOrSyntax NamedStructurePatternMemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return colon;
        case 2: return pattern.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax NamedStructurePatternMemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return colon;
        case 2: return pattern.get();
        default: return nullptr;
    }
}

void NamedStructurePatternMemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: colon = child.token(); return;
        case 2: pattern = &child.node()->as<PatternSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

NamedStructurePatternMemberSyntax* NamedStructurePatternMemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NamedStructurePatternMemberSyntax));
    return new (mem) NamedStructurePatternMemberSyntax(*this);
}

bool NamedTypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NamedType;
}

TokenOrSyntax NamedTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax NamedTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name.get();
        default: return nullptr;
    }
}

void NamedTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = &child.node()->as<NameSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

NamedTypeSyntax* NamedTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NamedTypeSyntax));
    return new (mem) NamedTypeSyntax(*this);
}

bool NetDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NetDeclaration;
}

TokenOrSyntax NetDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return netType;
        case 2: return strength;
        case 3: return expansionHint;
        case 4: return type.get();
        case 5: return &declarators;
        case 6: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NetDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return netType;
        case 2: return strength;
        case 3: return expansionHint;
        case 4: return type.get();
        case 5: return &declarators;
        case 6: return semi;
        default: return nullptr;
    }
}

void NetDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: netType = child.token(); return;
        case 2: strength = &child.node()->as<NetStrengthSyntax>(); return;
        case 3: expansionHint = child.token(); return;
        case 4: type = &child.node()->as<DataTypeSyntax>(); return;
        case 5: declarators = child.node()->as<SeparatedSyntaxList<VariableDeclaratorSyntax>>(); return;
        case 6: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

NetDeclarationSyntax* NetDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NetDeclarationSyntax));
    return new (mem) NetDeclarationSyntax(*this);
}

bool NetPortHeaderSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NetPortHeader;
}

TokenOrSyntax NetPortHeaderSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return direction;
        case 1: return netType;
        case 2: return dataType.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax NetPortHeaderSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return direction;
        case 1: return netType;
        case 2: return dataType.get();
        default: return nullptr;
    }
}

void NetPortHeaderSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: direction = child.token(); return;
        case 1: netType = child.token(); return;
        case 2: dataType = &child.node()->as<DataTypeSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

NetPortHeaderSyntax* NetPortHeaderSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NetPortHeaderSyntax));
    return new (mem) NetPortHeaderSyntax(*this);
}

bool NetStrengthSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ChargeStrength:
        case SyntaxKind::DriveStrength:
            return true;
        default:
            return false;
    }
}

bool NewArrayExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NewArrayExpression;
}

TokenOrSyntax NewArrayExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return newKeyword;
        case 1: return openBracket;
        case 2: return sizeExpr.get();
        case 3: return closeBracket;
        case 4: return initializer;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NewArrayExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return newKeyword;
        case 1: return openBracket;
        case 2: return sizeExpr.get();
        case 3: return closeBracket;
        case 4: return initializer;
        default: return nullptr;
    }
}

void NewArrayExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: newKeyword = child.token(); return;
        case 1: openBracket = child.token(); return;
        case 2: sizeExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: closeBracket = child.token(); return;
        case 4: initializer = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

NewArrayExpressionSyntax* NewArrayExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NewArrayExpressionSyntax));
    return new (mem) NewArrayExpressionSyntax(*this);
}

bool NewClassExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NewClassExpression;
}

TokenOrSyntax NewClassExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return classScope;
        case 1: return newKeyword;
        case 2: return arguments;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NewClassExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return classScope;
        case 1: return newKeyword;
        case 2: return arguments;
        default: return nullptr;
    }
}

void NewClassExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: classScope = &child.node()->as<ClassScopeSyntax>(); return;
        case 1: newKeyword = child.token(); return;
        case 2: arguments = &child.node()->as<ArgumentListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

NewClassExpressionSyntax* NewClassExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NewClassExpressionSyntax));
    return new (mem) NewClassExpressionSyntax(*this);
}

bool NewExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NewExpression;
}

TokenOrSyntax NewExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return newKeyword;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax NewExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return newKeyword;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void NewExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: newKeyword = child.token(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

NewExpressionSyntax* NewExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NewExpressionSyntax));
    return new (mem) NewExpressionSyntax(*this);
}

bool NonAnsiPortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::NonAnsiPortList;
}

TokenOrSyntax NonAnsiPortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax NonAnsiPortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &ports;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void NonAnsiPortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: ports = child.node()->as<SeparatedSyntaxList<NonAnsiPortSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

NonAnsiPortListSyntax* NonAnsiPortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(NonAnsiPortListSyntax));
    return new (mem) NonAnsiPortListSyntax(*this);
}

bool NonAnsiPortSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ExplicitNonAnsiPort:
        case SyntaxKind::ImplicitNonAnsiPort:
            return true;
        default:
            return false;
    }
}

bool OpenRangeListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::OpenRangeList;
}

TokenOrSyntax OpenRangeListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return &valueRanges;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax OpenRangeListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return &valueRanges;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

void OpenRangeListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: valueRanges = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 2: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

OpenRangeListSyntax* OpenRangeListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(OpenRangeListSyntax));
    return new (mem) OpenRangeListSyntax(*this);
}

bool OrderedArgumentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::OrderedArgument;
}

TokenOrSyntax OrderedArgumentSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax OrderedArgumentSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        default: return nullptr;
    }
}

void OrderedArgumentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

OrderedArgumentSyntax* OrderedArgumentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(OrderedArgumentSyntax));
    return new (mem) OrderedArgumentSyntax(*this);
}

bool OrderedPortConnectionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::OrderedPortConnection;
}

TokenOrSyntax OrderedPortConnectionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax OrderedPortConnectionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void OrderedPortConnectionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

OrderedPortConnectionSyntax* OrderedPortConnectionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(OrderedPortConnectionSyntax));
    return new (mem) OrderedPortConnectionSyntax(*this);
}

bool OrderedStructurePatternMemberSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::OrderedStructurePatternMember;
}

TokenOrSyntax OrderedStructurePatternMemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return pattern.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax OrderedStructurePatternMemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return pattern.get();
        default: return nullptr;
    }
}

void OrderedStructurePatternMemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: pattern = &child.node()->as<PatternSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

OrderedStructurePatternMemberSyntax* OrderedStructurePatternMemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(OrderedStructurePatternMemberSyntax));
    return new (mem) OrderedStructurePatternMemberSyntax(*this);
}

bool PackageImportDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PackageImportDeclaration;
}

TokenOrSyntax PackageImportDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &items;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax PackageImportDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return &items;
        case 3: return semi;
        default: return nullptr;
    }
}

void PackageImportDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: items = child.node()->as<SeparatedSyntaxList<PackageImportItemSyntax>>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

PackageImportDeclarationSyntax* PackageImportDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PackageImportDeclarationSyntax));
    return new (mem) PackageImportDeclarationSyntax(*this);
}

bool PackageImportItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PackageImportItem;
}

TokenOrSyntax PackageImportItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return package;
        case 1: return doubleColon;
        case 2: return item;
        default: return nullptr;
    }
}

ConstTokenOrSyntax PackageImportItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return package;
        case 1: return doubleColon;
        case 2: return item;
        default: return nullptr;
    }
}

void PackageImportItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: package = child.token(); return;
        case 1: doubleColon = child.token(); return;
        case 2: item = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

PackageImportItemSyntax* PackageImportItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PackageImportItemSyntax));
    return new (mem) PackageImportItemSyntax(*this);
}

bool ParameterDeclarationStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParameterDeclarationStatement;
}

TokenOrSyntax ParameterDeclarationStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return parameter.get();
        case 2: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParameterDeclarationStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return parameter.get();
        case 2: return semi;
        default: return nullptr;
    }
}

void ParameterDeclarationStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: parameter = &child.node()->as<ParameterDeclarationSyntax>(); return;
        case 2: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ParameterDeclarationStatementSyntax* ParameterDeclarationStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParameterDeclarationStatementSyntax));
    return new (mem) ParameterDeclarationStatementSyntax(*this);
}

bool ParameterDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParameterDeclaration;
}

TokenOrSyntax ParameterDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return type.get();
        case 2: return &declarators;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParameterDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return type.get();
        case 2: return &declarators;
        default: return nullptr;
    }
}

void ParameterDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
        case 2: declarators = child.node()->as<SeparatedSyntaxList<VariableDeclaratorSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

ParameterDeclarationSyntax* ParameterDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParameterDeclarationSyntax));
    return new (mem) ParameterDeclarationSyntax(*this);
}

bool ParameterPortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParameterPortList;
}

TokenOrSyntax ParameterPortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return hash;
        case 1: return openParen;
        case 2: return &declarations;
        case 3: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParameterPortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return hash;
        case 1: return openParen;
        case 2: return &declarations;
        case 3: return closeParen;
        default: return nullptr;
    }
}

void ParameterPortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: hash = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: declarations = child.node()->as<SeparatedSyntaxList<ParameterDeclarationSyntax>>(); return;
        case 3: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ParameterPortListSyntax* ParameterPortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParameterPortListSyntax));
    return new (mem) ParameterPortListSyntax(*this);
}

bool ParameterValueAssignmentSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParameterValueAssignment;
}

TokenOrSyntax ParameterValueAssignmentSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return hash;
        case 1: return parameters.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParameterValueAssignmentSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return hash;
        case 1: return parameters.get();
        default: return nullptr;
    }
}

void ParameterValueAssignmentSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: hash = child.token(); return;
        case 1: parameters = &child.node()->as<ArgumentListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ParameterValueAssignmentSyntax* ParameterValueAssignmentSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParameterValueAssignmentSyntax));
    return new (mem) ParameterValueAssignmentSyntax(*this);
}

bool ParenImplicitEventControlSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParenImplicitEventControl;
}

TokenOrSyntax ParenImplicitEventControlSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return at;
        case 1: return openParenStarCloseParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParenImplicitEventControlSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return at;
        case 1: return openParenStarCloseParen;
        default: return nullptr;
    }
}

void ParenImplicitEventControlSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: at = child.token(); return;
        case 1: openParenStarCloseParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ParenImplicitEventControlSyntax* ParenImplicitEventControlSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParenImplicitEventControlSyntax));
    return new (mem) ParenImplicitEventControlSyntax(*this);
}

bool ParenthesizedEventExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParenthesizedEventExpression;
}

TokenOrSyntax ParenthesizedEventExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return expr.get();
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParenthesizedEventExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return expr.get();
        case 2: return closeParen;
        default: return nullptr;
    }
}

void ParenthesizedEventExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: expr = &child.node()->as<EventExpressionSyntax>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ParenthesizedEventExpressionSyntax* ParenthesizedEventExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParenthesizedEventExpressionSyntax));
    return new (mem) ParenthesizedEventExpressionSyntax(*this);
}

bool ParenthesizedExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ParenthesizedExpression;
}

TokenOrSyntax ParenthesizedExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return expression.get();
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ParenthesizedExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return expression.get();
        case 2: return closeParen;
        default: return nullptr;
    }
}

void ParenthesizedExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: expression = &child.node()->as<ExpressionSyntax>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ParenthesizedExpressionSyntax* ParenthesizedExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ParenthesizedExpressionSyntax));
    return new (mem) ParenthesizedExpressionSyntax(*this);
}

bool PatternCaseItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PatternCaseItem;
}

TokenOrSyntax PatternCaseItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return pattern.get();
        case 1: return tripleAnd;
        case 2: return expr;
        case 3: return colon;
        case 4: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax PatternCaseItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return pattern.get();
        case 1: return tripleAnd;
        case 2: return expr;
        case 3: return colon;
        case 4: return statement.get();
        default: return nullptr;
    }
}

void PatternCaseItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: pattern = &child.node()->as<PatternSyntax>(); return;
        case 1: tripleAnd = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: colon = child.token(); return;
        case 4: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

PatternCaseItemSyntax* PatternCaseItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PatternCaseItemSyntax));
    return new (mem) PatternCaseItemSyntax(*this);
}

bool PatternSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ExpressionPattern:
        case SyntaxKind::StructurePattern:
        case SyntaxKind::TaggedPattern:
        case SyntaxKind::VariablePattern:
        case SyntaxKind::WildcardPattern:
            return true;
        default:
            return false;
    }
}

bool PortConnectionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::NamedPortConnection:
        case SyntaxKind::OrderedPortConnection:
        case SyntaxKind::WildcardPortConnection:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax PortConnectionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        default: return nullptr;
    }
}

ConstTokenOrSyntax PortConnectionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        default: return nullptr;
    }
}

void PortConnectionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

PortConnectionSyntax* PortConnectionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PortConnectionSyntax));
    return new (mem) PortConnectionSyntax(*this);
}

bool PortDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PortDeclaration;
}

TokenOrSyntax PortDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return header.get();
        case 2: return &declarators;
        case 3: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax PortDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return header.get();
        case 2: return &declarators;
        case 3: return semi;
        default: return nullptr;
    }
}

void PortDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: header = &child.node()->as<PortHeaderSyntax>(); return;
        case 2: declarators = child.node()->as<SeparatedSyntaxList<VariableDeclaratorSyntax>>(); return;
        case 3: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

PortDeclarationSyntax* PortDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PortDeclarationSyntax));
    return new (mem) PortDeclarationSyntax(*this);
}

bool PortHeaderSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::InterconnectPortHeader:
        case SyntaxKind::InterfacePortHeader:
        case SyntaxKind::NetPortHeader:
        case SyntaxKind::VariablePortHeader:
            return true;
        default:
            return false;
    }
}

bool PortListSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AnsiPortList:
        case SyntaxKind::NonAnsiPortList:
        case SyntaxKind::WildcardPortList:
            return true;
        default:
            return false;
    }
}

bool PostfixUnaryExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::PostdecrementExpression:
        case SyntaxKind::PostincrementExpression:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax PostfixUnaryExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return operand.get();
        case 1: return &attributes;
        case 2: return operatorToken;
        default: return nullptr;
    }
}

ConstTokenOrSyntax PostfixUnaryExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return operand.get();
        case 1: return &attributes;
        case 2: return operatorToken;
        default: return nullptr;
    }
}

void PostfixUnaryExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: operand = &child.node()->as<ExpressionSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: operatorToken = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

PostfixUnaryExpressionSyntax* PostfixUnaryExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PostfixUnaryExpressionSyntax));
    return new (mem) PostfixUnaryExpressionSyntax(*this);
}

bool PrefixUnaryExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AcceptOnPropertyExpression:
        case SyntaxKind::AlwaysPropertyExpression:
        case SyntaxKind::EventuallyPropertyExpression:
        case SyntaxKind::NextTimePropertyExpression:
        case SyntaxKind::RejectOnPropertyExpression:
        case SyntaxKind::SAlwaysPropertyExpression:
        case SyntaxKind::SEventuallyPropertyExpression:
        case SyntaxKind::SNextTimePropertyExpression:
        case SyntaxKind::SyncAcceptOnPropertyExpression:
        case SyntaxKind::SyncRejectOnPropertyExpression:
        case SyntaxKind::UnaryBitwiseAndExpression:
        case SyntaxKind::UnaryBitwiseNandExpression:
        case SyntaxKind::UnaryBitwiseNorExpression:
        case SyntaxKind::UnaryBitwiseNotExpression:
        case SyntaxKind::UnaryBitwiseOrExpression:
        case SyntaxKind::UnaryBitwiseXnorExpression:
        case SyntaxKind::UnaryBitwiseXorExpression:
        case SyntaxKind::UnaryLogicalNotExpression:
        case SyntaxKind::UnaryMinusExpression:
        case SyntaxKind::UnaryNotPropertyExpression:
        case SyntaxKind::UnaryPlusExpression:
        case SyntaxKind::UnaryPredecrementExpression:
        case SyntaxKind::UnaryPreincrementExpression:
        case SyntaxKind::UnarySequenceDelayExpression:
        case SyntaxKind::UnarySequenceEventExpression:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax PrefixUnaryExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return operatorToken;
        case 1: return &attributes;
        case 2: return operand.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax PrefixUnaryExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return operatorToken;
        case 1: return &attributes;
        case 2: return operand.get();
        default: return nullptr;
    }
}

void PrefixUnaryExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: operatorToken = child.token(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: operand = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

PrefixUnaryExpressionSyntax* PrefixUnaryExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PrefixUnaryExpressionSyntax));
    return new (mem) PrefixUnaryExpressionSyntax(*this);
}

bool PrimaryBlockEventExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PrimaryBlockEventExpression;
}

TokenOrSyntax PrimaryBlockEventExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return name.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax PrimaryBlockEventExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return name.get();
        default: return nullptr;
    }
}

void PrimaryBlockEventExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: name = &child.node()->as<NameSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

PrimaryBlockEventExpressionSyntax* PrimaryBlockEventExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PrimaryBlockEventExpressionSyntax));
    return new (mem) PrimaryBlockEventExpressionSyntax(*this);
}

bool PrimaryExpressionSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AssignmentPatternExpression:
        case SyntaxKind::ConcatenationExpression:
        case SyntaxKind::DefaultPatternKeyExpression:
        case SyntaxKind::EmptyQueueExpression:
        case SyntaxKind::IntegerLiteralExpression:
        case SyntaxKind::IntegerVectorExpression:
        case SyntaxKind::MultipleConcatenationExpression:
        case SyntaxKind::NullLiteralExpression:
        case SyntaxKind::OneStepLiteralExpression:
        case SyntaxKind::ParenthesizedExpression:
        case SyntaxKind::RealLiteralExpression:
        case SyntaxKind::StreamingConcatenationExpression:
        case SyntaxKind::StringLiteralExpression:
        case SyntaxKind::TimeLiteralExpression:
        case SyntaxKind::UnbasedUnsizedLiteralExpression:
        case SyntaxKind::WildcardLiteralExpression:
            return true;
        default:
            return false;
    }
}

bool ProceduralAssignStatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ProceduralAssignStatement:
        case SyntaxKind::ProceduralForceStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ProceduralAssignStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return lvalue.get();
        case 4: return equals;
        case 5: return value.get();
        case 6: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ProceduralAssignStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return lvalue.get();
        case 4: return equals;
        case 5: return value.get();
        case 6: return semi;
        default: return nullptr;
    }
}

void ProceduralAssignStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: keyword = child.token(); return;
        case 3: lvalue = &child.node()->as<ExpressionSyntax>(); return;
        case 4: equals = child.token(); return;
        case 5: value = &child.node()->as<ExpressionSyntax>(); return;
        case 6: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ProceduralAssignStatementSyntax* ProceduralAssignStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ProceduralAssignStatementSyntax));
    return new (mem) ProceduralAssignStatementSyntax(*this);
}

bool ProceduralBlockSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AlwaysBlock:
        case SyntaxKind::AlwaysCombBlock:
        case SyntaxKind::AlwaysFFBlock:
        case SyntaxKind::AlwaysLatchBlock:
        case SyntaxKind::FinalBlock:
        case SyntaxKind::InitialBlock:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ProceduralBlockSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ProceduralBlockSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return statement.get();
        default: return nullptr;
    }
}

void ProceduralBlockSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ProceduralBlockSyntax* ProceduralBlockSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ProceduralBlockSyntax));
    return new (mem) ProceduralBlockSyntax(*this);
}

bool ProceduralDeassignStatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ProceduralDeassignStatement:
        case SyntaxKind::ProceduralReleaseStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax ProceduralDeassignStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return variable.get();
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ProceduralDeassignStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return keyword;
        case 3: return variable.get();
        case 4: return semi;
        default: return nullptr;
    }
}

void ProceduralDeassignStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: keyword = child.token(); return;
        case 3: variable = &child.node()->as<ExpressionSyntax>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ProceduralDeassignStatementSyntax* ProceduralDeassignStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ProceduralDeassignStatementSyntax));
    return new (mem) ProceduralDeassignStatementSyntax(*this);
}

bool PropertyDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PropertyDeclaration;
}

TokenOrSyntax PropertyDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return name;
        case 3: return portList;
        case 4: return semi;
        case 5: return &assertionVariables;
        case 6: return propertySpec.get();
        case 7: return optionalSemi;
        case 8: return end;
        case 9: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax PropertyDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return name;
        case 3: return portList;
        case 4: return semi;
        case 5: return &assertionVariables;
        case 6: return propertySpec.get();
        case 7: return optionalSemi;
        case 8: return end;
        case 9: return endBlockName;
        default: return nullptr;
    }
}

void PropertyDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: name = child.token(); return;
        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
        case 4: semi = child.token(); return;
        case 5: assertionVariables = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 6: propertySpec = &child.node()->as<PropertySpecSyntax>(); return;
        case 7: optionalSemi = child.token(); return;
        case 8: end = child.token(); return;
        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

PropertyDeclarationSyntax* PropertyDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PropertyDeclarationSyntax));
    return new (mem) PropertyDeclarationSyntax(*this);
}

bool PropertySpecSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::PropertySpec;
}

TokenOrSyntax PropertySpecSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return clocking;
        case 1: return disable;
        case 2: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax PropertySpecSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return clocking;
        case 1: return disable;
        case 2: return expr.get();
        default: return nullptr;
    }
}

void PropertySpecSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: clocking = &child.node()->as<TimingControlSyntax>(); return;
        case 1: disable = &child.node()->as<DisableIffSyntax>(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

PropertySpecSyntax* PropertySpecSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(PropertySpecSyntax));
    return new (mem) PropertySpecSyntax(*this);
}

bool QueueDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::QueueDimensionSpecifier;
}

TokenOrSyntax QueueDimensionSpecifierSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dollar;
        case 1: return maxSizeClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax QueueDimensionSpecifierSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dollar;
        case 1: return maxSizeClause;
        default: return nullptr;
    }
}

void QueueDimensionSpecifierSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dollar = child.token(); return;
        case 1: maxSizeClause = &child.node()->as<ColonExpressionClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

QueueDimensionSpecifierSyntax* QueueDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(QueueDimensionSpecifierSyntax));
    return new (mem) QueueDimensionSpecifierSyntax(*this);
}

bool RandCaseItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::RandCaseItem;
}

TokenOrSyntax RandCaseItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expr.get();
        case 1: return colon;
        case 2: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax RandCaseItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expr.get();
        case 1: return colon;
        case 2: return statement.get();
        default: return nullptr;
    }
}

void RandCaseItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 1: colon = child.token(); return;
        case 2: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

RandCaseItemSyntax* RandCaseItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RandCaseItemSyntax));
    return new (mem) RandCaseItemSyntax(*this);
}

bool RandCaseStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::RandCaseStatement;
}

TokenOrSyntax RandCaseStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return randCase;
        case 3: return &items;
        case 4: return endCase;
        default: return nullptr;
    }
}

ConstTokenOrSyntax RandCaseStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return randCase;
        case 3: return &items;
        case 4: return endCase;
        default: return nullptr;
    }
}

void RandCaseStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: randCase = child.token(); return;
        case 3: items = child.node()->as<SyntaxList<RandCaseItemSyntax>>(); return;
        case 4: endCase = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

RandCaseStatementSyntax* RandCaseStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RandCaseStatementSyntax));
    return new (mem) RandCaseStatementSyntax(*this);
}

bool RandomizeMethodWithClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::RandomizeMethodWithClause;
}

TokenOrSyntax RandomizeMethodWithClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return with;
        case 1: return names;
        case 2: return constraints.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax RandomizeMethodWithClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return with;
        case 1: return names;
        case 2: return constraints.get();
        default: return nullptr;
    }
}

void RandomizeMethodWithClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: with = child.token(); return;
        case 1: names = &child.node()->as<IdentifierListSyntax>(); return;
        case 2: constraints = &child.node()->as<ConstraintBlockSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

RandomizeMethodWithClauseSyntax* RandomizeMethodWithClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RandomizeMethodWithClauseSyntax));
    return new (mem) RandomizeMethodWithClauseSyntax(*this);
}

bool RangeCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::RangeCoverageBinInitializer;
}

TokenOrSyntax RangeCoverageBinInitializerSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return ranges.get();
        case 1: return withClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax RangeCoverageBinInitializerSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return ranges.get();
        case 1: return withClause;
        default: return nullptr;
    }
}

void RangeCoverageBinInitializerSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

RangeCoverageBinInitializerSyntax* RangeCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RangeCoverageBinInitializerSyntax));
    return new (mem) RangeCoverageBinInitializerSyntax(*this);
}

bool RangeDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::RangeDimensionSpecifier;
}

TokenOrSyntax RangeDimensionSpecifierSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return selector.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax RangeDimensionSpecifierSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return selector.get();
        default: return nullptr;
    }
}

void RangeDimensionSpecifierSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: selector = &child.node()->as<SelectorSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

RangeDimensionSpecifierSyntax* RangeDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RangeDimensionSpecifierSyntax));
    return new (mem) RangeDimensionSpecifierSyntax(*this);
}

bool RangeSelectSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AscendingRangeSelect:
        case SyntaxKind::DescendingRangeSelect:
        case SyntaxKind::SimpleRangeSelect:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax RangeSelectSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return range;
        case 2: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax RangeSelectSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return range;
        case 2: return right.get();
        default: return nullptr;
    }
}

void RangeSelectSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: range = child.token(); return;
        case 2: right = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

RangeSelectSyntax* RangeSelectSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RangeSelectSyntax));
    return new (mem) RangeSelectSyntax(*this);
}

bool RepeatedEventControlSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::RepeatedEventControl;
}

TokenOrSyntax RepeatedEventControlSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return repeat;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        case 4: return eventControl;
        default: return nullptr;
    }
}

ConstTokenOrSyntax RepeatedEventControlSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return repeat;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        case 4: return eventControl;
        default: return nullptr;
    }
}

void RepeatedEventControlSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: repeat = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: closeParen = child.token(); return;
        case 4: eventControl = &child.node()->as<TimingControlSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

RepeatedEventControlSyntax* RepeatedEventControlSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(RepeatedEventControlSyntax));
    return new (mem) RepeatedEventControlSyntax(*this);
}

bool ReplicatedAssignmentPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ReplicatedAssignmentPattern;
}

TokenOrSyntax ReplicatedAssignmentPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return countExpr.get();
        case 2: return innerOpenBrace;
        case 3: return &items;
        case 4: return innerCloseBrace;
        case 5: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ReplicatedAssignmentPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return countExpr.get();
        case 2: return innerOpenBrace;
        case 3: return &items;
        case 4: return innerCloseBrace;
        case 5: return closeBrace;
        default: return nullptr;
    }
}

void ReplicatedAssignmentPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: countExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 2: innerOpenBrace = child.token(); return;
        case 3: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 4: innerCloseBrace = child.token(); return;
        case 5: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ReplicatedAssignmentPatternSyntax* ReplicatedAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ReplicatedAssignmentPatternSyntax));
    return new (mem) ReplicatedAssignmentPatternSyntax(*this);
}

bool ReturnStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ReturnStatement;
}

TokenOrSyntax ReturnStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return returnKeyword;
        case 3: return returnValue;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ReturnStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return returnKeyword;
        case 3: return returnValue;
        case 4: return semi;
        default: return nullptr;
    }
}

void ReturnStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: returnKeyword = child.token(); return;
        case 3: returnValue = &child.node()->as<ExpressionSyntax>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ReturnStatementSyntax* ReturnStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ReturnStatementSyntax));
    return new (mem) ReturnStatementSyntax(*this);
}

bool ScopedNameSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ScopedName;
}

TokenOrSyntax ScopedNameSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return separator;
        case 2: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax ScopedNameSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return separator;
        case 2: return right.get();
        default: return nullptr;
    }
}

void ScopedNameSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<NameSyntax>(); return;
        case 1: separator = child.token(); return;
        case 2: right = &child.node()->as<NameSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

ScopedNameSyntax* ScopedNameSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ScopedNameSyntax));
    return new (mem) ScopedNameSyntax(*this);
}

bool SelectorSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AscendingRangeSelect:
        case SyntaxKind::BitSelect:
        case SyntaxKind::DescendingRangeSelect:
        case SyntaxKind::SimpleRangeSelect:
            return true;
        default:
            return false;
    }
}

bool SequenceDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::SequenceDeclaration;
}

TokenOrSyntax SequenceDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return name;
        case 3: return portList;
        case 4: return semi;
        case 5: return &assertionVariables;
        case 6: return seqExpr.get();
        case 7: return optionalSemi;
        case 8: return end;
        case 9: return endBlockName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax SequenceDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return name;
        case 3: return portList;
        case 4: return semi;
        case 5: return &assertionVariables;
        case 6: return seqExpr.get();
        case 7: return optionalSemi;
        case 8: return end;
        case 9: return endBlockName;
        default: return nullptr;
    }
}

void SequenceDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: name = child.token(); return;
        case 3: portList = &child.node()->as<AssertionItemPortListSyntax>(); return;
        case 4: semi = child.token(); return;
        case 5: assertionVariables = child.node()->as<SyntaxList<MemberSyntax>>(); return;
        case 6: seqExpr = &child.node()->as<ExpressionSyntax>(); return;
        case 7: optionalSemi = child.token(); return;
        case 8: end = child.token(); return;
        case 9: endBlockName = &child.node()->as<NamedBlockClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

SequenceDeclarationSyntax* SequenceDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(SequenceDeclarationSyntax));
    return new (mem) SequenceDeclarationSyntax(*this);
}

bool ShortcutCycleDelayRangeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::ShortcutCycleDelayRange;
}

TokenOrSyntax ShortcutCycleDelayRangeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return doubleHash;
        case 1: return openBracket;
        case 2: return op;
        case 3: return closeBracket;
        default: return nullptr;
    }
}

ConstTokenOrSyntax ShortcutCycleDelayRangeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return doubleHash;
        case 1: return openBracket;
        case 2: return op;
        case 3: return closeBracket;
        default: return nullptr;
    }
}

void ShortcutCycleDelayRangeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: doubleHash = child.token(); return;
        case 1: openBracket = child.token(); return;
        case 2: op = child.token(); return;
        case 3: closeBracket = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

ShortcutCycleDelayRangeSyntax* ShortcutCycleDelayRangeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(ShortcutCycleDelayRangeSyntax));
    return new (mem) ShortcutCycleDelayRangeSyntax(*this);
}

bool SignalEventExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::SignalEventExpression;
}

TokenOrSyntax SignalEventExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return edge;
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax SignalEventExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return edge;
        case 1: return expr.get();
        default: return nullptr;
    }
}

void SignalEventExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: edge = child.token(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

SignalEventExpressionSyntax* SignalEventExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(SignalEventExpressionSyntax));
    return new (mem) SignalEventExpressionSyntax(*this);
}

bool SignedCastExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::SignedCastExpression;
}

TokenOrSyntax SignedCastExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return signing;
        case 1: return apostrophe;
        case 2: return inner.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax SignedCastExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return signing;
        case 1: return apostrophe;
        case 2: return inner.get();
        default: return nullptr;
    }
}

void SignedCastExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: signing = child.token(); return;
        case 1: apostrophe = child.token(); return;
        case 2: inner = &child.node()->as<ParenthesizedExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

SignedCastExpressionSyntax* SignedCastExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(SignedCastExpressionSyntax));
    return new (mem) SignedCastExpressionSyntax(*this);
}

bool SimpleAssignmentPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::SimpleAssignmentPattern;
}

TokenOrSyntax SimpleAssignmentPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return &items;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax SimpleAssignmentPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return &items;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

void SimpleAssignmentPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 2: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

SimpleAssignmentPatternSyntax* SimpleAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(SimpleAssignmentPatternSyntax));
    return new (mem) SimpleAssignmentPatternSyntax(*this);
}

bool SimpleDirectiveSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::CellDefineDirective:
        case SyntaxKind::EndCellDefineDirective:
        case SyntaxKind::EndKeywordsDirective:
        case SyntaxKind::NoUnconnectedDriveDirective:
        case SyntaxKind::PragmaDirective:
        case SyntaxKind::ResetAllDirective:
        case SyntaxKind::UnconnectedDriveDirective:
        case SyntaxKind::UndefineAllDirective:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax SimpleDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax SimpleDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return endOfDirective;
        default: return nullptr;
    }
}

void SimpleDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

SimpleDirectiveSyntax* SimpleDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(SimpleDirectiveSyntax));
    return new (mem) SimpleDirectiveSyntax(*this);
}

bool SolveBeforeConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::SolveBeforeConstraint;
}

TokenOrSyntax SolveBeforeConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return solve;
        case 1: return &beforeExpr;
        case 2: return before;
        case 3: return &afterExpr;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax SolveBeforeConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return solve;
        case 1: return &beforeExpr;
        case 2: return before;
        case 3: return &afterExpr;
        case 4: return semi;
        default: return nullptr;
    }
}

void SolveBeforeConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: solve = child.token(); return;
        case 1: beforeExpr = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 2: before = child.token(); return;
        case 3: afterExpr = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

SolveBeforeConstraintSyntax* SolveBeforeConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(SolveBeforeConstraintSyntax));
    return new (mem) SolveBeforeConstraintSyntax(*this);
}

bool StandardCaseItemSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StandardCaseItem;
}

TokenOrSyntax StandardCaseItemSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &expressions;
        case 1: return colon;
        case 2: return clause.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax StandardCaseItemSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &expressions;
        case 1: return colon;
        case 2: return clause.get();
        default: return nullptr;
    }
}

void StandardCaseItemSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expressions = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 1: colon = child.token(); return;
        case 2: clause = &child.node()->as<SyntaxNode>(); return;
        default: THROW_UNREACHABLE;
    }
}

StandardCaseItemSyntax* StandardCaseItemSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StandardCaseItemSyntax));
    return new (mem) StandardCaseItemSyntax(*this);
}

bool StatementSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::AssertPropertyStatement:
        case SyntaxKind::AssumePropertyStatement:
        case SyntaxKind::BlockingEventTriggerStatement:
        case SyntaxKind::CaseStatement:
        case SyntaxKind::ConditionalStatement:
        case SyntaxKind::CoverPropertyStatement:
        case SyntaxKind::CoverSequenceStatement:
        case SyntaxKind::DisableForkStatement:
        case SyntaxKind::DisableStatement:
        case SyntaxKind::DoWhileStatement:
        case SyntaxKind::EmptyStatement:
        case SyntaxKind::ExpectPropertyStatement:
        case SyntaxKind::ExpressionStatement:
        case SyntaxKind::ForLoopStatement:
        case SyntaxKind::ForeachLoopStatement:
        case SyntaxKind::ForeverStatement:
        case SyntaxKind::ImmediateAssertStatement:
        case SyntaxKind::ImmediateAssumeStatement:
        case SyntaxKind::ImmediateCoverStatement:
        case SyntaxKind::JumpStatement:
        case SyntaxKind::LoopStatement:
        case SyntaxKind::NonblockingEventTriggerStatement:
        case SyntaxKind::ParallelBlockStatement:
        case SyntaxKind::ProceduralAssignStatement:
        case SyntaxKind::ProceduralDeassignStatement:
        case SyntaxKind::ProceduralForceStatement:
        case SyntaxKind::ProceduralReleaseStatement:
        case SyntaxKind::RandCaseStatement:
        case SyntaxKind::RestrictPropertyStatement:
        case SyntaxKind::ReturnStatement:
        case SyntaxKind::SequentialBlockStatement:
        case SyntaxKind::TimingControlStatement:
        case SyntaxKind::WaitForkStatement:
        case SyntaxKind::WaitOrderStatement:
        case SyntaxKind::WaitStatement:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax StatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        default: return nullptr;
    }
}

void StatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

StatementSyntax* StatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StatementSyntax));
    return new (mem) StatementSyntax(*this);
}

bool StreamExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StreamExpression;
}

TokenOrSyntax StreamExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return expression.get();
        case 1: return withRange;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StreamExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return expression.get();
        case 1: return withRange;
        default: return nullptr;
    }
}

void StreamExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: expression = &child.node()->as<ExpressionSyntax>(); return;
        case 1: withRange = &child.node()->as<StreamExpressionWithRange>(); return;
        default: THROW_UNREACHABLE;
    }
}

StreamExpressionSyntax* StreamExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StreamExpressionSyntax));
    return new (mem) StreamExpressionSyntax(*this);
}

bool StreamExpressionWithRange::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StreamExpressionWithRange;
}

TokenOrSyntax StreamExpressionWithRange::getChild(uint32_t index) {
    switch (index) {
        case 0: return withKeyword;
        case 1: return range.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax StreamExpressionWithRange::getChild(uint32_t index) const {
    switch (index) {
        case 0: return withKeyword;
        case 1: return range.get();
        default: return nullptr;
    }
}

void StreamExpressionWithRange::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: withKeyword = child.token(); return;
        case 1: range = &child.node()->as<ElementSelectSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

StreamExpressionWithRange* StreamExpressionWithRange::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StreamExpressionWithRange));
    return new (mem) StreamExpressionWithRange(*this);
}

bool StreamingConcatenationExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StreamingConcatenationExpression;
}

TokenOrSyntax StreamingConcatenationExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return operatorToken;
        case 2: return sliceSize;
        case 3: return innerOpenBrace;
        case 4: return &expressions;
        case 5: return innerCloseBrace;
        case 6: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StreamingConcatenationExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return operatorToken;
        case 2: return sliceSize;
        case 3: return innerOpenBrace;
        case 4: return &expressions;
        case 5: return innerCloseBrace;
        case 6: return closeBrace;
        default: return nullptr;
    }
}

void StreamingConcatenationExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: operatorToken = child.token(); return;
        case 2: sliceSize = &child.node()->as<ExpressionSyntax>(); return;
        case 3: innerOpenBrace = child.token(); return;
        case 4: expressions = child.node()->as<SeparatedSyntaxList<StreamExpressionSyntax>>(); return;
        case 5: innerCloseBrace = child.token(); return;
        case 6: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

StreamingConcatenationExpressionSyntax* StreamingConcatenationExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StreamingConcatenationExpressionSyntax));
    return new (mem) StreamingConcatenationExpressionSyntax(*this);
}

bool StructUnionMemberSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StructUnionMember;
}

TokenOrSyntax StructUnionMemberSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return randomQualifier;
        case 2: return type.get();
        case 3: return &declarators;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StructUnionMemberSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return randomQualifier;
        case 2: return type.get();
        case 3: return &declarators;
        case 4: return semi;
        default: return nullptr;
    }
}

void StructUnionMemberSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: randomQualifier = child.token(); return;
        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
        case 3: declarators = child.node()->as<SeparatedSyntaxList<VariableDeclaratorSyntax>>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

StructUnionMemberSyntax* StructUnionMemberSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StructUnionMemberSyntax));
    return new (mem) StructUnionMemberSyntax(*this);
}

bool StructUnionTypeSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::StructType:
        case SyntaxKind::UnionType:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax StructUnionTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return keyword;
        case 1: return tagged;
        case 2: return packed;
        case 3: return signing;
        case 4: return openBrace;
        case 5: return &members;
        case 6: return closeBrace;
        case 7: return &dimensions;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StructUnionTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return keyword;
        case 1: return tagged;
        case 2: return packed;
        case 3: return signing;
        case 4: return openBrace;
        case 5: return &members;
        case 6: return closeBrace;
        case 7: return &dimensions;
        default: return nullptr;
    }
}

void StructUnionTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: keyword = child.token(); return;
        case 1: tagged = child.token(); return;
        case 2: packed = child.token(); return;
        case 3: signing = child.token(); return;
        case 4: openBrace = child.token(); return;
        case 5: members = child.node()->as<SyntaxList<StructUnionMemberSyntax>>(); return;
        case 6: closeBrace = child.token(); return;
        case 7: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        default: THROW_UNREACHABLE;
    }
}

StructUnionTypeSyntax* StructUnionTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StructUnionTypeSyntax));
    return new (mem) StructUnionTypeSyntax(*this);
}

bool StructurePatternMemberSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::NamedStructurePatternMember:
        case SyntaxKind::OrderedStructurePatternMember:
            return true;
        default:
            return false;
    }
}

bool StructurePatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StructurePattern;
}

TokenOrSyntax StructurePatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return &members;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StructurePatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return &members;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

void StructurePatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: members = child.node()->as<SeparatedSyntaxList<StructurePatternMemberSyntax>>(); return;
        case 2: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

StructurePatternSyntax* StructurePatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StructurePatternSyntax));
    return new (mem) StructurePatternSyntax(*this);
}

bool StructuredAssignmentPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::StructuredAssignmentPattern;
}

TokenOrSyntax StructuredAssignmentPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBrace;
        case 1: return &items;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

ConstTokenOrSyntax StructuredAssignmentPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBrace;
        case 1: return &items;
        case 2: return closeBrace;
        default: return nullptr;
    }
}

void StructuredAssignmentPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBrace = child.token(); return;
        case 1: items = child.node()->as<SeparatedSyntaxList<AssignmentPatternItemSyntax>>(); return;
        case 2: closeBrace = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

StructuredAssignmentPatternSyntax* StructuredAssignmentPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(StructuredAssignmentPatternSyntax));
    return new (mem) StructuredAssignmentPatternSyntax(*this);
}

bool TaggedPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TaggedPattern;
}

TokenOrSyntax TaggedPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return tagged;
        case 1: return memberName;
        case 2: return pattern;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TaggedPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return tagged;
        case 1: return memberName;
        case 2: return pattern;
        default: return nullptr;
    }
}

void TaggedPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: tagged = child.token(); return;
        case 1: memberName = child.token(); return;
        case 2: pattern = &child.node()->as<PatternSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TaggedPatternSyntax* TaggedPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TaggedPatternSyntax));
    return new (mem) TaggedPatternSyntax(*this);
}

bool TaggedUnionExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TaggedUnionExpression;
}

TokenOrSyntax TaggedUnionExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return tagged;
        case 1: return member;
        case 2: return expr;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TaggedUnionExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return tagged;
        case 1: return member;
        case 2: return expr;
        default: return nullptr;
    }
}

void TaggedUnionExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: tagged = child.token(); return;
        case 1: member = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TaggedUnionExpressionSyntax* TaggedUnionExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TaggedUnionExpressionSyntax));
    return new (mem) TaggedUnionExpressionSyntax(*this);
}

bool TimeUnitsDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TimeUnitsDeclaration;
}

TokenOrSyntax TimeUnitsDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return time;
        case 3: return divider;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TimeUnitsDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return keyword;
        case 2: return time;
        case 3: return divider;
        case 4: return semi;
        default: return nullptr;
    }
}

void TimeUnitsDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: keyword = child.token(); return;
        case 2: time = child.token(); return;
        case 3: divider = &child.node()->as<DividerClauseSyntax>(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

TimeUnitsDeclarationSyntax* TimeUnitsDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TimeUnitsDeclarationSyntax));
    return new (mem) TimeUnitsDeclarationSyntax(*this);
}

bool TimescaleDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TimescaleDirective;
}

TokenOrSyntax TimescaleDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return timeUnit;
        case 2: return timeUnitUnit;
        case 3: return slash;
        case 4: return timePrecision;
        case 5: return timePrecisionUnit;
        case 6: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TimescaleDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return timeUnit;
        case 2: return timeUnitUnit;
        case 3: return slash;
        case 4: return timePrecision;
        case 5: return timePrecisionUnit;
        case 6: return endOfDirective;
        default: return nullptr;
    }
}

void TimescaleDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: timeUnit = child.token(); return;
        case 2: timeUnitUnit = child.token(); return;
        case 3: slash = child.token(); return;
        case 4: timePrecision = child.token(); return;
        case 5: timePrecisionUnit = child.token(); return;
        case 6: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

TimescaleDirectiveSyntax* TimescaleDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TimescaleDirectiveSyntax));
    return new (mem) TimescaleDirectiveSyntax(*this);
}

bool TimingControlExpressionConcatenationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TimingControlExpressionConcatenation;
}

TokenOrSyntax TimingControlExpressionConcatenationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return left.get();
        case 1: return timing.get();
        case 2: return right.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax TimingControlExpressionConcatenationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return left.get();
        case 1: return timing.get();
        case 2: return right.get();
        default: return nullptr;
    }
}

void TimingControlExpressionConcatenationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: left = &child.node()->as<ExpressionSyntax>(); return;
        case 1: timing = &child.node()->as<TimingControlSyntax>(); return;
        case 2: right = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TimingControlExpressionConcatenationSyntax* TimingControlExpressionConcatenationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TimingControlExpressionConcatenationSyntax));
    return new (mem) TimingControlExpressionConcatenationSyntax(*this);
}

bool TimingControlExpressionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TimingControlExpression;
}

TokenOrSyntax TimingControlExpressionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return timing.get();
        case 1: return expr.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax TimingControlExpressionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return timing.get();
        case 1: return expr.get();
        default: return nullptr;
    }
}

void TimingControlExpressionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: timing = &child.node()->as<TimingControlSyntax>(); return;
        case 1: expr = &child.node()->as<ExpressionSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TimingControlExpressionSyntax* TimingControlExpressionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TimingControlExpressionSyntax));
    return new (mem) TimingControlExpressionSyntax(*this);
}

bool TimingControlStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TimingControlStatement;
}

TokenOrSyntax TimingControlStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return timingControl.get();
        case 3: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax TimingControlStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return timingControl.get();
        case 3: return statement.get();
        default: return nullptr;
    }
}

void TimingControlStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: timingControl = &child.node()->as<TimingControlSyntax>(); return;
        case 3: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TimingControlStatementSyntax* TimingControlStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TimingControlStatementSyntax));
    return new (mem) TimingControlStatementSyntax(*this);
}

bool TimingControlSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::CycleDelay:
        case SyntaxKind::DelayControl:
        case SyntaxKind::EventControl:
        case SyntaxKind::EventControlWithExpression:
        case SyntaxKind::ImplicitEventControl:
        case SyntaxKind::ParenImplicitEventControl:
        case SyntaxKind::RepeatedEventControl:
        case SyntaxKind::ShortcutCycleDelayRange:
            return true;
        default:
            return false;
    }
}

bool TransListCoverageBinInitializerSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TransListCoverageBinInitializer;
}

TokenOrSyntax TransListCoverageBinInitializerSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &sets;
        case 1: return withClause;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TransListCoverageBinInitializerSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &sets;
        case 1: return withClause;
        default: return nullptr;
    }
}

void TransListCoverageBinInitializerSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: sets = child.node()->as<SeparatedSyntaxList<TransSetSyntax>>(); return;
        case 1: withClause = &child.node()->as<WithClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TransListCoverageBinInitializerSyntax* TransListCoverageBinInitializerSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TransListCoverageBinInitializerSyntax));
    return new (mem) TransListCoverageBinInitializerSyntax(*this);
}

bool TransRangeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TransRange;
}

TokenOrSyntax TransRangeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &items;
        case 1: return repeat;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TransRangeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &items;
        case 1: return repeat;
        default: return nullptr;
    }
}

void TransRangeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: items = child.node()->as<SeparatedSyntaxList<ExpressionSyntax>>(); return;
        case 1: repeat = &child.node()->as<TransRepeatRangeSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

TransRangeSyntax* TransRangeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TransRangeSyntax));
    return new (mem) TransRangeSyntax(*this);
}

bool TransRepeatRangeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TransRepeatRange;
}

TokenOrSyntax TransRepeatRangeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBracket;
        case 1: return specifier;
        case 2: return selector;
        case 3: return closeBracket;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TransRepeatRangeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBracket;
        case 1: return specifier;
        case 2: return selector;
        case 3: return closeBracket;
        default: return nullptr;
    }
}

void TransRepeatRangeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBracket = child.token(); return;
        case 1: specifier = child.token(); return;
        case 2: selector = &child.node()->as<SelectorSyntax>(); return;
        case 3: closeBracket = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

TransRepeatRangeSyntax* TransRepeatRangeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TransRepeatRangeSyntax));
    return new (mem) TransRepeatRangeSyntax(*this);
}

bool TransSetSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TransSet;
}

TokenOrSyntax TransSetSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return &ranges;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TransSetSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return &ranges;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void TransSetSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: ranges = child.node()->as<SeparatedSyntaxList<TransRangeSyntax>>(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

TransSetSyntax* TransSetSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TransSetSyntax));
    return new (mem) TransSetSyntax(*this);
}

bool TypeReferenceSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TypeReference;
}

TokenOrSyntax TypeReferenceSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return typeKeyword;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TypeReferenceSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return typeKeyword;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

void TypeReferenceSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: typeKeyword = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

TypeReferenceSyntax* TypeReferenceSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TypeReferenceSyntax));
    return new (mem) TypeReferenceSyntax(*this);
}

bool TypedefDeclarationSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::TypedefDeclaration;
}

TokenOrSyntax TypedefDeclarationSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return typedefKeyword;
        case 2: return type.get();
        case 3: return name;
        case 4: return &dimensions;
        case 5: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax TypedefDeclarationSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return typedefKeyword;
        case 2: return type.get();
        case 3: return name;
        case 4: return &dimensions;
        case 5: return semi;
        default: return nullptr;
    }
}

void TypedefDeclarationSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: typedefKeyword = child.token(); return;
        case 2: type = &child.node()->as<DataTypeSyntax>(); return;
        case 3: name = child.token(); return;
        case 4: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        case 5: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

TypedefDeclarationSyntax* TypedefDeclarationSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(TypedefDeclarationSyntax));
    return new (mem) TypedefDeclarationSyntax(*this);
}

bool UnconditionalBranchDirectiveSyntax::isKind(SyntaxKind kind) {
    switch (kind) {
        case SyntaxKind::ElseDirective:
        case SyntaxKind::EndIfDirective:
            return true;
        default:
            return false;
    }
}

TokenOrSyntax UnconditionalBranchDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return endOfDirective;
        case 2: return &disabledTokens;
        default: return nullptr;
    }
}

ConstTokenOrSyntax UnconditionalBranchDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return endOfDirective;
        case 2: return &disabledTokens;
        default: return nullptr;
    }
}

void UnconditionalBranchDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: endOfDirective = child.token(); return;
        case 2: disabledTokens = child.node()->as<TokenList>(); return;
        default: THROW_UNREACHABLE;
    }
}

UnconditionalBranchDirectiveSyntax* UnconditionalBranchDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(UnconditionalBranchDirectiveSyntax));
    return new (mem) UnconditionalBranchDirectiveSyntax(*this);
}

bool UndefDirectiveSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::UndefDirective;
}

TokenOrSyntax UndefDirectiveSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return directive;
        case 1: return name;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

ConstTokenOrSyntax UndefDirectiveSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return directive;
        case 1: return name;
        case 2: return endOfDirective;
        default: return nullptr;
    }
}

void UndefDirectiveSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: directive = child.token(); return;
        case 1: name = child.token(); return;
        case 2: endOfDirective = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

UndefDirectiveSyntax* UndefDirectiveSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(UndefDirectiveSyntax));
    return new (mem) UndefDirectiveSyntax(*this);
}

bool UniquenessConstraintSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::UniquenessConstraint;
}

TokenOrSyntax UniquenessConstraintSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return unique;
        case 1: return ranges.get();
        case 2: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax UniquenessConstraintSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return unique;
        case 1: return ranges.get();
        case 2: return semi;
        default: return nullptr;
    }
}

void UniquenessConstraintSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: unique = child.token(); return;
        case 1: ranges = &child.node()->as<OpenRangeListSyntax>(); return;
        case 2: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

UniquenessConstraintSyntax* UniquenessConstraintSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(UniquenessConstraintSyntax));
    return new (mem) UniquenessConstraintSyntax(*this);
}

bool VarDataTypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::VarDataType;
}

TokenOrSyntax VarDataTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return var;
        case 1: return type.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax VarDataTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return var;
        case 1: return type.get();
        default: return nullptr;
    }
}

void VarDataTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: var = child.token(); return;
        case 1: type = &child.node()->as<DataTypeSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

VarDataTypeSyntax* VarDataTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(VarDataTypeSyntax));
    return new (mem) VarDataTypeSyntax(*this);
}

bool VariableDeclaratorSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::VariableDeclarator;
}

TokenOrSyntax VariableDeclaratorSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return name;
        case 1: return &dimensions;
        case 2: return initializer;
        default: return nullptr;
    }
}

ConstTokenOrSyntax VariableDeclaratorSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return name;
        case 1: return &dimensions;
        case 2: return initializer;
        default: return nullptr;
    }
}

void VariableDeclaratorSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: name = child.token(); return;
        case 1: dimensions = child.node()->as<SyntaxList<VariableDimensionSyntax>>(); return;
        case 2: initializer = &child.node()->as<EqualsValueClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

VariableDeclaratorSyntax* VariableDeclaratorSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(VariableDeclaratorSyntax));
    return new (mem) VariableDeclaratorSyntax(*this);
}

bool VariableDimensionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::VariableDimension;
}

TokenOrSyntax VariableDimensionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openBracket;
        case 1: return specifier;
        case 2: return closeBracket;
        default: return nullptr;
    }
}

ConstTokenOrSyntax VariableDimensionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openBracket;
        case 1: return specifier;
        case 2: return closeBracket;
        default: return nullptr;
    }
}

void VariableDimensionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openBracket = child.token(); return;
        case 1: specifier = &child.node()->as<DimensionSpecifierSyntax>(); return;
        case 2: closeBracket = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

VariableDimensionSyntax* VariableDimensionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(VariableDimensionSyntax));
    return new (mem) VariableDimensionSyntax(*this);
}

bool VariablePatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::VariablePattern;
}

TokenOrSyntax VariablePatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dot;
        case 1: return variableName;
        default: return nullptr;
    }
}

ConstTokenOrSyntax VariablePatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dot;
        case 1: return variableName;
        default: return nullptr;
    }
}

void VariablePatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dot = child.token(); return;
        case 1: variableName = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

VariablePatternSyntax* VariablePatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(VariablePatternSyntax));
    return new (mem) VariablePatternSyntax(*this);
}

bool VariablePortHeaderSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::VariablePortHeader;
}

TokenOrSyntax VariablePortHeaderSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return direction;
        case 1: return varKeyword;
        case 2: return dataType.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax VariablePortHeaderSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return direction;
        case 1: return varKeyword;
        case 2: return dataType.get();
        default: return nullptr;
    }
}

void VariablePortHeaderSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: direction = child.token(); return;
        case 1: varKeyword = child.token(); return;
        case 2: dataType = &child.node()->as<DataTypeSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

VariablePortHeaderSyntax* VariablePortHeaderSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(VariablePortHeaderSyntax));
    return new (mem) VariablePortHeaderSyntax(*this);
}

bool VirtualInterfaceTypeSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::VirtualInterfaceType;
}

TokenOrSyntax VirtualInterfaceTypeSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return virtualKeyword;
        case 1: return interfaceKeyword;
        case 2: return name;
        case 3: return parameters;
        case 4: return modport;
        default: return nullptr;
    }
}

ConstTokenOrSyntax VirtualInterfaceTypeSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return virtualKeyword;
        case 1: return interfaceKeyword;
        case 2: return name;
        case 3: return parameters;
        case 4: return modport;
        default: return nullptr;
    }
}

void VirtualInterfaceTypeSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: virtualKeyword = child.token(); return;
        case 1: interfaceKeyword = child.token(); return;
        case 2: name = child.token(); return;
        case 3: parameters = &child.node()->as<ParameterValueAssignmentSyntax>(); return;
        case 4: modport = &child.node()->as<DotMemberClauseSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

VirtualInterfaceTypeSyntax* VirtualInterfaceTypeSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(VirtualInterfaceTypeSyntax));
    return new (mem) VirtualInterfaceTypeSyntax(*this);
}

bool WaitForkStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WaitForkStatement;
}

TokenOrSyntax WaitForkStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return wait;
        case 3: return fork;
        case 4: return semi;
        default: return nullptr;
    }
}

ConstTokenOrSyntax WaitForkStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return wait;
        case 3: return fork;
        case 4: return semi;
        default: return nullptr;
    }
}

void WaitForkStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: wait = child.token(); return;
        case 3: fork = child.token(); return;
        case 4: semi = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

WaitForkStatementSyntax* WaitForkStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WaitForkStatementSyntax));
    return new (mem) WaitForkStatementSyntax(*this);
}

bool WaitOrderStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WaitOrderStatement;
}

TokenOrSyntax WaitOrderStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return wait_order;
        case 3: return openParen;
        case 4: return &names;
        case 5: return closeParen;
        case 6: return action.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax WaitOrderStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return wait_order;
        case 3: return openParen;
        case 4: return &names;
        case 5: return closeParen;
        case 6: return action.get();
        default: return nullptr;
    }
}

void WaitOrderStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: wait_order = child.token(); return;
        case 3: openParen = child.token(); return;
        case 4: names = child.node()->as<SeparatedSyntaxList<NameSyntax>>(); return;
        case 5: closeParen = child.token(); return;
        case 6: action = &child.node()->as<ActionBlockSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

WaitOrderStatementSyntax* WaitOrderStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WaitOrderStatementSyntax));
    return new (mem) WaitOrderStatementSyntax(*this);
}

bool WaitStatementSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WaitStatement;
}

TokenOrSyntax WaitStatementSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return wait;
        case 3: return openParen;
        case 4: return expr.get();
        case 5: return closeParen;
        case 6: return statement.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax WaitStatementSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return label;
        case 1: return &attributes;
        case 2: return wait;
        case 3: return openParen;
        case 4: return expr.get();
        case 5: return closeParen;
        case 6: return statement.get();
        default: return nullptr;
    }
}

void WaitStatementSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: label = &child.node()->as<NamedLabelSyntax>(); return;
        case 1: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 2: wait = child.token(); return;
        case 3: openParen = child.token(); return;
        case 4: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 5: closeParen = child.token(); return;
        case 6: statement = &child.node()->as<StatementSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

WaitStatementSyntax* WaitStatementSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WaitStatementSyntax));
    return new (mem) WaitStatementSyntax(*this);
}

bool WildcardDimensionSpecifierSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WildcardDimensionSpecifier;
}

TokenOrSyntax WildcardDimensionSpecifierSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return star;
        default: return nullptr;
    }
}

ConstTokenOrSyntax WildcardDimensionSpecifierSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return star;
        default: return nullptr;
    }
}

void WildcardDimensionSpecifierSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: star = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

WildcardDimensionSpecifierSyntax* WildcardDimensionSpecifierSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WildcardDimensionSpecifierSyntax));
    return new (mem) WildcardDimensionSpecifierSyntax(*this);
}

bool WildcardPatternSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WildcardPattern;
}

TokenOrSyntax WildcardPatternSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return dotStar;
        default: return nullptr;
    }
}

ConstTokenOrSyntax WildcardPatternSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return dotStar;
        default: return nullptr;
    }
}

void WildcardPatternSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: dotStar = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

WildcardPatternSyntax* WildcardPatternSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WildcardPatternSyntax));
    return new (mem) WildcardPatternSyntax(*this);
}

bool WildcardPortConnectionSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WildcardPortConnection;
}

TokenOrSyntax WildcardPortConnectionSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return &attributes;
        case 1: return dotStar;
        default: return nullptr;
    }
}

ConstTokenOrSyntax WildcardPortConnectionSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return &attributes;
        case 1: return dotStar;
        default: return nullptr;
    }
}

void WildcardPortConnectionSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: attributes = child.node()->as<SyntaxList<AttributeInstanceSyntax>>(); return;
        case 1: dotStar = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

WildcardPortConnectionSyntax* WildcardPortConnectionSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WildcardPortConnectionSyntax));
    return new (mem) WildcardPortConnectionSyntax(*this);
}

bool WildcardPortListSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WildcardPortList;
}

TokenOrSyntax WildcardPortListSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return openParen;
        case 1: return dotStar;
        case 2: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax WildcardPortListSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return openParen;
        case 1: return dotStar;
        case 2: return closeParen;
        default: return nullptr;
    }
}

void WildcardPortListSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: openParen = child.token(); return;
        case 1: dotStar = child.token(); return;
        case 2: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

WildcardPortListSyntax* WildcardPortListSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WildcardPortListSyntax));
    return new (mem) WildcardPortListSyntax(*this);
}

bool WithClauseSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WithClause;
}

TokenOrSyntax WithClauseSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return with;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

ConstTokenOrSyntax WithClauseSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return with;
        case 1: return openParen;
        case 2: return expr.get();
        case 3: return closeParen;
        default: return nullptr;
    }
}

void WithClauseSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: with = child.token(); return;
        case 1: openParen = child.token(); return;
        case 2: expr = &child.node()->as<ExpressionSyntax>(); return;
        case 3: closeParen = child.token(); return;
        default: THROW_UNREACHABLE;
    }
}

WithClauseSyntax* WithClauseSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WithClauseSyntax));
    return new (mem) WithClauseSyntax(*this);
}

bool WithFunctionSampleSyntax::isKind(SyntaxKind kind) {
    return kind == SyntaxKind::WithFunctionSample;
}

TokenOrSyntax WithFunctionSampleSyntax::getChild(uint32_t index) {
    switch (index) {
        case 0: return with;
        case 1: return function;
        case 2: return sample;
        case 3: return portList.get();
        default: return nullptr;
    }
}

ConstTokenOrSyntax WithFunctionSampleSyntax::getChild(uint32_t index) const {
    switch (index) {
        case 0: return with;
        case 1: return function;
        case 2: return sample;
        case 3: return portList.get();
        default: return nullptr;
    }
}

void WithFunctionSampleSyntax::setChild(uint32_t index, TokenOrSyntax child) {
    switch (index) {
        case 0: with = child.token(); return;
        case 1: function = child.token(); return;
        case 2: sample = child.token(); return;
        case 3: portList = &child.node()->as<AnsiPortListSyntax>(); return;
        default: THROW_UNREACHABLE;
    }
}

WithFunctionSampleSyntax* WithFunctionSampleSyntax::clone(BumpAllocator& alloc) const {
    auto mem = alloc.allocate(sizeof(*this), alignof(WithFunctionSampleSyntax));
    return new (mem) WithFunctionSampleSyntax(*this);
}

ActionBlockSyntax& SyntaxFactory::actionBlock(StatementSyntax* statement, ElseClauseSyntax* elseClause) {
    return *alloc.emplace<ActionBlockSyntax>(statement, elseClause);
}

AnsiPortListSyntax& SyntaxFactory::ansiPortList(Token openParen, SeparatedSyntaxList<MemberSyntax> ports, Token closeParen) {
    return *alloc.emplace<AnsiPortListSyntax>(openParen, ports, closeParen);
}

ArgumentListSyntax& SyntaxFactory::argumentList(Token openParen, SeparatedSyntaxList<ArgumentSyntax> parameters, Token closeParen) {
    return *alloc.emplace<ArgumentListSyntax>(openParen, parameters, closeParen);
}

AssertionItemPortListSyntax& SyntaxFactory::assertionItemPortList(Token openParen, SeparatedSyntaxList<AssertionItemPortSyntax> ports, Token closeParen) {
    return *alloc.emplace<AssertionItemPortListSyntax>(openParen, ports, closeParen);
}

AssertionItemPortSyntax& SyntaxFactory::assertionItemPort(SyntaxList<AttributeInstanceSyntax> attributes, Token local, Token direction, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) {
    return *alloc.emplace<AssertionItemPortSyntax>(attributes, local, direction, type, declarator);
}

AssignmentPatternExpressionSyntax& SyntaxFactory::assignmentPatternExpression(DataTypeSyntax* type, AssignmentPatternSyntax& pattern) {
    return *alloc.emplace<AssignmentPatternExpressionSyntax>(type, pattern);
}

AssignmentPatternItemSyntax& SyntaxFactory::assignmentPatternItem(ExpressionSyntax& key, Token colon, ExpressionSyntax& expr) {
    return *alloc.emplace<AssignmentPatternItemSyntax>(key, colon, expr);
}

AttributeInstanceSyntax& SyntaxFactory::attributeInstance(Token openParen, SeparatedSyntaxList<AttributeSpecSyntax> specs, Token closeParen) {
    return *alloc.emplace<AttributeInstanceSyntax>(openParen, specs, closeParen);
}

AttributeSpecSyntax& SyntaxFactory::attributeSpec(Token name, EqualsValueClauseSyntax* value) {
    return *alloc.emplace<AttributeSpecSyntax>(name, value);
}

BadExpressionSyntax& SyntaxFactory::badExpression(ExpressionSyntax& expr) {
    return *alloc.emplace<BadExpressionSyntax>(expr);
}

BeginKeywordsDirectiveSyntax& SyntaxFactory::beginKeywordsDirective(Token directive, Token versionSpecifier, Token endOfDirective) {
    return *alloc.emplace<BeginKeywordsDirectiveSyntax>(directive, versionSpecifier, endOfDirective);
}

BinaryBlockEventExpressionSyntax& SyntaxFactory::binaryBlockEventExpression(BlockEventExpressionSyntax& left, Token orKeyword, BlockEventExpressionSyntax& right) {
    return *alloc.emplace<BinaryBlockEventExpressionSyntax>(left, orKeyword, right);
}

BinaryEventExpressionSyntax& SyntaxFactory::binaryEventExpression(EventExpressionSyntax& left, Token operatorToken, EventExpressionSyntax& right) {
    return *alloc.emplace<BinaryEventExpressionSyntax>(left, operatorToken, right);
}

BinaryExpressionSyntax& SyntaxFactory::binaryExpression(SyntaxKind kind, ExpressionSyntax& left, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& right) {
    return *alloc.emplace<BinaryExpressionSyntax>(kind, left, operatorToken, attributes, right);
}

BitSelectSyntax& SyntaxFactory::bitSelect(ExpressionSyntax& expr) {
    return *alloc.emplace<BitSelectSyntax>(expr);
}

BlockCoverageEventSyntax& SyntaxFactory::blockCoverageEvent(Token atat, Token openParen, BlockEventExpressionSyntax& expr, Token closeParen) {
    return *alloc.emplace<BlockCoverageEventSyntax>(atat, openParen, expr, closeParen);
}

BlockStatementSyntax& SyntaxFactory::blockStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token begin, NamedBlockClauseSyntax* blockName, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<BlockStatementSyntax>(kind, label, attributes, begin, blockName, items, end, endBlockName);
}

CaseGenerateSyntax& SyntaxFactory::caseGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, SyntaxList<CaseItemSyntax> items, Token endCase) {
    return *alloc.emplace<CaseGenerateSyntax>(attributes, keyword, openParen, condition, closeParen, items, endCase);
}

CaseStatementSyntax& SyntaxFactory::caseStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token caseKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token matchesOrInside, SyntaxList<CaseItemSyntax> items, Token endcase) {
    return *alloc.emplace<CaseStatementSyntax>(label, attributes, uniqueOrPriority, caseKeyword, openParen, expr, closeParen, matchesOrInside, items, endcase);
}

CastExpressionSyntax& SyntaxFactory::castExpression(ExpressionSyntax& left, Token apostrophe, ParenthesizedExpressionSyntax& right) {
    return *alloc.emplace<CastExpressionSyntax>(left, apostrophe, right);
}

ChargeStrengthSyntax& SyntaxFactory::chargeStrength(Token openParen, Token strength, Token closeParen) {
    return *alloc.emplace<ChargeStrengthSyntax>(openParen, strength, closeParen);
}

ClassDeclarationSyntax& SyntaxFactory::classDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token virtualOrInterface, Token classKeyword, Token lifetime, Token name, ParameterPortListSyntax* parameters, ExtendsClauseSyntax* extendsClause, ImplementsClauseSyntax* implementsClause, Token semi, SyntaxList<MemberSyntax> items, Token endClass, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<ClassDeclarationSyntax>(attributes, virtualOrInterface, classKeyword, lifetime, name, parameters, extendsClause, implementsClause, semi, items, endClass, endBlockName);
}

ClassMethodDeclarationSyntax& SyntaxFactory::classMethodDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionDeclarationSyntax& declaration) {
    return *alloc.emplace<ClassMethodDeclarationSyntax>(attributes, qualifiers, declaration);
}

ClassMethodPrototypeSyntax& SyntaxFactory::classMethodPrototype(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, FunctionPrototypeSyntax& prototype, Token semi) {
    return *alloc.emplace<ClassMethodPrototypeSyntax>(attributes, qualifiers, prototype, semi);
}

ClassNameSyntax& SyntaxFactory::className(Token identifier, ParameterValueAssignmentSyntax& parameters) {
    return *alloc.emplace<ClassNameSyntax>(identifier, parameters);
}

ClassPropertyDeclarationSyntax& SyntaxFactory::classPropertyDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, MemberSyntax& declaration) {
    return *alloc.emplace<ClassPropertyDeclarationSyntax>(attributes, qualifiers, declaration);
}

ClassScopeSyntax& SyntaxFactory::classScope(NameSyntax& left, Token separator) {
    return *alloc.emplace<ClassScopeSyntax>(left, separator);
}

ClockingDeclarationSyntax& SyntaxFactory::clockingDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token globalOrDefault, Token clocking, Token blockName, Token at, ParenthesizedEventExpressionSyntax* event, Token eventIdentifier, Token semi, SyntaxList<ClockingItemSyntax> items, Token endClocking, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<ClockingDeclarationSyntax>(attributes, globalOrDefault, clocking, blockName, at, event, eventIdentifier, semi, items, endClocking, endBlockName);
}

ClockingDirectionSyntax& SyntaxFactory::clockingDirection(Token input, ClockingSkewSyntax* inputSkew, Token output, ClockingSkewSyntax* ouputSkew, Token inout) {
    return *alloc.emplace<ClockingDirectionSyntax>(input, inputSkew, output, ouputSkew, inout);
}

ClockingItemSyntax& SyntaxFactory::clockingItem(Token defaultKeyword, ClockingDirectionSyntax* direction, SeparatedSyntaxList<AttributeSpecSyntax> assignments, Token semi, MemberSyntax* declaration) {
    return *alloc.emplace<ClockingItemSyntax>(defaultKeyword, direction, assignments, semi, declaration);
}

ClockingSkewSyntax& SyntaxFactory::clockingSkew(Token edge, Token hash, ExpressionSyntax* value) {
    return *alloc.emplace<ClockingSkewSyntax>(edge, hash, value);
}

ColonExpressionClauseSyntax& SyntaxFactory::colonExpressionClause(Token colon, ExpressionSyntax& expr) {
    return *alloc.emplace<ColonExpressionClauseSyntax>(colon, expr);
}

CompilationUnitSyntax& SyntaxFactory::compilationUnit(SyntaxList<MemberSyntax> members, Token endOfFile) {
    return *alloc.emplace<CompilationUnitSyntax>(members, endOfFile);
}

ConcatenationExpressionSyntax& SyntaxFactory::concatenationExpression(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> expressions, Token closeBrace) {
    return *alloc.emplace<ConcatenationExpressionSyntax>(openBrace, expressions, closeBrace);
}

ConcurrentAssertionMemberSyntax& SyntaxFactory::concurrentAssertionMember(SyntaxList<AttributeInstanceSyntax> attributes, ConcurrentAssertionStatementSyntax& statement) {
    return *alloc.emplace<ConcurrentAssertionMemberSyntax>(attributes, statement);
}

ConcurrentAssertionStatementSyntax& SyntaxFactory::concurrentAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token propertyOrSequence, Token openParen, PropertySpecSyntax& propertySpec, Token closeParen, ActionBlockSyntax& action) {
    return *alloc.emplace<ConcurrentAssertionStatementSyntax>(kind, label, attributes, keyword, propertyOrSequence, openParen, propertySpec, closeParen, action);
}

ConditionalBranchDirectiveSyntax& SyntaxFactory::conditionalBranchDirective(SyntaxKind kind, Token directive, Token name, Token endOfDirective, TokenList disabledTokens) {
    return *alloc.emplace<ConditionalBranchDirectiveSyntax>(kind, directive, name, endOfDirective, disabledTokens);
}

ConditionalConstraintSyntax& SyntaxFactory::conditionalConstraint(Token ifKeyword, Token openParen, ExpressionSyntax& condition, Token closeParen, ConstraintItemSyntax& constraints, ElseConstraintClauseSyntax* elseClause) {
    return *alloc.emplace<ConditionalConstraintSyntax>(ifKeyword, openParen, condition, closeParen, constraints, elseClause);
}

ConditionalExpressionSyntax& SyntaxFactory::conditionalExpression(ConditionalPredicateSyntax& predicate, Token question, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& left, Token colon, ExpressionSyntax& right) {
    return *alloc.emplace<ConditionalExpressionSyntax>(predicate, question, attributes, left, colon, right);
}

ConditionalPatternSyntax& SyntaxFactory::conditionalPattern(ExpressionSyntax& expr, MatchesClauseSyntax* matchesClause) {
    return *alloc.emplace<ConditionalPatternSyntax>(expr, matchesClause);
}

ConditionalPredicateSyntax& SyntaxFactory::conditionalPredicate(SeparatedSyntaxList<ConditionalPatternSyntax> conditions) {
    return *alloc.emplace<ConditionalPredicateSyntax>(conditions);
}

ConditionalStatementSyntax& SyntaxFactory::conditionalStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token uniqueOrPriority, Token ifKeyword, Token openParen, ConditionalPredicateSyntax& predicate, Token closeParen, StatementSyntax& statement, ElseClauseSyntax* elseClause) {
    return *alloc.emplace<ConditionalStatementSyntax>(label, attributes, uniqueOrPriority, ifKeyword, openParen, predicate, closeParen, statement, elseClause);
}

ConstraintBlockSyntax& SyntaxFactory::constraintBlock(Token openBrace, SyntaxList<ConstraintItemSyntax> items, Token closeBrace) {
    return *alloc.emplace<ConstraintBlockSyntax>(openBrace, items, closeBrace);
}

ConstraintDeclarationSyntax& SyntaxFactory::constraintDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, ConstraintBlockSyntax& block) {
    return *alloc.emplace<ConstraintDeclarationSyntax>(attributes, qualifiers, keyword, name, block);
}

ConstraintPrototypeSyntax& SyntaxFactory::constraintPrototype(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token keyword, Token name, Token semi) {
    return *alloc.emplace<ConstraintPrototypeSyntax>(attributes, qualifiers, keyword, name, semi);
}

ContinuousAssignSyntax& SyntaxFactory::continuousAssign(SyntaxList<AttributeInstanceSyntax> attributes, Token assign, SeparatedSyntaxList<ExpressionSyntax> assignments, Token semi) {
    return *alloc.emplace<ContinuousAssignSyntax>(attributes, assign, assignments, semi);
}

CoverageBinsSyntax& SyntaxFactory::coverageBins(SyntaxList<AttributeInstanceSyntax> attributes, Token wildcard, Token keyword, Token name, ElementSelectSyntax* selector, Token equals, CoverageBinInitializerSyntax& initializer, IffClauseSyntax* iff, Token semi) {
    return *alloc.emplace<CoverageBinsSyntax>(attributes, wildcard, keyword, name, selector, equals, initializer, iff, semi);
}

CoverageOptionSyntax& SyntaxFactory::coverageOption(SyntaxList<AttributeInstanceSyntax> attributes, Token option, Token dot, Token name, Token equals, ExpressionSyntax& expr, Token semi) {
    return *alloc.emplace<CoverageOptionSyntax>(attributes, option, dot, name, equals, expr, semi);
}

CovergroupDeclarationSyntax& SyntaxFactory::covergroupDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token covergroup, Token name, AnsiPortListSyntax* portList, SyntaxNode* event, Token semi, SyntaxList<MemberSyntax> members, Token endgroup, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<CovergroupDeclarationSyntax>(attributes, covergroup, name, portList, event, semi, members, endgroup, endBlockName);
}

CoverpointSyntax& SyntaxFactory::coverpoint(SyntaxList<AttributeInstanceSyntax> attributes, DataTypeSyntax* type, NamedLabelSyntax* label, Token coverpoint, ExpressionSyntax& expr, Token openBrace, SyntaxList<MemberSyntax> members, Token closeBrace, Token emptySemi) {
    return *alloc.emplace<CoverpointSyntax>(attributes, type, label, coverpoint, expr, openBrace, members, closeBrace, emptySemi);
}

DPIImportExportSyntax& SyntaxFactory::dPIImportExport(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token stringLiteral, Token property, Token name, Token equals, FunctionPrototypeSyntax& method, Token semi) {
    return *alloc.emplace<DPIImportExportSyntax>(attributes, keyword, stringLiteral, property, name, equals, method, semi);
}

DataDeclarationSyntax& SyntaxFactory::dataDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, TokenList modifiers, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) {
    return *alloc.emplace<DataDeclarationSyntax>(attributes, modifiers, type, declarators, semi);
}

DefParamAssignmentSyntax& SyntaxFactory::defParamAssignment(NameSyntax& name, EqualsValueClauseSyntax* setter) {
    return *alloc.emplace<DefParamAssignmentSyntax>(name, setter);
}

DefParamSyntax& SyntaxFactory::defParam(SyntaxList<AttributeInstanceSyntax> attributes, Token defparam, SeparatedSyntaxList<DefParamAssignmentSyntax> assignments, Token semi) {
    return *alloc.emplace<DefParamSyntax>(attributes, defparam, assignments, semi);
}

DefaultCaseItemSyntax& SyntaxFactory::defaultCaseItem(Token defaultKeyword, Token colon, SyntaxNode& clause) {
    return *alloc.emplace<DefaultCaseItemSyntax>(defaultKeyword, colon, clause);
}

DefaultCoverageBinInitializerSyntax& SyntaxFactory::defaultCoverageBinInitializer(Token defaultKeyword, Token sequenceKeyword) {
    return *alloc.emplace<DefaultCoverageBinInitializerSyntax>(defaultKeyword, sequenceKeyword);
}

DefaultNetTypeDirectiveSyntax& SyntaxFactory::defaultNetTypeDirective(Token directive, Token netType, Token endOfDirective) {
    return *alloc.emplace<DefaultNetTypeDirectiveSyntax>(directive, netType, endOfDirective);
}

DeferredAssertionSyntax& SyntaxFactory::deferredAssertion(Token hash, Token zero, Token finalKeyword) {
    return *alloc.emplace<DeferredAssertionSyntax>(hash, zero, finalKeyword);
}

DefineDirectiveSyntax& SyntaxFactory::defineDirective(Token directive, Token name, MacroFormalArgumentListSyntax* formalArguments, TokenList body, Token endOfDirective) {
    return *alloc.emplace<DefineDirectiveSyntax>(directive, name, formalArguments, body, endOfDirective);
}

DelaySyntax& SyntaxFactory::delay(SyntaxKind kind, Token hash, ExpressionSyntax& delayValue) {
    return *alloc.emplace<DelaySyntax>(kind, hash, delayValue);
}

DisableConstraintSyntax& SyntaxFactory::disableConstraint(Token disable, Token soft, NameSyntax& name, Token semi) {
    return *alloc.emplace<DisableConstraintSyntax>(disable, soft, name, semi);
}

DisableForkStatementSyntax& SyntaxFactory::disableForkStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, Token fork, Token semi) {
    return *alloc.emplace<DisableForkStatementSyntax>(label, attributes, disable, fork, semi);
}

DisableIffSyntax& SyntaxFactory::disableIff(Token disable, Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) {
    return *alloc.emplace<DisableIffSyntax>(disable, iff, openParen, expr, closeParen);
}

DisableStatementSyntax& SyntaxFactory::disableStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token disable, NameSyntax& name, Token semi) {
    return *alloc.emplace<DisableStatementSyntax>(label, attributes, disable, name, semi);
}

DistConstraintListSyntax& SyntaxFactory::distConstraintList(Token dist, Token openBrace, SeparatedSyntaxList<DistItemSyntax> items, Token closeBrace) {
    return *alloc.emplace<DistConstraintListSyntax>(dist, openBrace, items, closeBrace);
}

DistItemSyntax& SyntaxFactory::distItem(ExpressionSyntax& range, DistWeightSyntax* weight) {
    return *alloc.emplace<DistItemSyntax>(range, weight);
}

DistWeightSyntax& SyntaxFactory::distWeight(Token op, ExpressionSyntax& expr) {
    return *alloc.emplace<DistWeightSyntax>(op, expr);
}

DividerClauseSyntax& SyntaxFactory::dividerClause(Token divide, Token value) {
    return *alloc.emplace<DividerClauseSyntax>(divide, value);
}

DoWhileStatementSyntax& SyntaxFactory::doWhileStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token doKeyword, StatementSyntax& statement, Token whileKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen, Token semi) {
    return *alloc.emplace<DoWhileStatementSyntax>(label, attributes, doKeyword, statement, whileKeyword, openParen, expr, closeParen, semi);
}

DotMemberClauseSyntax& SyntaxFactory::dotMemberClause(Token dot, Token member) {
    return *alloc.emplace<DotMemberClauseSyntax>(dot, member);
}

DriveStrengthSyntax& SyntaxFactory::driveStrength(Token openParen, Token strength0, Token comma, Token strength1, Token closeParen) {
    return *alloc.emplace<DriveStrengthSyntax>(openParen, strength0, comma, strength1, closeParen);
}

ElementSelectExpressionSyntax& SyntaxFactory::elementSelectExpression(ExpressionSyntax& left, ElementSelectSyntax& select) {
    return *alloc.emplace<ElementSelectExpressionSyntax>(left, select);
}

ElementSelectSyntax& SyntaxFactory::elementSelect(Token openBracket, SelectorSyntax* selector, Token closeBracket) {
    return *alloc.emplace<ElementSelectSyntax>(openBracket, selector, closeBracket);
}

ElseClauseSyntax& SyntaxFactory::elseClause(Token elseKeyword, SyntaxNode& clause) {
    return *alloc.emplace<ElseClauseSyntax>(elseKeyword, clause);
}

ElseConstraintClauseSyntax& SyntaxFactory::elseConstraintClause(Token elseKeyword, ConstraintItemSyntax& constraints) {
    return *alloc.emplace<ElseConstraintClauseSyntax>(elseKeyword, constraints);
}

EmptyArgumentSyntax& SyntaxFactory::emptyArgument() {
    return *alloc.emplace<EmptyArgumentSyntax>();
}

EmptyIdentifierNameSyntax& SyntaxFactory::emptyIdentifierName() {
    return *alloc.emplace<EmptyIdentifierNameSyntax>();
}

EmptyMemberSyntax& SyntaxFactory::emptyMember(SyntaxList<AttributeInstanceSyntax> attributes, TokenList qualifiers, Token semi) {
    return *alloc.emplace<EmptyMemberSyntax>(attributes, qualifiers, semi);
}

EmptyQueueExpressionSyntax& SyntaxFactory::emptyQueueExpression(Token openBrace, Token closeBrace) {
    return *alloc.emplace<EmptyQueueExpressionSyntax>(openBrace, closeBrace);
}

EmptyStatementSyntax& SyntaxFactory::emptyStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token semicolon) {
    return *alloc.emplace<EmptyStatementSyntax>(label, attributes, semicolon);
}

EnumTypeSyntax& SyntaxFactory::enumType(Token keyword, DataTypeSyntax* baseType, Token openBrace, SeparatedSyntaxList<VariableDeclaratorSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) {
    return *alloc.emplace<EnumTypeSyntax>(keyword, baseType, openBrace, members, closeBrace, dimensions);
}

EqualsValueClauseSyntax& SyntaxFactory::equalsValueClause(Token equals, ExpressionSyntax& expr) {
    return *alloc.emplace<EqualsValueClauseSyntax>(equals, expr);
}

EventControlSyntax& SyntaxFactory::eventControl(Token at, NameSyntax& eventName) {
    return *alloc.emplace<EventControlSyntax>(at, eventName);
}

EventControlWithExpressionSyntax& SyntaxFactory::eventControlWithExpression(Token at, EventExpressionSyntax& expr) {
    return *alloc.emplace<EventControlWithExpressionSyntax>(at, expr);
}

EventTriggerStatementSyntax& SyntaxFactory::eventTriggerStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token trigger, TimingControlSyntax* timing, NameSyntax& name) {
    return *alloc.emplace<EventTriggerStatementSyntax>(kind, label, attributes, trigger, timing, name);
}

ExplicitAnsiPortSyntax& SyntaxFactory::explicitAnsiPort(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
    return *alloc.emplace<ExplicitAnsiPortSyntax>(attributes, direction, dot, name, openParen, expr, closeParen);
}

ExplicitNonAnsiPortSyntax& SyntaxFactory::explicitNonAnsiPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
    return *alloc.emplace<ExplicitNonAnsiPortSyntax>(dot, name, openParen, expr, closeParen);
}

ExpressionConstraintSyntax& SyntaxFactory::expressionConstraint(Token soft, ExpressionSyntax& expr, Token semi) {
    return *alloc.emplace<ExpressionConstraintSyntax>(soft, expr, semi);
}

ExpressionCoverageBinInitializerSyntax& SyntaxFactory::expressionCoverageBinInitializer(ExpressionSyntax& expr, WithClauseSyntax* withClause) {
    return *alloc.emplace<ExpressionCoverageBinInitializerSyntax>(expr, withClause);
}

ExpressionOrDistSyntax& SyntaxFactory::expressionOrDist(ExpressionSyntax& expr, DistConstraintListSyntax& distribution) {
    return *alloc.emplace<ExpressionOrDistSyntax>(expr, distribution);
}

ExpressionPatternSyntax& SyntaxFactory::expressionPattern(ExpressionSyntax& expr) {
    return *alloc.emplace<ExpressionPatternSyntax>(expr);
}

ExpressionStatementSyntax& SyntaxFactory::expressionStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr, Token semi) {
    return *alloc.emplace<ExpressionStatementSyntax>(label, attributes, expr, semi);
}

ExtendsClauseSyntax& SyntaxFactory::extendsClause(Token keyword, NameSyntax& baseName, ArgumentListSyntax* arguments) {
    return *alloc.emplace<ExtendsClauseSyntax>(keyword, baseName, arguments);
}

ExternModuleSyntax& SyntaxFactory::externModule(Token externKeyword, ModuleHeaderSyntax& header) {
    return *alloc.emplace<ExternModuleSyntax>(externKeyword, header);
}

ForLoopStatementSyntax& SyntaxFactory::forLoopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token forKeyword, Token openParen, SeparatedSyntaxList<SyntaxNode> initializers, Token semi1, ExpressionSyntax& stopExpr, Token semi2, SeparatedSyntaxList<ExpressionSyntax> steps, Token closeParen, StatementSyntax& statement) {
    return *alloc.emplace<ForLoopStatementSyntax>(label, attributes, forKeyword, openParen, initializers, semi1, stopExpr, semi2, steps, closeParen, statement);
}

ForVariableDeclarationSyntax& SyntaxFactory::forVariableDeclaration(Token varKeyword, DataTypeSyntax& type, VariableDeclaratorSyntax& declarator) {
    return *alloc.emplace<ForVariableDeclarationSyntax>(varKeyword, type, declarator);
}

ForeachLoopListSyntax& SyntaxFactory::foreachLoopList(Token openParen, NameSyntax& arrayName, Token openBracket, SeparatedSyntaxList<NameSyntax> loopVariables, Token closeBracket, Token closeParen) {
    return *alloc.emplace<ForeachLoopListSyntax>(openParen, arrayName, openBracket, loopVariables, closeBracket, closeParen);
}

ForeachLoopStatementSyntax& SyntaxFactory::foreachLoopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ForeachLoopListSyntax& loopList, StatementSyntax& statement) {
    return *alloc.emplace<ForeachLoopStatementSyntax>(label, attributes, keyword, loopList, statement);
}

ForeverStatementSyntax& SyntaxFactory::foreverStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token foreverKeyword, StatementSyntax& statement) {
    return *alloc.emplace<ForeverStatementSyntax>(label, attributes, foreverKeyword, statement);
}

ForwardInterfaceClassTypedefDeclarationSyntax& SyntaxFactory::forwardInterfaceClassTypedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token interfaceKeyword, Token classKeyword, Token name, Token semi) {
    return *alloc.emplace<ForwardInterfaceClassTypedefDeclarationSyntax>(attributes, typedefKeyword, interfaceKeyword, classKeyword, name, semi);
}

ForwardTypedefDeclarationSyntax& SyntaxFactory::forwardTypedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, Token keyword, Token name, Token semi) {
    return *alloc.emplace<ForwardTypedefDeclarationSyntax>(attributes, typedefKeyword, keyword, name, semi);
}

FunctionDeclarationSyntax& SyntaxFactory::functionDeclaration(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, FunctionPrototypeSyntax& prototype, Token semi, SyntaxList<SyntaxNode> items, Token end, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<FunctionDeclarationSyntax>(kind, attributes, prototype, semi, items, end, endBlockName);
}

FunctionPortListSyntax& SyntaxFactory::functionPortList(Token openParen, SeparatedSyntaxList<FunctionPortSyntax> ports, Token closeParen) {
    return *alloc.emplace<FunctionPortListSyntax>(openParen, ports, closeParen);
}

FunctionPortSyntax& SyntaxFactory::functionPort(SyntaxList<AttributeInstanceSyntax> attributes, Token constKeyword, Token direction, Token varKeyword, DataTypeSyntax* dataType, VariableDeclaratorSyntax& declarator) {
    return *alloc.emplace<FunctionPortSyntax>(attributes, constKeyword, direction, varKeyword, dataType, declarator);
}

FunctionPrototypeSyntax& SyntaxFactory::functionPrototype(Token keyword, Token lifetime, DataTypeSyntax* returnType, NameSyntax& name, FunctionPortListSyntax* portList) {
    return *alloc.emplace<FunctionPrototypeSyntax>(keyword, lifetime, returnType, name, portList);
}

GenerateBlockSyntax& SyntaxFactory::generateBlock(SyntaxList<AttributeInstanceSyntax> attributes, NamedLabelSyntax* label, Token begin, NamedBlockClauseSyntax* beginName, SyntaxList<MemberSyntax> members, Token end, NamedBlockClauseSyntax* endName) {
    return *alloc.emplace<GenerateBlockSyntax>(attributes, label, begin, beginName, members, end, endName);
}

GenerateRegionSyntax& SyntaxFactory::generateRegion(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SyntaxList<MemberSyntax> members, Token endgenerate) {
    return *alloc.emplace<GenerateRegionSyntax>(attributes, keyword, members, endgenerate);
}

GenvarDeclarationSyntax& SyntaxFactory::genvarDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token semi) {
    return *alloc.emplace<GenvarDeclarationSyntax>(attributes, keyword, identifiers, semi);
}

HierarchicalInstanceSyntax& SyntaxFactory::hierarchicalInstance(Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token openParen, SeparatedSyntaxList<PortConnectionSyntax> connections, Token closeParen) {
    return *alloc.emplace<HierarchicalInstanceSyntax>(name, dimensions, openParen, connections, closeParen);
}

HierarchyInstantiationSyntax& SyntaxFactory::hierarchyInstantiation(SyntaxList<AttributeInstanceSyntax> attributes, Token type, ParameterValueAssignmentSyntax* parameters, SeparatedSyntaxList<HierarchicalInstanceSyntax> instances, Token semi) {
    return *alloc.emplace<HierarchyInstantiationSyntax>(attributes, type, parameters, instances, semi);
}

IdentifierListSyntax& SyntaxFactory::identifierList(Token openParen, SeparatedSyntaxList<IdentifierNameSyntax> identifiers, Token closeParen) {
    return *alloc.emplace<IdentifierListSyntax>(openParen, identifiers, closeParen);
}

IdentifierNameSyntax& SyntaxFactory::identifierName(Token identifier) {
    return *alloc.emplace<IdentifierNameSyntax>(identifier);
}

IdentifierSelectNameSyntax& SyntaxFactory::identifierSelectName(Token identifier, SyntaxList<ElementSelectSyntax> selectors) {
    return *alloc.emplace<IdentifierSelectNameSyntax>(identifier, selectors);
}

IfGenerateSyntax& SyntaxFactory::ifGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, ExpressionSyntax& condition, Token closeParen, MemberSyntax& block, ElseClauseSyntax* elseClause) {
    return *alloc.emplace<IfGenerateSyntax>(attributes, keyword, openParen, condition, closeParen, block, elseClause);
}

IffClauseSyntax& SyntaxFactory::iffClause(Token iff, Token openParen, ExpressionSyntax& expr, Token closeParen) {
    return *alloc.emplace<IffClauseSyntax>(iff, openParen, expr, closeParen);
}

ImmediateAssertionMemberSyntax& SyntaxFactory::immediateAssertionMember(SyntaxList<AttributeInstanceSyntax> attributes, ImmediateAssertionStatementSyntax& statement) {
    return *alloc.emplace<ImmediateAssertionMemberSyntax>(attributes, statement);
}

ImmediateAssertionStatementSyntax& SyntaxFactory::immediateAssertionStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, DeferredAssertionSyntax* delay, ParenthesizedExpressionSyntax& expr, ActionBlockSyntax& action) {
    return *alloc.emplace<ImmediateAssertionStatementSyntax>(kind, label, attributes, keyword, delay, expr, action);
}

ImplementsClauseSyntax& SyntaxFactory::implementsClause(Token keyword, SeparatedSyntaxList<NameSyntax> interfaces) {
    return *alloc.emplace<ImplementsClauseSyntax>(keyword, interfaces);
}

ImplicationConstraintSyntax& SyntaxFactory::implicationConstraint(ExpressionSyntax& left, Token arrow, ConstraintItemSyntax& constraints) {
    return *alloc.emplace<ImplicationConstraintSyntax>(left, arrow, constraints);
}

ImplicitAnsiPortSyntax& SyntaxFactory::implicitAnsiPort(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, VariableDeclaratorSyntax& declarator) {
    return *alloc.emplace<ImplicitAnsiPortSyntax>(attributes, header, declarator);
}

ImplicitEventControlSyntax& SyntaxFactory::implicitEventControl(Token atStar) {
    return *alloc.emplace<ImplicitEventControlSyntax>(atStar);
}

ImplicitNonAnsiPortSyntax& SyntaxFactory::implicitNonAnsiPort(ExpressionSyntax& expr) {
    return *alloc.emplace<ImplicitNonAnsiPortSyntax>(expr);
}

ImplicitTypeSyntax& SyntaxFactory::implicitType(Token signing, SyntaxList<VariableDimensionSyntax> dimensions) {
    return *alloc.emplace<ImplicitTypeSyntax>(signing, dimensions);
}

IncludeDirectiveSyntax& SyntaxFactory::includeDirective(Token directive, Token fileName, Token endOfDirective) {
    return *alloc.emplace<IncludeDirectiveSyntax>(directive, fileName, endOfDirective);
}

InsideExpressionSyntax& SyntaxFactory::insideExpression(ExpressionSyntax& expr, Token inside, OpenRangeListSyntax& ranges) {
    return *alloc.emplace<InsideExpressionSyntax>(expr, inside, ranges);
}

IntegerTypeSyntax& SyntaxFactory::integerType(SyntaxKind kind, Token keyword, Token signing, SyntaxList<VariableDimensionSyntax> dimensions) {
    return *alloc.emplace<IntegerTypeSyntax>(kind, keyword, signing, dimensions);
}

IntegerVectorExpressionSyntax& SyntaxFactory::integerVectorExpression(Token size, Token base, Token value) {
    return *alloc.emplace<IntegerVectorExpressionSyntax>(size, base, value);
}

InterconnectPortHeaderSyntax& SyntaxFactory::interconnectPortHeader(Token direction, Token interconnect, DataTypeSyntax* type) {
    return *alloc.emplace<InterconnectPortHeaderSyntax>(direction, interconnect, type);
}

InterfacePortHeaderSyntax& SyntaxFactory::interfacePortHeader(Token nameOrKeyword, DotMemberClauseSyntax* modport) {
    return *alloc.emplace<InterfacePortHeaderSyntax>(nameOrKeyword, modport);
}

InvocationExpressionSyntax& SyntaxFactory::invocationExpression(ExpressionSyntax& left, SyntaxList<AttributeInstanceSyntax> attributes, ArgumentListSyntax* arguments) {
    return *alloc.emplace<InvocationExpressionSyntax>(left, attributes, arguments);
}

JumpStatementSyntax& SyntaxFactory::jumpStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token breakOrContinue, Token semi) {
    return *alloc.emplace<JumpStatementSyntax>(label, attributes, breakOrContinue, semi);
}

KeywordNameSyntax& SyntaxFactory::keywordName(SyntaxKind kind, Token keyword) {
    return *alloc.emplace<KeywordNameSyntax>(kind, keyword);
}

KeywordTypeSyntax& SyntaxFactory::keywordType(SyntaxKind kind, Token keyword) {
    return *alloc.emplace<KeywordTypeSyntax>(kind, keyword);
}

LetDeclarationSyntax& SyntaxFactory::letDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token let, Token identifier, AssertionItemPortListSyntax* portList, EqualsValueClauseSyntax& initializer, Token semi) {
    return *alloc.emplace<LetDeclarationSyntax>(attributes, let, identifier, portList, initializer, semi);
}

LineDirectiveSyntax& SyntaxFactory::lineDirective(Token directive, Token lineNumber, Token fileName, Token level, Token endOfDirective) {
    return *alloc.emplace<LineDirectiveSyntax>(directive, lineNumber, fileName, level, endOfDirective);
}

LiteralExpressionSyntax& SyntaxFactory::literalExpression(SyntaxKind kind, Token literal) {
    return *alloc.emplace<LiteralExpressionSyntax>(kind, literal);
}

LoopConstraintSyntax& SyntaxFactory::loopConstraint(Token foreachKeyword, ForeachLoopListSyntax& loopList, ConstraintItemSyntax& constraints) {
    return *alloc.emplace<LoopConstraintSyntax>(foreachKeyword, loopList, constraints);
}

LoopGenerateSyntax& SyntaxFactory::loopGenerate(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token openParen, Token genvar, Token identifier, Token equals, ExpressionSyntax& initialExpr, Token semi1, ExpressionSyntax& stopExpr, Token semi2, ExpressionSyntax& iterationExpr, Token closeParen, MemberSyntax& block) {
    return *alloc.emplace<LoopGenerateSyntax>(attributes, keyword, openParen, genvar, identifier, equals, initialExpr, semi1, stopExpr, semi2, iterationExpr, closeParen, block);
}

LoopStatementSyntax& SyntaxFactory::loopStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token repeatOrWhile, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) {
    return *alloc.emplace<LoopStatementSyntax>(label, attributes, repeatOrWhile, openParen, expr, closeParen, statement);
}

MacroActualArgumentListSyntax& SyntaxFactory::macroActualArgumentList(Token openParen, SeparatedSyntaxList<MacroActualArgumentSyntax> args, Token closeParen) {
    return *alloc.emplace<MacroActualArgumentListSyntax>(openParen, args, closeParen);
}

MacroActualArgumentSyntax& SyntaxFactory::macroActualArgument(TokenList tokens) {
    return *alloc.emplace<MacroActualArgumentSyntax>(tokens);
}

MacroArgumentDefaultSyntax& SyntaxFactory::macroArgumentDefault(Token equals, TokenList tokens) {
    return *alloc.emplace<MacroArgumentDefaultSyntax>(equals, tokens);
}

MacroFormalArgumentListSyntax& SyntaxFactory::macroFormalArgumentList(Token openParen, SeparatedSyntaxList<MacroFormalArgumentSyntax> args, Token closeParen) {
    return *alloc.emplace<MacroFormalArgumentListSyntax>(openParen, args, closeParen);
}

MacroFormalArgumentSyntax& SyntaxFactory::macroFormalArgument(Token name, MacroArgumentDefaultSyntax* defaultValue) {
    return *alloc.emplace<MacroFormalArgumentSyntax>(name, defaultValue);
}

MacroUsageSyntax& SyntaxFactory::macroUsage(Token directive, MacroActualArgumentListSyntax* args) {
    return *alloc.emplace<MacroUsageSyntax>(directive, args);
}

MatchesClauseSyntax& SyntaxFactory::matchesClause(Token matchesKeyword, PatternSyntax& pattern) {
    return *alloc.emplace<MatchesClauseSyntax>(matchesKeyword, pattern);
}

MemberAccessExpressionSyntax& SyntaxFactory::memberAccessExpression(ExpressionSyntax& left, Token dot, Token name) {
    return *alloc.emplace<MemberAccessExpressionSyntax>(left, dot, name);
}

MinTypMaxExpressionSyntax& SyntaxFactory::minTypMaxExpression(ExpressionSyntax& min, Token colon1, ExpressionSyntax& typ, Token colon2, ExpressionSyntax& max) {
    return *alloc.emplace<MinTypMaxExpressionSyntax>(min, colon1, typ, colon2, max);
}

ModportClockingPortSyntax& SyntaxFactory::modportClockingPort(SyntaxList<AttributeInstanceSyntax> attributes, Token clocking, Token name) {
    return *alloc.emplace<ModportClockingPortSyntax>(attributes, clocking, name);
}

ModportDeclarationSyntax& SyntaxFactory::modportDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<ModportItemSyntax> items, Token semi) {
    return *alloc.emplace<ModportDeclarationSyntax>(attributes, keyword, items, semi);
}

ModportExplicitPortSyntax& SyntaxFactory::modportExplicitPort(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
    return *alloc.emplace<ModportExplicitPortSyntax>(dot, name, openParen, expr, closeParen);
}

ModportItemSyntax& SyntaxFactory::modportItem(Token name, AnsiPortListSyntax& ports) {
    return *alloc.emplace<ModportItemSyntax>(name, ports);
}

ModportNamedPortSyntax& SyntaxFactory::modportNamedPort(Token name) {
    return *alloc.emplace<ModportNamedPortSyntax>(name);
}

ModportSimplePortListSyntax& SyntaxFactory::modportSimplePortList(SyntaxList<AttributeInstanceSyntax> attributes, Token direction, SeparatedSyntaxList<ModportPortSyntax> ports) {
    return *alloc.emplace<ModportSimplePortListSyntax>(attributes, direction, ports);
}

ModportSubroutinePortListSyntax& SyntaxFactory::modportSubroutinePortList(SyntaxList<AttributeInstanceSyntax> attributes, Token importExport, SeparatedSyntaxList<ModportPortSyntax> ports) {
    return *alloc.emplace<ModportSubroutinePortListSyntax>(attributes, importExport, ports);
}

ModportSubroutinePortSyntax& SyntaxFactory::modportSubroutinePort(FunctionPrototypeSyntax& prototype) {
    return *alloc.emplace<ModportSubroutinePortSyntax>(prototype);
}

ModuleDeclarationSyntax& SyntaxFactory::moduleDeclaration(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, ModuleHeaderSyntax& header, SyntaxList<MemberSyntax> members, Token endmodule, NamedBlockClauseSyntax* blockName) {
    return *alloc.emplace<ModuleDeclarationSyntax>(kind, attributes, header, members, endmodule, blockName);
}

ModuleHeaderSyntax& SyntaxFactory::moduleHeader(SyntaxKind kind, Token moduleKeyword, Token lifetime, Token name, SyntaxList<PackageImportDeclarationSyntax> imports, ParameterPortListSyntax* parameters, PortListSyntax* ports, Token semi) {
    return *alloc.emplace<ModuleHeaderSyntax>(kind, moduleKeyword, lifetime, name, imports, parameters, ports, semi);
}

MultipleConcatenationExpressionSyntax& SyntaxFactory::multipleConcatenationExpression(Token openBrace, ExpressionSyntax& expression, ConcatenationExpressionSyntax& concatenation, Token closeBrace) {
    return *alloc.emplace<MultipleConcatenationExpressionSyntax>(openBrace, expression, concatenation, closeBrace);
}

NamedArgumentSyntax& SyntaxFactory::namedArgument(Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
    return *alloc.emplace<NamedArgumentSyntax>(dot, name, openParen, expr, closeParen);
}

NamedBlockClauseSyntax& SyntaxFactory::namedBlockClause(Token colon, Token name) {
    return *alloc.emplace<NamedBlockClauseSyntax>(colon, name);
}

NamedLabelSyntax& SyntaxFactory::namedLabel(Token name, Token colon) {
    return *alloc.emplace<NamedLabelSyntax>(name, colon);
}

NamedPortConnectionSyntax& SyntaxFactory::namedPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, Token dot, Token name, Token openParen, ExpressionSyntax* expr, Token closeParen) {
    return *alloc.emplace<NamedPortConnectionSyntax>(attributes, dot, name, openParen, expr, closeParen);
}

NamedStructurePatternMemberSyntax& SyntaxFactory::namedStructurePatternMember(Token name, Token colon, PatternSyntax& pattern) {
    return *alloc.emplace<NamedStructurePatternMemberSyntax>(name, colon, pattern);
}

NamedTypeSyntax& SyntaxFactory::namedType(NameSyntax& name) {
    return *alloc.emplace<NamedTypeSyntax>(name);
}

NetDeclarationSyntax& SyntaxFactory::netDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token netType, NetStrengthSyntax* strength, Token expansionHint, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) {
    return *alloc.emplace<NetDeclarationSyntax>(attributes, netType, strength, expansionHint, type, declarators, semi);
}

NetPortHeaderSyntax& SyntaxFactory::netPortHeader(Token direction, Token netType, DataTypeSyntax& dataType) {
    return *alloc.emplace<NetPortHeaderSyntax>(direction, netType, dataType);
}

NewArrayExpressionSyntax& SyntaxFactory::newArrayExpression(Token newKeyword, Token openBracket, ExpressionSyntax& sizeExpr, Token closeBracket, ParenthesizedExpressionSyntax* initializer) {
    return *alloc.emplace<NewArrayExpressionSyntax>(newKeyword, openBracket, sizeExpr, closeBracket, initializer);
}

NewClassExpressionSyntax& SyntaxFactory::newClassExpression(ClassScopeSyntax* classScope, Token newKeyword, ArgumentListSyntax* arguments) {
    return *alloc.emplace<NewClassExpressionSyntax>(classScope, newKeyword, arguments);
}

NewExpressionSyntax& SyntaxFactory::newExpression(Token newKeyword, ExpressionSyntax& expr) {
    return *alloc.emplace<NewExpressionSyntax>(newKeyword, expr);
}

NonAnsiPortListSyntax& SyntaxFactory::nonAnsiPortList(Token openParen, SeparatedSyntaxList<NonAnsiPortSyntax> ports, Token closeParen) {
    return *alloc.emplace<NonAnsiPortListSyntax>(openParen, ports, closeParen);
}

OpenRangeListSyntax& SyntaxFactory::openRangeList(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> valueRanges, Token closeBrace) {
    return *alloc.emplace<OpenRangeListSyntax>(openBrace, valueRanges, closeBrace);
}

OrderedArgumentSyntax& SyntaxFactory::orderedArgument(ExpressionSyntax& expr) {
    return *alloc.emplace<OrderedArgumentSyntax>(expr);
}

OrderedPortConnectionSyntax& SyntaxFactory::orderedPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& expr) {
    return *alloc.emplace<OrderedPortConnectionSyntax>(attributes, expr);
}

OrderedStructurePatternMemberSyntax& SyntaxFactory::orderedStructurePatternMember(PatternSyntax& pattern) {
    return *alloc.emplace<OrderedStructurePatternMemberSyntax>(pattern);
}

PackageImportDeclarationSyntax& SyntaxFactory::packageImportDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, SeparatedSyntaxList<PackageImportItemSyntax> items, Token semi) {
    return *alloc.emplace<PackageImportDeclarationSyntax>(attributes, keyword, items, semi);
}

PackageImportItemSyntax& SyntaxFactory::packageImportItem(Token package, Token doubleColon, Token item) {
    return *alloc.emplace<PackageImportItemSyntax>(package, doubleColon, item);
}

ParameterDeclarationStatementSyntax& SyntaxFactory::parameterDeclarationStatement(SyntaxList<AttributeInstanceSyntax> attributes, ParameterDeclarationSyntax& parameter, Token semi) {
    return *alloc.emplace<ParameterDeclarationStatementSyntax>(attributes, parameter, semi);
}

ParameterDeclarationSyntax& SyntaxFactory::parameterDeclaration(Token keyword, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators) {
    return *alloc.emplace<ParameterDeclarationSyntax>(keyword, type, declarators);
}

ParameterPortListSyntax& SyntaxFactory::parameterPortList(Token hash, Token openParen, SeparatedSyntaxList<ParameterDeclarationSyntax> declarations, Token closeParen) {
    return *alloc.emplace<ParameterPortListSyntax>(hash, openParen, declarations, closeParen);
}

ParameterValueAssignmentSyntax& SyntaxFactory::parameterValueAssignment(Token hash, ArgumentListSyntax& parameters) {
    return *alloc.emplace<ParameterValueAssignmentSyntax>(hash, parameters);
}

ParenImplicitEventControlSyntax& SyntaxFactory::parenImplicitEventControl(Token at, Token openParenStarCloseParen) {
    return *alloc.emplace<ParenImplicitEventControlSyntax>(at, openParenStarCloseParen);
}

ParenthesizedEventExpressionSyntax& SyntaxFactory::parenthesizedEventExpression(Token openParen, EventExpressionSyntax& expr, Token closeParen) {
    return *alloc.emplace<ParenthesizedEventExpressionSyntax>(openParen, expr, closeParen);
}

ParenthesizedExpressionSyntax& SyntaxFactory::parenthesizedExpression(Token openParen, ExpressionSyntax& expression, Token closeParen) {
    return *alloc.emplace<ParenthesizedExpressionSyntax>(openParen, expression, closeParen);
}

PatternCaseItemSyntax& SyntaxFactory::patternCaseItem(PatternSyntax& pattern, Token tripleAnd, ExpressionSyntax* expr, Token colon, StatementSyntax& statement) {
    return *alloc.emplace<PatternCaseItemSyntax>(pattern, tripleAnd, expr, colon, statement);
}

PortDeclarationSyntax& SyntaxFactory::portDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, PortHeaderSyntax& header, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) {
    return *alloc.emplace<PortDeclarationSyntax>(attributes, header, declarators, semi);
}

PostfixUnaryExpressionSyntax& SyntaxFactory::postfixUnaryExpression(SyntaxKind kind, ExpressionSyntax& operand, SyntaxList<AttributeInstanceSyntax> attributes, Token operatorToken) {
    return *alloc.emplace<PostfixUnaryExpressionSyntax>(kind, operand, attributes, operatorToken);
}

PrefixUnaryExpressionSyntax& SyntaxFactory::prefixUnaryExpression(SyntaxKind kind, Token operatorToken, SyntaxList<AttributeInstanceSyntax> attributes, ExpressionSyntax& operand) {
    return *alloc.emplace<PrefixUnaryExpressionSyntax>(kind, operatorToken, attributes, operand);
}

PrimaryBlockEventExpressionSyntax& SyntaxFactory::primaryBlockEventExpression(Token keyword, NameSyntax& name) {
    return *alloc.emplace<PrimaryBlockEventExpressionSyntax>(keyword, name);
}

ProceduralAssignStatementSyntax& SyntaxFactory::proceduralAssignStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& lvalue, Token equals, ExpressionSyntax& value, Token semi) {
    return *alloc.emplace<ProceduralAssignStatementSyntax>(kind, label, attributes, keyword, lvalue, equals, value, semi);
}

ProceduralBlockSyntax& SyntaxFactory::proceduralBlock(SyntaxKind kind, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, StatementSyntax& statement) {
    return *alloc.emplace<ProceduralBlockSyntax>(kind, attributes, keyword, statement);
}

ProceduralDeassignStatementSyntax& SyntaxFactory::proceduralDeassignStatement(SyntaxKind kind, NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, ExpressionSyntax& variable, Token semi) {
    return *alloc.emplace<ProceduralDeassignStatementSyntax>(kind, label, attributes, keyword, variable, semi);
}

PropertyDeclarationSyntax& SyntaxFactory::propertyDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, PropertySpecSyntax& propertySpec, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<PropertyDeclarationSyntax>(attributes, keyword, name, portList, semi, assertionVariables, propertySpec, optionalSemi, end, endBlockName);
}

PropertySpecSyntax& SyntaxFactory::propertySpec(TimingControlSyntax* clocking, DisableIffSyntax* disable, ExpressionSyntax& expr) {
    return *alloc.emplace<PropertySpecSyntax>(clocking, disable, expr);
}

QueueDimensionSpecifierSyntax& SyntaxFactory::queueDimensionSpecifier(Token dollar, ColonExpressionClauseSyntax* maxSizeClause) {
    return *alloc.emplace<QueueDimensionSpecifierSyntax>(dollar, maxSizeClause);
}

RandCaseItemSyntax& SyntaxFactory::randCaseItem(ExpressionSyntax& expr, Token colon, StatementSyntax& statement) {
    return *alloc.emplace<RandCaseItemSyntax>(expr, colon, statement);
}

RandCaseStatementSyntax& SyntaxFactory::randCaseStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token randCase, SyntaxList<RandCaseItemSyntax> items, Token endCase) {
    return *alloc.emplace<RandCaseStatementSyntax>(label, attributes, randCase, items, endCase);
}

RandomizeMethodWithClauseSyntax& SyntaxFactory::randomizeMethodWithClause(Token with, IdentifierListSyntax* names, ConstraintBlockSyntax& constraints) {
    return *alloc.emplace<RandomizeMethodWithClauseSyntax>(with, names, constraints);
}

RangeCoverageBinInitializerSyntax& SyntaxFactory::rangeCoverageBinInitializer(OpenRangeListSyntax& ranges, WithClauseSyntax* withClause) {
    return *alloc.emplace<RangeCoverageBinInitializerSyntax>(ranges, withClause);
}

RangeDimensionSpecifierSyntax& SyntaxFactory::rangeDimensionSpecifier(SelectorSyntax& selector) {
    return *alloc.emplace<RangeDimensionSpecifierSyntax>(selector);
}

RangeSelectSyntax& SyntaxFactory::rangeSelect(SyntaxKind kind, ExpressionSyntax& left, Token range, ExpressionSyntax& right) {
    return *alloc.emplace<RangeSelectSyntax>(kind, left, range, right);
}

RepeatedEventControlSyntax& SyntaxFactory::repeatedEventControl(Token repeat, Token openParen, ExpressionSyntax& expr, Token closeParen, TimingControlSyntax* eventControl) {
    return *alloc.emplace<RepeatedEventControlSyntax>(repeat, openParen, expr, closeParen, eventControl);
}

ReplicatedAssignmentPatternSyntax& SyntaxFactory::replicatedAssignmentPattern(Token openBrace, ExpressionSyntax& countExpr, Token innerOpenBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token innerCloseBrace, Token closeBrace) {
    return *alloc.emplace<ReplicatedAssignmentPatternSyntax>(openBrace, countExpr, innerOpenBrace, items, innerCloseBrace, closeBrace);
}

ReturnStatementSyntax& SyntaxFactory::returnStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token returnKeyword, ExpressionSyntax* returnValue, Token semi) {
    return *alloc.emplace<ReturnStatementSyntax>(label, attributes, returnKeyword, returnValue, semi);
}

ScopedNameSyntax& SyntaxFactory::scopedName(NameSyntax& left, Token separator, NameSyntax& right) {
    return *alloc.emplace<ScopedNameSyntax>(left, separator, right);
}

SequenceDeclarationSyntax& SyntaxFactory::sequenceDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token name, AssertionItemPortListSyntax* portList, Token semi, SyntaxList<MemberSyntax> assertionVariables, ExpressionSyntax& seqExpr, Token optionalSemi, Token end, NamedBlockClauseSyntax* endBlockName) {
    return *alloc.emplace<SequenceDeclarationSyntax>(attributes, keyword, name, portList, semi, assertionVariables, seqExpr, optionalSemi, end, endBlockName);
}

ShortcutCycleDelayRangeSyntax& SyntaxFactory::shortcutCycleDelayRange(Token doubleHash, Token openBracket, Token op, Token closeBracket) {
    return *alloc.emplace<ShortcutCycleDelayRangeSyntax>(doubleHash, openBracket, op, closeBracket);
}

SignalEventExpressionSyntax& SyntaxFactory::signalEventExpression(Token edge, ExpressionSyntax& expr) {
    return *alloc.emplace<SignalEventExpressionSyntax>(edge, expr);
}

SignedCastExpressionSyntax& SyntaxFactory::signedCastExpression(Token signing, Token apostrophe, ParenthesizedExpressionSyntax& inner) {
    return *alloc.emplace<SignedCastExpressionSyntax>(signing, apostrophe, inner);
}

SimpleAssignmentPatternSyntax& SyntaxFactory::simpleAssignmentPattern(Token openBrace, SeparatedSyntaxList<ExpressionSyntax> items, Token closeBrace) {
    return *alloc.emplace<SimpleAssignmentPatternSyntax>(openBrace, items, closeBrace);
}

SimpleDirectiveSyntax& SyntaxFactory::simpleDirective(SyntaxKind kind, Token directive, Token endOfDirective) {
    return *alloc.emplace<SimpleDirectiveSyntax>(kind, directive, endOfDirective);
}

SolveBeforeConstraintSyntax& SyntaxFactory::solveBeforeConstraint(Token solve, SeparatedSyntaxList<ExpressionSyntax> beforeExpr, Token before, SeparatedSyntaxList<ExpressionSyntax> afterExpr, Token semi) {
    return *alloc.emplace<SolveBeforeConstraintSyntax>(solve, beforeExpr, before, afterExpr, semi);
}

StandardCaseItemSyntax& SyntaxFactory::standardCaseItem(SeparatedSyntaxList<ExpressionSyntax> expressions, Token colon, SyntaxNode& clause) {
    return *alloc.emplace<StandardCaseItemSyntax>(expressions, colon, clause);
}

StreamExpressionSyntax& SyntaxFactory::streamExpression(ExpressionSyntax& expression, StreamExpressionWithRange* withRange) {
    return *alloc.emplace<StreamExpressionSyntax>(expression, withRange);
}

StreamExpressionWithRange& SyntaxFactory::streamExpressionWithRange(Token withKeyword, ElementSelectSyntax& range) {
    return *alloc.emplace<StreamExpressionWithRange>(withKeyword, range);
}

StreamingConcatenationExpressionSyntax& SyntaxFactory::streamingConcatenationExpression(Token openBrace, Token operatorToken, ExpressionSyntax* sliceSize, Token innerOpenBrace, SeparatedSyntaxList<StreamExpressionSyntax> expressions, Token innerCloseBrace, Token closeBrace) {
    return *alloc.emplace<StreamingConcatenationExpressionSyntax>(openBrace, operatorToken, sliceSize, innerOpenBrace, expressions, innerCloseBrace, closeBrace);
}

StructUnionMemberSyntax& SyntaxFactory::structUnionMember(SyntaxList<AttributeInstanceSyntax> attributes, Token randomQualifier, DataTypeSyntax& type, SeparatedSyntaxList<VariableDeclaratorSyntax> declarators, Token semi) {
    return *alloc.emplace<StructUnionMemberSyntax>(attributes, randomQualifier, type, declarators, semi);
}

StructUnionTypeSyntax& SyntaxFactory::structUnionType(SyntaxKind kind, Token keyword, Token tagged, Token packed, Token signing, Token openBrace, SyntaxList<StructUnionMemberSyntax> members, Token closeBrace, SyntaxList<VariableDimensionSyntax> dimensions) {
    return *alloc.emplace<StructUnionTypeSyntax>(kind, keyword, tagged, packed, signing, openBrace, members, closeBrace, dimensions);
}

StructurePatternSyntax& SyntaxFactory::structurePattern(Token openBrace, SeparatedSyntaxList<StructurePatternMemberSyntax> members, Token closeBrace) {
    return *alloc.emplace<StructurePatternSyntax>(openBrace, members, closeBrace);
}

StructuredAssignmentPatternSyntax& SyntaxFactory::structuredAssignmentPattern(Token openBrace, SeparatedSyntaxList<AssignmentPatternItemSyntax> items, Token closeBrace) {
    return *alloc.emplace<StructuredAssignmentPatternSyntax>(openBrace, items, closeBrace);
}

TaggedPatternSyntax& SyntaxFactory::taggedPattern(Token tagged, Token memberName, PatternSyntax* pattern) {
    return *alloc.emplace<TaggedPatternSyntax>(tagged, memberName, pattern);
}

TaggedUnionExpressionSyntax& SyntaxFactory::taggedUnionExpression(Token tagged, Token member, ExpressionSyntax* expr) {
    return *alloc.emplace<TaggedUnionExpressionSyntax>(tagged, member, expr);
}

TimeUnitsDeclarationSyntax& SyntaxFactory::timeUnitsDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token keyword, Token time, DividerClauseSyntax* divider, Token semi) {
    return *alloc.emplace<TimeUnitsDeclarationSyntax>(attributes, keyword, time, divider, semi);
}

TimescaleDirectiveSyntax& SyntaxFactory::timescaleDirective(Token directive, Token timeUnit, Token timeUnitUnit, Token slash, Token timePrecision, Token timePrecisionUnit, Token endOfDirective) {
    return *alloc.emplace<TimescaleDirectiveSyntax>(directive, timeUnit, timeUnitUnit, slash, timePrecision, timePrecisionUnit, endOfDirective);
}

TimingControlExpressionConcatenationSyntax& SyntaxFactory::timingControlExpressionConcatenation(ExpressionSyntax& left, TimingControlSyntax& timing, ExpressionSyntax& right) {
    return *alloc.emplace<TimingControlExpressionConcatenationSyntax>(left, timing, right);
}

TimingControlExpressionSyntax& SyntaxFactory::timingControlExpression(TimingControlSyntax& timing, ExpressionSyntax& expr) {
    return *alloc.emplace<TimingControlExpressionSyntax>(timing, expr);
}

TimingControlStatementSyntax& SyntaxFactory::timingControlStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, TimingControlSyntax& timingControl, StatementSyntax& statement) {
    return *alloc.emplace<TimingControlStatementSyntax>(label, attributes, timingControl, statement);
}

TransListCoverageBinInitializerSyntax& SyntaxFactory::transListCoverageBinInitializer(SeparatedSyntaxList<TransSetSyntax> sets, WithClauseSyntax* withClause) {
    return *alloc.emplace<TransListCoverageBinInitializerSyntax>(sets, withClause);
}

TransRangeSyntax& SyntaxFactory::transRange(SeparatedSyntaxList<ExpressionSyntax> items, TransRepeatRangeSyntax* repeat) {
    return *alloc.emplace<TransRangeSyntax>(items, repeat);
}

TransRepeatRangeSyntax& SyntaxFactory::transRepeatRange(Token openBracket, Token specifier, SelectorSyntax* selector, Token closeBracket) {
    return *alloc.emplace<TransRepeatRangeSyntax>(openBracket, specifier, selector, closeBracket);
}

TransSetSyntax& SyntaxFactory::transSet(Token openParen, SeparatedSyntaxList<TransRangeSyntax> ranges, Token closeParen) {
    return *alloc.emplace<TransSetSyntax>(openParen, ranges, closeParen);
}

TypeReferenceSyntax& SyntaxFactory::typeReference(Token typeKeyword, Token openParen, ExpressionSyntax& expr, Token closeParen) {
    return *alloc.emplace<TypeReferenceSyntax>(typeKeyword, openParen, expr, closeParen);
}

TypedefDeclarationSyntax& SyntaxFactory::typedefDeclaration(SyntaxList<AttributeInstanceSyntax> attributes, Token typedefKeyword, DataTypeSyntax& type, Token name, SyntaxList<VariableDimensionSyntax> dimensions, Token semi) {
    return *alloc.emplace<TypedefDeclarationSyntax>(attributes, typedefKeyword, type, name, dimensions, semi);
}

UnconditionalBranchDirectiveSyntax& SyntaxFactory::unconditionalBranchDirective(SyntaxKind kind, Token directive, Token endOfDirective, TokenList disabledTokens) {
    return *alloc.emplace<UnconditionalBranchDirectiveSyntax>(kind, directive, endOfDirective, disabledTokens);
}

UndefDirectiveSyntax& SyntaxFactory::undefDirective(Token directive, Token name, Token endOfDirective) {
    return *alloc.emplace<UndefDirectiveSyntax>(directive, name, endOfDirective);
}

UniquenessConstraintSyntax& SyntaxFactory::uniquenessConstraint(Token unique, OpenRangeListSyntax& ranges, Token semi) {
    return *alloc.emplace<UniquenessConstraintSyntax>(unique, ranges, semi);
}

VarDataTypeSyntax& SyntaxFactory::varDataType(Token var, DataTypeSyntax& type) {
    return *alloc.emplace<VarDataTypeSyntax>(var, type);
}

VariableDeclaratorSyntax& SyntaxFactory::variableDeclarator(Token name, SyntaxList<VariableDimensionSyntax> dimensions, EqualsValueClauseSyntax* initializer) {
    return *alloc.emplace<VariableDeclaratorSyntax>(name, dimensions, initializer);
}

VariableDimensionSyntax& SyntaxFactory::variableDimension(Token openBracket, DimensionSpecifierSyntax* specifier, Token closeBracket) {
    return *alloc.emplace<VariableDimensionSyntax>(openBracket, specifier, closeBracket);
}

VariablePatternSyntax& SyntaxFactory::variablePattern(Token dot, Token variableName) {
    return *alloc.emplace<VariablePatternSyntax>(dot, variableName);
}

VariablePortHeaderSyntax& SyntaxFactory::variablePortHeader(Token direction, Token varKeyword, DataTypeSyntax& dataType) {
    return *alloc.emplace<VariablePortHeaderSyntax>(direction, varKeyword, dataType);
}

VirtualInterfaceTypeSyntax& SyntaxFactory::virtualInterfaceType(Token virtualKeyword, Token interfaceKeyword, Token name, ParameterValueAssignmentSyntax* parameters, DotMemberClauseSyntax* modport) {
    return *alloc.emplace<VirtualInterfaceTypeSyntax>(virtualKeyword, interfaceKeyword, name, parameters, modport);
}

WaitForkStatementSyntax& SyntaxFactory::waitForkStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token fork, Token semi) {
    return *alloc.emplace<WaitForkStatementSyntax>(label, attributes, wait, fork, semi);
}

WaitOrderStatementSyntax& SyntaxFactory::waitOrderStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait_order, Token openParen, SeparatedSyntaxList<NameSyntax> names, Token closeParen, ActionBlockSyntax& action) {
    return *alloc.emplace<WaitOrderStatementSyntax>(label, attributes, wait_order, openParen, names, closeParen, action);
}

WaitStatementSyntax& SyntaxFactory::waitStatement(NamedLabelSyntax* label, SyntaxList<AttributeInstanceSyntax> attributes, Token wait, Token openParen, ExpressionSyntax& expr, Token closeParen, StatementSyntax& statement) {
    return *alloc.emplace<WaitStatementSyntax>(label, attributes, wait, openParen, expr, closeParen, statement);
}

WildcardDimensionSpecifierSyntax& SyntaxFactory::wildcardDimensionSpecifier(Token star) {
    return *alloc.emplace<WildcardDimensionSpecifierSyntax>(star);
}

WildcardPatternSyntax& SyntaxFactory::wildcardPattern(Token dotStar) {
    return *alloc.emplace<WildcardPatternSyntax>(dotStar);
}

WildcardPortConnectionSyntax& SyntaxFactory::wildcardPortConnection(SyntaxList<AttributeInstanceSyntax> attributes, Token dotStar) {
    return *alloc.emplace<WildcardPortConnectionSyntax>(attributes, dotStar);
}

WildcardPortListSyntax& SyntaxFactory::wildcardPortList(Token openParen, Token dotStar, Token closeParen) {
    return *alloc.emplace<WildcardPortListSyntax>(openParen, dotStar, closeParen);
}

WithClauseSyntax& SyntaxFactory::withClause(Token with, Token openParen, ExpressionSyntax& expr, Token closeParen) {
    return *alloc.emplace<WithClauseSyntax>(with, openParen, expr, closeParen);
}

WithFunctionSampleSyntax& SyntaxFactory::withFunctionSample(Token with, Token function, Token sample, AnsiPortListSyntax& portList) {
    return *alloc.emplace<WithFunctionSampleSyntax>(with, function, sample, portList);
}

}
