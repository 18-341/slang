#!/usr/bin/env python
# This script generates C++ source for parse tree syntax nodes from a data file.

import os

class TypeInfo:
	def __init__(self, processedMembers, members, pointerMembers, final,
				 constructorArgs, base, combinedMembers):
		self.processedMembers = processedMembers
		self.members = members
		self.pointerMembers = pointerMembers
		self.final = final
		self.constructorArgs = constructorArgs
		self.base = base
		self.combinedMembers = combinedMembers

def main():
	ourdir = os.path.dirname(os.path.realpath(__file__))
	inf = open(os.path.join(ourdir, "syntax.txt"))
	outf = open(os.path.join(ourdir, "../source/parsing/AllSyntax.h"), 'w')
	cppf = open(os.path.join(ourdir, "../source/parsing/AllSyntax.cpp"), 'w')

	outf.write('''//------------------------------------------------------------------------------
// AllSyntax.h
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#pragma once

#include "lexing/Token.h"
#include "util/BumpAllocator.h"
#include "SyntaxNode.h"

// This file contains all parse tree syntax nodes.
// It is auto-generated by the syntax_gen.py script under the scripts/ directory.

namespace slang {

''')

	cppf.write('''//------------------------------------------------------------------------------
// AllSyntax.cpp
// All generated syntax node data structures.
//
// File is under the MIT license; see LICENSE for details.
//------------------------------------------------------------------------------
#include "AllSyntax.h"

// This file contains all parse tree syntax node generated definitions.
// It is auto-generated by the syntax_gen.py script under the scripts/ directory.

namespace slang {

''')

	currtype = None
	currkind = None
	currtype_name = None
	tags = None
	alltypes = {}
	kindmap = {}

	alltypes['SyntaxNode'] = TypeInfo(None, None, None, '', None, None, [])

	for line in [x.strip('\n') for x in inf]:
		if line.startswith('//'):
			outf.write(line)
			outf.write('\n\n')
		elif len(line) == 0 or (currtype is not None and line == 'empty'):
			if currtype is not None:
				generate(outf, currtype_name, tags, currtype, alltypes, kindmap)
			currtype = None
			currkind = None
		elif currtype is not None:
			p = line.split(' ')
			if len(p) != 2:
				raise Exception("Two elements per member please.")
			currtype.append(p)
		elif currkind is not None:
			for k in line.split(' '):
				if k in kindmap:
					raise Exception("More than one kind map for {}".format(k))
				kindmap[k] = currkind
		elif line.startswith('forward '):
			outf.write('struct {};\n'.format(line[8:]))
		elif line.startswith('kindmap<'):
			currkind = line[8:line.index('>')]
		else:
			p = line.split(' ')
			currtype_name = p[0]
			tags = p[1:] if len(p) > 1 else None
			currtype = []

	if currtype:
		generate(outf, currtype_name, tags, currtype, alltypes, kindmap)

	cppf.write('uint32_t SyntaxNode::getChildCount() const {\n')
	cppf.write('    switch (kind) {\n')
	cppf.write('        case SyntaxKind::Unknown: return 0;\n')
	cppf.write('        case SyntaxKind::List: return ((const SyntaxListBase*)this)->getChildCount();\n')

	for k,v in sorted(kindmap.items()):
		count = len(alltypes[v].combinedMembers)
		cppf.write('        case SyntaxKind::{}: return {};\n'.format(k, count))

	cppf.write('    }\n')
	cppf.write('    THROW_UNREACHABLE;\n')
	cppf.write('}\n\n')

	reverseKindmap = {}
	for k,v in kindmap.items():
		if v in reverseKindmap:
			reverseKindmap[v].append(k)
		else:
			reverseKindmap[v] = [k]

	for k,v in alltypes.items():
		if not v.final:
			continue

		while v.base != 'SyntaxNode':
			kinds = reverseKindmap[k]
			if v.base in reverseKindmap:
				reverseKindmap[v.base].extend(kinds)
			else:
				reverseKindmap[v.base] = kinds[:]
			k = v.base
			v = alltypes[k]

	# Write out isKind static methods for each derived type
	for k,v in sorted(alltypes.items()):
		if v.base is None:
			continue

		cppf.write('bool {}::isKind(SyntaxKind kind) {{\n'.format(k))
		kinds = set(reverseKindmap[k])
		if len(kinds) == 1:
			cppf.write('    return kind == SyntaxKind::{};\n'.format(list(kinds)[0]))
		else:
			cppf.write('    switch (kind) {\n')
			for kind in sorted(kinds):
				cppf.write('        case SyntaxKind::{}:\n'.format(kind))
			cppf.write('            return true;\n')
			cppf.write('        default:\n')
			cppf.write('            return false;\n')
			cppf.write('    }\n')

		cppf.write('}\n\n')

		if len(v.members) != 0 or v.final != '':
			cppf.write('TokenOrSyntax {}::getChild(uint32_t index) const {{\n'.format(k))
			if len(v.combinedMembers) > 0:
				cppf.write('    switch (index) {\n')

				index = 0
				for m in v.combinedMembers:
					addr = '&' if m[1] in v.pointerMembers else ''
					cppf.write('        case {}: return {}{};\n'.format(index, addr, m[1]))
					index += 1

				cppf.write('        default: return nullptr;\n')
				cppf.write('    }\n')
			else:
				cppf.write('    (void)index;\n')
				cppf.write('    return nullptr;\n')

			cppf.write('}\n\n')

	# Write out syntax factory methods
	outf.write('class SyntaxFactory {\n')
	outf.write('public:\n')
	outf.write('    explicit SyntaxFactory(BumpAllocator& alloc) : alloc(alloc) {}\n')
	outf.write('\n')

	for k,v in sorted(alltypes.items()):
		if not v.final:
			continue

		methodName = k
		if methodName.endswith('Syntax'):
			methodName = methodName[:-6]
		methodName = methodName[:1].lower() + methodName[1:]
		outf.write('    {}& {}({});\n'.format(k, methodName, v.constructorArgs))

		argNames = ' '.join(v.constructorArgs.split(' ')[1::2])
		cppf.write('{}& SyntaxFactory::{}({}) {{\n'.format(k, methodName, v.constructorArgs))
		cppf.write('    return *alloc.emplace<{}>({});\n'.format(k, argNames))
		cppf.write('}\n\n')

	outf.write('\n')
	outf.write('private:\n')
	outf.write('    BumpAllocator& alloc;\n')
	outf.write('};\n\n')

	# Write out a dispatch method to get from SyntaxKind to actual concrete type
	outf.write('namespace detail {\n\n')
	outf.write('template<typename TNode, typename TVisitor, typename... Args>\n')
	outf.write('decltype(auto) visitSyntaxNode(TNode* node, TVisitor& visitor, Args&&... args) {\n')
	outf.write('    static constexpr bool isConst = std::is_const_v<TNode>;')
	outf.write('    switch (node->kind) {\n')
	outf.write('        case SyntaxKind::Unknown: return visitor.visitInvalid(*node, std::forward<Args>(args)...);\n')
	outf.write('        case SyntaxKind::List: return visitor.visit(*static_cast<std::conditional_t<isConst, const SyntaxListBase*, SyntaxListBase*>>(node), std::forward<Args>(args)...);\n')

	for k,v in sorted(kindmap.items()):
		outf.write('        case SyntaxKind::{}: return visitor.visit(*static_cast<'.format(k))
		outf.write('std::conditional_t<isConst, const {0}*, {0}*>>(node), std::forward<Args>(args)...);\n'.format(v))
		alltypes.pop(v, None)

	outf.write('    }\n')
	outf.write('    THROW_UNREACHABLE;\n')
	outf.write('}\n\n')
	outf.write('}\n\n')

	outf.write('template<typename TVisitor, typename... Args>\n')
	outf.write('decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) {\n')
	outf.write('    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);\n')
	outf.write('}\n\n')

	outf.write('template<typename TVisitor, typename... Args>\n')
	outf.write('decltype(auto) SyntaxNode::visit(TVisitor& visitor, Args&&... args) const {\n')
	outf.write('    return detail::visitSyntaxNode(this, visitor, std::forward<Args>(args)...);\n')
	outf.write('}\n\n')

	outf.write('}\n')
	cppf.write('}\n')

	# Do some checking to make sure all types have at least one kind assigned,
	# or has set final=false. We already removed types from alltypes in the
	# loop above.
	for k,v in alltypes.items():
		if v.final:
			print("Type '{}' has no kinds assigned to it.".format(k))

def generate(outf, name, tags, members, alltypes, kindmap):
	tagdict = {}
	if tags:
		for t in tags:
			p = t.split('=')
			tagdict[p[0]] = p[1]

	base = tagdict['base'] if 'base' in tagdict else 'SyntaxNode'
	outf.write('struct {} : public {} {{\n'.format(name, base))

	pointerMembers = set()
	optionalMembers = set()
	processed_members = []
	baseInitializers = ''
	combined = members
	if base != 'SyntaxNode':
		processed_members.extend(alltypes[base].processedMembers)
		pointerMembers = pointerMembers.union(alltypes[base].pointerMembers)
		baseInitializers = ', '.join([x[1] for x in alltypes[base].members])
		if baseInitializers:
			baseInitializers = ', ' + baseInitializers
		combined = alltypes[base].members + members

	for m in members:
		if m[0] == 'token':
			typename = 'Token'
		elif m[0] == 'tokenlist':
			typename = 'TokenList'
			pointerMembers.add(m[1])
		elif m[0].startswith('list<'):
			typename = 'SyntaxList<' + m[0][5:]
			pointerMembers.add(m[1])
		elif m[0].startswith('separated_list<'):
			typename = 'SeparatedSyntaxList<' + m[0][15:]
			pointerMembers.add(m[1])
		else:
			optional = False
			if m[0].endswith('?'):
				optional = True
				m[0] = m[0][:-1]

			if m[0] not in alltypes:
				raise Exception("Unknown type '{}'".format(m[0]))

			if optional:
				typename = m[0] + '*'
				optionalMembers.add(m[1])
			else:
				pointerMembers.add(m[1])
				typename = m[0] + '&'

		l = '{} {}'.format(typename, m[1])
		processed_members.append(l)
		outf.write('    {};\n'.format(l))

	kindArg = 'SyntaxKind kind' if 'kind' not in tagdict else ''
	kindValue = 'kind' if 'kind' not in tagdict else 'SyntaxKind::' + tagdict['kind']

	if 'kind' in tagdict:
		k = tagdict['kind']
		if k in kindmap:
			raise Exception("More than one kind map for {}".format(k))
		kindmap[k] = name

	if kindArg and len(processed_members) > 0:
		kindArg += ', '

	initializers = ', '.join(['{0}({0})'.format(x[1]) for x in members])
	if initializers:
		initializers = ', ' + initializers

	final = ' final'
	if 'final' in tagdict and tagdict['final'] == 'false':
		final = ''

	constructorArgs = '{}{}'.format(kindArg, ', '.join(processed_members))
	alltypes[name] = TypeInfo(processed_members, members, pointerMembers, final,
							  constructorArgs, base, combined)

	outf.write('\n')
	outf.write('    {}({}) :\n'.format(name, constructorArgs))
	outf.write('        {}({}{}){}\n'.format(base, kindValue, baseInitializers, initializers))
	outf.write('    {}\n\n')

	if len(members) == 0 and final == '':
		outf.write('    static bool isKind(SyntaxKind kind);\n')
	else:
		outf.write('    {}(const {}&) = delete;\n'.format(name, name))
		outf.write('    {}& operator=(const {}&) = delete;\n\n'.format(name, name))

		outf.write('    static bool isKind(SyntaxKind kind);\n\n')

		outf.write('    TokenOrSyntax getChild(uint32_t index) const;\n')

	outf.write('};\n\n')

if __name__ == "__main__":
	main()
